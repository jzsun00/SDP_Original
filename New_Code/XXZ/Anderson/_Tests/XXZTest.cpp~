#include <cstdio>
#include <string>
#include <vector>

#include "../../../XXZ/hamiltonians_XXZ.hpp"
#include "../hamiltonians_XXZ.hpp"
#include "arcomp.h"
#include "arlnsmat.h"
#include "arlscomp.h"
#include "lcompsol.h"

using std::complex;
using std::vector;

int main() {
  size_t sites = 3;
  double Jz = 0.2;
  size_t dim = std::pow(2, sites);
  SpinHalfBasis basis(sites);
  //std::cout << "Full Basis:\n" << basis.toString() << std::endl;
  //XXZFullHamiltonian ham0;
  //SpinHalfPolynomial XXZPoly = ham0.makePoly(sites, Jz);

  int n = 8;
  int nnz = 12;
  int * irow = new int[nnz];
  int * pcol = new int[n + 1];
  complex<double> * valA = new complex<double>[nnz];

  ARluNonSymMatrix<complex<double>, double> A(n, nnz, valA, irow, pcol);

  // Defining what we need: the four eigenvectors of A with largest magnitude.

  ARluCompStdEig<double> dprob(4L, A);

  // Finding eigenvalues and eigenvectors.

  dprob.FindEigenvectors();

  // Printing solution.

  Solution(A, dprob);

  size_t sites = 5;
  double Jz = 0.2;
  std::cout << "sites = " << sites << ", Jz = " << Jz << std::endl;
  SpinHalfPolynomial poly = makePoly(sites, Jz);
  std::cout << "poly = " << poly.toString() << std::endl;
  SpinHalfBasis basis(sites);
  basis.init();
  XXZSparseHamiltonian ham(poly, sites, Jz);
  //std::cout << "Creating Hamiltonian, now printing the Hamiltonian" << std::endl;
  //std::cout << "poly = " << ham.getPoly().toString() << std::endl;
  std::cout << "Now constructing the matrix";
  ham.createMatrix(basis);
  std::cout << "Printing the Hamiltonian\n" << ham.toString() << std::endl;
  std::cout << "Test pass!" << std::endl;
  return EXIT_SUCCESS;

}  // main
