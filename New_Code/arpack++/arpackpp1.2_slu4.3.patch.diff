diff -crB arpack++/examples/areig/areig.h arpack++new/examples/areig/areig.h
*** arpack++/examples/areig/areig.h	2000-03-02 14:20:43.000000000 -0500
--- arpack++new/examples/areig/areig.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 292,298 ****
  
        2) Optional input parameters:
  
!       char* which       A parameter thar specifies which of the Ritz values
                          are to be computed. "which" must be set to one of:
                          LM: to find eigenvalues with largest magnitude;
                          SM: to find eigenvalues with smallest magnitude;
--- 292,299 ----
  
        2) Optional input parameters:
  
!       const std::string& which
!                         A parameter thar specifies which of the Ritz values
                          are to be computed. "which" must be set to one of:
                          LM: to find eigenvalues with largest magnitude;
                          SM: to find eigenvalues with smallest magnitude;
***************
*** 359,365 ****
  #ifndef AREIG_H
  #define AREIG_H
  
! 
  #include "arcomp.h"
  #include "arlsmat.h"
  #include "arlnsmat.h"
--- 360,366 ----
  #ifndef AREIG_H
  #define AREIG_H
  
! #include <string>
  #include "arcomp.h"
  #include "arlsmat.h"
  #include "arlnsmat.h"
***************
*** 373,379 ****
  
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnz, arcomplex<ARFLOAT> A[],
!           int irow[], int pcol[], int nev, char* which = "LM", int ncv = 0,
            ARFLOAT tol = 0.0, int maxit = 0, arcomplex<ARFLOAT>* resid = NULL,
            bool AutoShift = true)
  {
--- 374,380 ----
  
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnz, arcomplex<ARFLOAT> A[],
!           int irow[], int pcol[], int nev, const std::string& which = "LM", int ncv = 0,
            ARFLOAT tol = 0.0, int maxit = 0, arcomplex<ARFLOAT>* resid = NULL,
            bool AutoShift = true)
  {
***************
*** 397,403 ****
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnz, arcomplex<ARFLOAT> A[], int irow[], int pcol[],
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, arcomplex<ARFLOAT>* resid = NULL, 
            bool AutoShift = true)
  {
--- 398,404 ----
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnz, arcomplex<ARFLOAT> A[], int irow[], int pcol[],
!           int nev, const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, arcomplex<ARFLOAT>* resid = NULL, 
            bool AutoShift = true)
  {
***************
*** 421,427 ****
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnz, arcomplex<ARFLOAT> A[],
            int irow[], int pcol[], arcomplex<ARFLOAT> sigma, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
  
--- 422,428 ----
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnz, arcomplex<ARFLOAT> A[],
            int irow[], int pcol[], arcomplex<ARFLOAT> sigma, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 444,450 ****
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnz, arcomplex<ARFLOAT> A[], int irow[], int pcol[],
!           arcomplex<ARFLOAT> sigma, int nev, char* which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
--- 445,451 ----
  template <class ARFLOAT>
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnz, arcomplex<ARFLOAT> A[], int irow[], int pcol[],
!           arcomplex<ARFLOAT> sigma, int nev, const std::string& which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
***************
*** 469,476 ****
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnzA,
            arcomplex<ARFLOAT> A[], int irowA[], int pcolA[], int nnzB,
            arcomplex<ARFLOAT> B[], int irowB[], int pcolB[], int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
!           arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 470,478 ----
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnzA,
            arcomplex<ARFLOAT> A[], int irowA[], int pcolA[], int nnzB,
            arcomplex<ARFLOAT> B[], int irowB[], int pcolB[], int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, arcomplex<ARFLOAT>* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
***************
*** 494,501 ****
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnzA, arcomplex<ARFLOAT> A[], int irowA[], int pcolA[],
            int nnzB, arcomplex<ARFLOAT> B[], int irowB[], int pcolB[],
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, arcomplex<ARFLOAT>* resid = NULL, 
            bool AutoShift = true)
  {
  
--- 496,503 ----
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnzA, arcomplex<ARFLOAT> A[], int irowA[], int pcolA[],
            int nnzB, arcomplex<ARFLOAT> B[], int irowB[], int pcolB[],
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, arcomplex<ARFLOAT>* resid = NULL, 
            bool AutoShift = true)
  {
  
***************
*** 520,527 ****
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnzA, arcomplex<ARFLOAT> A[],
            int irowA[], int pcolA[], int nnzB, arcomplex<ARFLOAT> B[],
            int irowB[], int pcolB[], arcomplex<ARFLOAT> sigma, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
!           arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 522,530 ----
  int AREig(arcomplex<ARFLOAT> EigVal[], int n, int nnzA, arcomplex<ARFLOAT> A[],
            int irowA[], int pcolA[], int nnzB, arcomplex<ARFLOAT> B[],
            int irowB[], int pcolB[], arcomplex<ARFLOAT> sigma, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, arcomplex<ARFLOAT>* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
***************
*** 545,551 ****
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnzA, arcomplex<ARFLOAT> A[], int irowA[], int pcolA[],
            int nnzB, arcomplex<ARFLOAT> B[], int irowB[], int pcolB[],
!           arcomplex<ARFLOAT> sigma, int nev, char* which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
--- 548,554 ----
  int AREig(arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT> EigVec[], int n,
            int nnzA, arcomplex<ARFLOAT> A[], int irowA[], int pcolA[],
            int nnzB, arcomplex<ARFLOAT> B[], int irowB[], int pcolB[],
!           arcomplex<ARFLOAT> sigma, int nev, const std::string& which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            arcomplex<ARFLOAT>* resid = NULL, bool AutoShift = true)
  {
***************
*** 569,575 ****
  
  template <class ARFLOAT>
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnz,
!           ARFLOAT A[], int irow[], int pcol[], int nev, char* which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0, 
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
--- 572,579 ----
  
  template <class ARFLOAT>
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnz,
!           ARFLOAT A[], int irow[], int pcol[], int nev,
!           const std::string& which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0, 
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
***************
*** 592,598 ****
  
  template <class ARFLOAT>
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnz,
!           ARFLOAT A[], int irow[], int pcol[], int nev, char* which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0, 
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
--- 596,603 ----
  
  template <class ARFLOAT>
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnz,
!           ARFLOAT A[], int irow[], int pcol[], int nev,
!           const std::string& which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0, 
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
***************
*** 616,622 ****
  template <class ARFLOAT>
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n, 
            int nnz, ARFLOAT A[], int irow[], int pcol[], int nev, 
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0, 
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 621,627 ----
  template <class ARFLOAT>
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n, 
            int nnz, ARFLOAT A[], int irow[], int pcol[], int nev, 
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0, 
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 639,645 ****
  template <class ARFLOAT>
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnz,
            ARFLOAT A[], int irow[], int pcol[], ARFLOAT sigma, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 644,650 ----
  template <class ARFLOAT>
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnz,
            ARFLOAT A[], int irow[], int pcol[], ARFLOAT sigma, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 662,668 ****
  template <class ARFLOAT>
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnz,
            ARFLOAT A[], int irow[], int pcol[], ARFLOAT sigma, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 667,673 ----
  template <class ARFLOAT>
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnz,
            ARFLOAT A[], int irow[], int pcol[], ARFLOAT sigma, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 685,692 ****
  template <class ARFLOAT>
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n, 
            int nnz, ARFLOAT A[], int irow[], int pcol[], ARFLOAT sigma, 
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0, 
!           int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating a matrix in ARPACK++ format.
--- 690,698 ----
  template <class ARFLOAT>
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n, 
            int nnz, ARFLOAT A[], int irow[], int pcol[], ARFLOAT sigma, 
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating a matrix in ARPACK++ format.
***************
*** 709,715 ****
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 715,721 ----
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 734,740 ****
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 740,746 ----
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 759,766 ****
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n,
            int nnzA, ARFLOAT A[], int irowA[], int pcolA[],
            int nnzB, ARFLOAT B[], int irowB[], int pcolB[],
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 765,773 ----
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n,
            int nnzA, ARFLOAT A[], int irowA[], int pcolA[],
            int nnzB, ARFLOAT B[], int irowB[], int pcolB[],
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
***************
*** 784,791 ****
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], ARFLOAT sigma,
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 791,799 ----
  int AREig(double EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], ARFLOAT sigma,
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
***************
*** 810,817 ****
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], ARFLOAT sigma,
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 818,826 ----
  int AREig(float EigValR[], ARFLOAT EigValI[], int n, int nnzA,
            ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], ARFLOAT sigma,
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
***************
*** 836,842 ****
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n,
            int nnzA, ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], ARFLOAT sigma, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 845,851 ----
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n,
            int nnzA, ARFLOAT A[], int irowA[], int pcolA[], int nnzB,
            ARFLOAT B[], int irowB[], int pcolB[], ARFLOAT sigma, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 862,869 ****
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], int n, int nnzA, ARFLOAT A[],
            int irowA[], int pcolA[], int nnzB, ARFLOAT B[], int irowB[],
            int pcolB[], char part, ARFLOAT sigmaR, ARFLOAT sigmaI,
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 871,879 ----
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], int n, int nnzA, ARFLOAT A[],
            int irowA[], int pcolA[], int nnzB, ARFLOAT B[], int irowB[],
            int pcolB[], char part, ARFLOAT sigmaR, ARFLOAT sigmaI,
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
***************
*** 889,897 ****
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n, 
            int nnzA, ARFLOAT A[], int irowA[], int pcolA[], int nnzB, 
            ARFLOAT B[], int irowB[], int pcolB[], char part, ARFLOAT sigmaR, 
!           ARFLOAT sigmaI, int nev, char* which = "LM", int ncv = 0, 
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL, 
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 899,907 ----
  int AREig(ARFLOAT EigValR[], ARFLOAT EigValI[], ARFLOAT EigVec[], int n, 
            int nnzA, ARFLOAT A[], int irowA[], int pcolA[], int nnzB, 
            ARFLOAT B[], int irowB[], int pcolB[], char part, ARFLOAT sigmaR, 
!           ARFLOAT sigmaI, int nev, const std::string& which = "LM",
!           int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
!           ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
***************
*** 915,921 ****
  
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], int n, int nnz, ARFLOAT A[], int irow[],
!           int pcol[], char uplo, int nev, char* which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
--- 925,931 ----
  
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], int n, int nnz, ARFLOAT A[], int irow[],
!           int pcol[], char uplo, int nev, const std::string& which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
***************
*** 939,945 ****
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnz, ARFLOAT A[],
            int irow[], int pcol[], char uplo, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 949,955 ----
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnz, ARFLOAT A[],
            int irow[], int pcol[], char uplo, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 962,968 ****
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], int n, int nnz, ARFLOAT A[], int irow[],
            int pcol[], char uplo, ARFLOAT sigma, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 972,978 ----
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], int n, int nnz, ARFLOAT A[], int irow[],
            int pcol[], char uplo, ARFLOAT sigma, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 985,992 ****
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnz, ARFLOAT A[],
            int irow[], int pcol[], char uplo, ARFLOAT sigma,
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating a matrix in ARPACK++ format.
--- 995,1003 ----
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnz, ARFLOAT A[],
            int irow[], int pcol[], char uplo, ARFLOAT sigma,
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating a matrix in ARPACK++ format.
***************
*** 1008,1014 ****
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], int n, int nnzA, ARFLOAT A[], int irowA[],
            int pcolA[], int nnzB, ARFLOAT B[], int irowB[], int pcolB[],
!           char uplo, int nev, char* which = "LM", int ncv = 0,
            ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
            bool AutoShift = true)
  {
--- 1019,1025 ----
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], int n, int nnzA, ARFLOAT A[], int irowA[],
            int pcolA[], int nnzB, ARFLOAT B[], int irowB[], int pcolB[],
!           char uplo, int nev, const std::string& which = "LM", int ncv = 0,
            ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
            bool AutoShift = true)
  {
***************
*** 1033,1039 ****
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnzA, ARFLOAT A[],
            int irowA[], int pcolA[], int nnzB, ARFLOAT B[], int irowB[],
!           int pcolB[], char uplo, int nev, char* which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
--- 1044,1050 ----
  template <class ARFLOAT>
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnzA, ARFLOAT A[],
            int irowA[], int pcolA[], int nnzB, ARFLOAT B[], int irowB[],
!           int pcolB[], char uplo, int nev, const std::string& which = "LM",
            int ncv = 0, ARFLOAT tol = 0.0, int maxit = 0,
            ARFLOAT* resid = NULL, bool AutoShift = true)
  {
***************
*** 1059,1065 ****
  int AREig(ARFLOAT EigVal[], int n, int nnzA, ARFLOAT A[], int irowA[],
            int pcolA[], int nnzB, ARFLOAT B[], int irowB[], int pcolB[],
            char uplo, char InvertMode, ARFLOAT sigma, int nev,
!           char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
--- 1070,1076 ----
  int AREig(ARFLOAT EigVal[], int n, int nnzA, ARFLOAT A[], int irowA[],
            int pcolA[], int nnzB, ARFLOAT B[], int irowB[], int pcolB[],
            char uplo, char InvertMode, ARFLOAT sigma, int nev,
!           const std::string& which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
            int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
***************
*** 1085,1092 ****
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnzA, ARFLOAT A[],
            int irowA[], int pcolA[], int nnzB, ARFLOAT B[], int irowB[],
            int pcolB[], char uplo, char InvertMode, ARFLOAT sigma,
!           int nev, char* which = "LM", int ncv = 0, ARFLOAT tol = 0.0,
!           int maxit = 0, ARFLOAT* resid = NULL, bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
--- 1096,1104 ----
  int AREig(ARFLOAT EigVal[], ARFLOAT EigVec[], int n, int nnzA, ARFLOAT A[],
            int irowA[], int pcolA[], int nnzB, ARFLOAT B[], int irowB[],
            int pcolB[], char uplo, char InvertMode, ARFLOAT sigma,
!           int nev, const std::string& which = "LM", int ncv = 0,
!           ARFLOAT tol = 0.0, int maxit = 0, ARFLOAT* resid = NULL,
!           bool AutoShift = true)
  {
  
    // Creating two matrices in ARPACK++ format.
diff -crB arpack++/examples/areig/complex/acompsol.h arpack++new/examples/areig/complex/acompsol.h
*** arpack++/examples/areig/complex/acompsol.h	2000-02-21 13:33:35.000000000 -0500
--- arpack++new/examples/areig/complex/acompsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef ACOMPSOL_H
  #define ACOMPSOL_H
  
! #include <math.h>
  #include "arcomp.h"
  #include "blas1c.h"
  #include "lapackc.h"
--- 18,24 ----
  #ifndef ACOMPSOL_H
  #define ACOMPSOL_H
  
! #include <cmath>
  #include "arcomp.h"
  #include "blas1c.h"
  #include "lapackc.h"
***************
*** 30,36 ****
                arcomplex<ARFLOAT>* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
!   on standard "cout" stream.
  */
  
  {
--- 30,36 ----
                arcomplex<ARFLOAT>* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 40,59 ****
    ARFLOAT*                                      ResNorm;
    ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> matrix(n, nnz, A, irow, pcol);
  
!   cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
!   cout << "complex standard eigenvalue problem: A*x - lambda*x \n \n";
  
!   cout << "Dimension of the system            : " << n     << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
  
    // Printing eigenvalues.
  
!   cout << "Eigenvalues:" << endl;
  
    for (i=0; i<nconv; i++) {
!     cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
    }
!   cout << endl;
  
    // Printing eigenvectors.
  
--- 40,59 ----
    ARFLOAT*                                      ResNorm;
    ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> matrix(n, nnz, A, irow, pcol);
  
!   std::cout<< std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
!   std::cout<< "complex standard eigenvalue problem: A*x - lambda*x \n \n";
  
!   std::cout<< "Dimension of the system            : " << n     << std::endl;
!   std::cout<< "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
  
    // Printing eigenvalues.
  
!   std::cout<< "Eigenvalues:" << std::endl;
  
    for (i=0; i<nconv; i++) {
!     std::cout<< "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
    }
!   std::cout<< std::endl;
  
    // Printing eigenvectors.
  
***************
*** 72,81 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] ResNorm;
--- 72,81 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout<< "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout<< ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout<< std::endl;
  
      delete[] Ax;
      delete[] ResNorm;
***************
*** 92,98 ****
                arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT>* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problem on standard "cout" stream.
  */
  
  {
--- 92,98 ----
                arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT>* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problem on standard "std::cout" stream.
  */
  
  {
***************
*** 104,123 ****
    ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA);
    ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB);
  
!   cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
!   cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x \n \n";
  
!   cout << "Dimension of the system            : " << n     << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
  
    // Printing eigenvalues.
  
!   cout << "Eigenvalues:" << endl;
  
    for (i=0; i<nconv; i++) {
!     cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
    }
!   cout << endl;
  
    // Printing eigenvectors.
  
--- 104,123 ----
    ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA);
    ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB);
  
!   std::cout<< std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
!   std::cout<< "Complex generalized eigenvalue problem: A*x - lambda*B*x \n \n";
  
!   std::cout<< "Dimension of the system            : " << n     << std::endl;
!   std::cout<< "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
  
    // Printing eigenvalues.
  
!   std::cout<< "Eigenvalues:" << std::endl;
  
    for (i=0; i<nconv; i++) {
!     std::cout<< "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
    }
!   std::cout<< std::endl;
  
    // Printing eigenvectors.
  
***************
*** 138,147 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << i << ") - lambda(" << i;
!       cout << ")*B*x(" << i << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] Bx;
--- 138,147 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout<< "||A*x(" << i << ") - lambda(" << i;
!       std::cout<< ")*B*x(" << i << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout<< std::endl;
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/areig/complex/Makefile arpack++new/examples/areig/complex/Makefile
*** arpack++/examples/areig/complex/Makefile	2000-02-18 15:22:18.000000000 -0500
--- arpack++new/examples/areig/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 36,42 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 36,42 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core acompgre acompgsh acompreg acompshf
  
  # defining pattern rules.
  
diff -crB arpack++/examples/areig/nonsym/ansymsol.h arpack++new/examples/areig/nonsym/ansymsol.h
*** arpack++/examples/areig/nonsym/ansymsol.h	2000-02-21 13:45:48.000000000 -0500
--- arpack++new/examples/areig/nonsym/ansymsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef ANSYMSOL_H
  #define ANSYMSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "arlnsmat.h"
--- 18,24 ----
  #ifndef ANSYMSOL_H
  #define ANSYMSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "arlnsmat.h"
***************
*** 29,35 ****
                ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problem
!   on standard "cout" stream.
  */
  
  {
--- 29,35 ----
                ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problem
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 39,64 ****
    ARFLOAT*                           ResNorm;
    ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrix(n, nnz, A, irow, pcol);
  
!   cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
!   cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x \n \n";
  
!   cout << "Dimension of the system            : " << n     << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
  
    // Printing eigenvalues.
  
!   cout << "Eigenvalues:" << endl;
  
    for (i=0; i<nconv; i++) {
!     cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
      if (EigValI[i]>=0.0) {
!       cout << " + " << EigValI[i] << " I" << endl;
      }
      else {
!       cout << " - " << fabs(EigValI[i]) << " I" << endl;
      }
    }
!   cout << endl;
  
    // Printing eigenvectors.
  
--- 39,64 ----
    ARFLOAT*                           ResNorm;
    ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrix(n, nnz, A, irow, pcol);
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
!   std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x \n \n";
  
!   std::cout << "Dimension of the system            : " << n     << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
  
    // Printing eigenvalues.
  
!   std::cout << "Eigenvalues:" << std::endl;
  
    for (i=0; i<nconv; i++) {
!     std::cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
      if (EigValI[i]>=0.0) {
!       std::cout << " + " << EigValI[i] << " I" << std::endl;
      }
      else {
!       std::cout << " - " << fabs(EigValI[i]) << " I" << std::endl;
      }
    }
!   std::cout << std::endl;
  
    // Printing eigenvectors.
  
***************
*** 97,106 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] ResNorm;
--- 97,106 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] ResNorm;
***************
*** 117,123 ****
                ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problem on standard "cout" stream.
  */
  
  {
--- 117,123 ----
                ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problem on standard "std::cout" stream.
  */
  
  {
***************
*** 129,155 ****
    ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA);
    ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB);
  
!   cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
!   cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   cout << endl << endl;
  
!   cout << "Dimension of the system            : " << n     << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
  
    // Printing eigenvalues.
  
!   cout << "Eigenvalues:" << endl;
  
    for (i=0; i<nconv; i++) {
!     cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
      if (EigValI[i]>=0.0) {
!       cout << " + " << EigValI[i] << " I" << endl;
      }
      else {
!       cout << " - " << fabs(EigValI[i]) << " I" << endl;
      }
    }
!   cout << endl;
  
    // Printing eigenvectors.
  
--- 129,155 ----
    ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA);
    ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB);
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
!   std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   std::cout << std::endl << std::endl;
  
!   std::cout << "Dimension of the system            : " << n     << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
  
    // Printing eigenvalues.
  
!   std::cout << "Eigenvalues:" << std::endl;
  
    for (i=0; i<nconv; i++) {
!     std::cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
      if (EigValI[i]>=0.0) {
!       std::cout << " + " << EigValI[i] << " I" << std::endl;
      }
      else {
!       std::cout << " - " << fabs(EigValI[i]) << " I" << std::endl;
      }
    }
!   std::cout << std::endl;
  
    // Printing eigenvectors.
  
***************
*** 193,202 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << i << ") - lambda(" << i;
!       cout << ")*B*x(" << i << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] Bx;
--- 193,202 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << i << ") - lambda(" << i;
!       std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/areig/nonsym/Makefile arpack++new/examples/areig/nonsym/Makefile
*** arpack++/examples/areig/nonsym/Makefile	2000-02-18 16:19:24.000000000 -0500
--- arpack++new/examples/areig/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 42,48 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 42,48 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core ansymgre ansymgsc ansymgsh ansymreg ansymshf simple
  
  # defining pattern rules.
  
diff -crB arpack++/examples/areig/nonsym/simple.cc arpack++new/examples/areig/nonsym/simple.cc
*** arpack++/examples/areig/nonsym/simple.cc	2000-02-18 16:17:43.000000000 -0500
--- arpack++new/examples/areig/nonsym/simple.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  
  #include "lnmatrxc.h"
  #include "areig.h"
! #include <math.h>
  
  int main()
  {
--- 18,24 ----
  
  #include "lnmatrxc.h"
  #include "areig.h"
! #include <cmath>
  
  int main()
  {
***************
*** 50,65 ****
  
    // Printing eigenvalues.
  
!   cout << "Eigenvalues:" << endl;
    for (int i=0; i<nconv; i++) {
!     cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
      if (EigValI[i]>=0.0) {
!       cout << " + " << EigValI[i] << " I" << endl;
      }
      else {
!       cout << " - " << fabs(EigValI[i]) << " I" << endl;
      }
    }
!   cout << endl;
  
  } // main
--- 50,65 ----
  
    // Printing eigenvalues.
  
!   std::cout << "Eigenvalues:" << std::endl;
    for (int i=0; i<nconv; i++) {
!     std::cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
      if (EigValI[i]>=0.0) {
!       std::cout << " + " << EigValI[i] << " I" << std::endl;
      }
      else {
!       std::cout << " - " << fabs(EigValI[i]) << " I" << std::endl;
      }
    }
!   std::cout << std::endl;
  
  } // main
diff -crB arpack++/examples/areig/sym/asymsol.h arpack++new/examples/areig/sym/asymsol.h
*** arpack++/examples/areig/sym/asymsol.h	2000-02-21 13:53:20.000000000 -0500
--- arpack++new/examples/areig/sym/asymsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef ASYMSOL_H
  #define ASYMSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "arlsmat.h"
--- 18,24 ----
  #ifndef ASYMSOL_H
  #define ASYMSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "arlsmat.h"
***************
*** 28,34 ****
                ARINT pcol[], char uplo, ARFLOAT EigVal[], ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of symmetric eigen-problems
!   on standard "cout" stream.
  */
  
  {
--- 28,34 ----
                ARINT pcol[], char uplo, ARFLOAT EigVal[], ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of symmetric eigen-problems
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 38,57 ****
    ARFLOAT*               ResNorm;
    ARluSymMatrix<ARFLOAT> matrix(n, nnz, A, irow, pcol, uplo);
  
!   cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
!   cout << "Real symmetric eigenvalue problem: A*x - lambda*x \n \n";
  
!   cout << "Dimension of the system            : " << n     << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
  
    // Printing eigenvalues.
  
!   cout << "Eigenvalues:" << endl;
  
    for (i=0; i<nconv; i++) {
!     cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
    }
!   cout << endl;
  
    // Printing eigenvectors.
  
--- 38,57 ----
    ARFLOAT*               ResNorm;
    ARluSymMatrix<ARFLOAT> matrix(n, nnz, A, irow, pcol, uplo);
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
!   std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x \n \n";
  
!   std::cout << "Dimension of the system            : " << n     << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
  
    // Printing eigenvalues.
  
!   std::cout << "Eigenvalues:" << std::endl;
  
    for (i=0; i<nconv; i++) {
!     std::cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
    }
!   std::cout << std::endl;
  
    // Printing eigenvectors.
  
***************
*** 70,79 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] ResNorm;
--- 70,79 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] ResNorm;
***************
*** 89,95 ****
                ARINT pcolB[], char uplo, ARFLOAT EigVal[], ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of symmetric generalized
!   eigen-problem on standard "cout" stream.
  */
  
  {
--- 89,95 ----
                ARINT pcolB[], char uplo, ARFLOAT EigVal[], ARFLOAT* EigVec = 0)
  /*
    Prints eigenvalues and eigenvectors of symmetric generalized
!   eigen-problem on standard "std::cout" stream.
  */
  
  {
***************
*** 100,120 ****
    ARluSymMatrix<ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA, uplo);
    ARluSymMatrix<ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB, uplo);
  
!   cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
!   cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   cout << endl << endl;
  
!   cout << "Dimension of the system            : " << n     << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
  
    // Printing eigenvalues.
  
!   cout << "Eigenvalues:" << endl;
  
    for (i=0; i<nconv; i++) {
!     cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
    }
!   cout << endl;
  
    // Printing eigenvectors.
  
--- 100,120 ----
    ARluSymMatrix<ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA, uplo);
    ARluSymMatrix<ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB, uplo);
  
!   std::cout << std::endl <<std::endl << "Testing ARPACK++ function AREig" <<std::endl;
!   std::cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   std::cout << std::endl <<std::endl;
  
!   std::cout << "Dimension of the system            : " << n     << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl <<std::endl;
  
    // Printing eigenvalues.
  
!   std::cout << "Eigenvalues:" << std::endl;
  
    for (i=0; i<nconv; i++) {
!     std::cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
    }
!   std::cout << std::endl;
  
    // Printing eigenvectors.
  
***************
*** 135,144 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << i << ") - lambda(" << i;
!       cout << ")*B*x(" << i << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] Bx;
--- 135,144 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << i << ") - lambda(" << i;
!       std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/areig/sym/Makefile arpack++new/examples/areig/sym/Makefile
*** arpack++/examples/areig/sym/Makefile	2000-02-18 16:11:18.000000000 -0500
--- arpack++new/examples/areig/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 42,48 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 42,48 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core asymgbkl asymgcay asymgreg asymgshf asymreg asymshf
  
  # defining pattern rules.
  
diff -crB arpack++/examples/band/complex/Makefile arpack++new/examples/band/complex/Makefile
*** arpack++/examples/band/complex/Makefile	2000-02-18 13:40:44.000000000 -0500
--- arpack++new/examples/band/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 32,38 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 32,38 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core bcompreg bcompshf bcompgre bcompgsh
  
  # defining pattern rules.
  
diff -crB arpack++/examples/band/nonsym/bsvd.cc arpack++new/examples/band/nonsym/bsvd.cc
*** arpack++/examples/band/nonsym/bsvd.cc	2000-02-18 13:35:55.000000000 -0500
--- arpack++new/examples/band/nonsym/bsvd.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 45,52 ****
  #include "arssym.h"
  #include "bnmatrxw.h"
  #include "arbnsmat.h"
! #include "iostream.h"
! #include <math.h>
  
  
  int main()
--- 45,52 ----
  #include "arssym.h"
  #include "bnmatrxw.h"
  #include "arbnsmat.h"
! #include <iostream>
! #include <cmath>
  
  
  int main()
***************
*** 90,100 ****
  
    // Printing some information about the problem.
  
!   cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
!   cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
!   cout << endl << "greatest singular values: " << endl; 
    for (i=0; i<4; i++) {
!     cout << "  sigma [" << i+1 << "]: " << svalue[i] << endl;
    }
  
  } // main.
--- 90,100 ----
  
    // Printing some information about the problem.
  
!   std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
!   std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
!   std::cout << std::endl << "greatest singular values: " << std::endl; 
    for (i=0; i<4; i++) {
!     std::cout << "  sigma [" << i+1 << "]: " << svalue[i] << std::endl;
    }
  
  } // main.
diff -crB arpack++/examples/band/nonsym/Makefile arpack++new/examples/band/nonsym/Makefile
*** arpack++/examples/band/nonsym/Makefile	2000-02-18 13:30:35.000000000 -0500
--- arpack++new/examples/band/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 38,44 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 38,44 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core bnsymreg bnsymshf bnsymgre bnsymgsh bnsymgsc bsvd
  
  # defining pattern rules.
  
diff -crB arpack++/examples/band/sym/Makefile arpack++new/examples/band/sym/Makefile
*** arpack++/examples/band/sym/Makefile	2000-02-18 13:27:56.000000000 -0500
--- arpack++new/examples/band/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 38,44 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 38,44 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core bsymreg bsymshf bsymgreg bsymgshf bsymgbkl bsymgcay
  
  # defining pattern rules.
  
diff -crB arpack++/examples/dense/complex/Makefile arpack++new/examples/dense/complex/Makefile
*** arpack++/examples/dense/complex/Makefile	2000-02-18 15:18:23.000000000 -0500
--- arpack++new/examples/dense/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 32,38 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 32,38 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core dcompreg dcompshf dcompgre dcompgsh
  
  # defining pattern rules.
  
diff -crB arpack++/examples/dense/nonsym/dsvd2.cc arpack++new/examples/dense/nonsym/dsvd2.cc
*** arpack++/examples/dense/nonsym/dsvd2.cc	2000-02-18 15:12:32.000000000 -0500
--- arpack++new/examples/dense/nonsym/dsvd2.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 46,53 ****
  
  #include "arssym.h"
  #include "ardnsmat.h"
! #include "iostream.h"
! #include <math.h>
  
  
  int main()
--- 46,53 ----
  
  #include "arssym.h"
  #include "ardnsmat.h"
! #include <iostream>
! #include <cmath>
  
  
  int main()
***************
*** 80,90 ****
  
    // Printing some information about the problem.
  
!   cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
!   cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
!   cout << endl << "greatest singular values: " << endl; 
    for (i=0; i<4; i++) {
!     cout << "  sigma [" << i+1 << "]: " << svalue[i] << endl;
    }
  
  } // main.
--- 80,90 ----
  
    // Printing some information about the problem.
  
!   std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
!   std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
!   std::cout << std::endl << "greatest singular values: " << std::endl; 
    for (i=0; i<4; i++) {
!     std::cout << "  sigma [" << i+1 << "]: " << svalue[i] << std::endl;
    }
  
  } // main.
diff -crB arpack++/examples/dense/nonsym/dsvd.cc arpack++new/examples/dense/nonsym/dsvd.cc
*** arpack++/examples/dense/nonsym/dsvd.cc	2000-02-18 15:11:17.000000000 -0500
--- arpack++new/examples/dense/nonsym/dsvd.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 42,49 ****
  #include "arssym.h"
  #include "dnmatrxw.h"
  #include "ardnsmat.h"
! #include "iostream.h"
! #include <math.h>
  
  
  int main()
--- 42,49 ----
  #include "arssym.h"
  #include "dnmatrxw.h"
  #include "ardnsmat.h"
! #include <iostream>
! #include <cmath>
  
  
  int main()
***************
*** 85,95 ****
  
    // Printing some information about the problem.
  
!   cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
!   cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
!   cout << endl << "greatest singular values: " << endl; 
    for (i=0; i<4; i++) {
!     cout << "  sigma [" << i+1 << "]: " << svalue[i] << endl;
    }
  
  } // main.
--- 85,95 ----
  
    // Printing some information about the problem.
  
!   std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
!   std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
!   std::cout << std::endl << "greatest singular values: " << std::endl; 
    for (i=0; i<4; i++) {
!     std::cout << "  sigma [" << i+1 << "]: " << svalue[i] << std::endl;
    }
  
  } // main.
diff -crB arpack++/examples/dense/nonsym/Makefile arpack++new/examples/dense/nonsym/Makefile
*** arpack++/examples/dense/nonsym/Makefile	2000-02-18 15:11:42.000000000 -0500
--- arpack++new/examples/dense/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 41,47 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 41,47 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core dnsymreg dnsymshf dnsymgre dnsymgsh dnsymgsc dsvd
  
  # defining pattern rules.
  
diff -crB arpack++/examples/dense/sym/Makefile arpack++new/examples/dense/sym/Makefile
*** arpack++/examples/dense/sym/Makefile	2000-02-18 14:33:51.000000000 -0500
--- arpack++new/examples/dense/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 38,44 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 38,44 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core dsymreg dsymshf dsymgreg dsymgshf dsymgbkl dsymgcay
  
  # defining pattern rules.
  
diff -crB arpack++/examples/harwell/complex/hcompgen.cc arpack++new/examples/harwell/complex/hcompgen.cc
*** arpack++/examples/harwell/complex/hcompgen.cc	2000-02-22 11:28:48.000000000 -0500
--- arpack++new/examples/harwell/complex/hcompgen.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 32,38 ****
        Houston, Texas
  */
  
! #include <iostream.h>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlgcomp.h"
--- 32,39 ----
        Houston, Texas
  */
  
! #include <iostream>
! #include <string>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlgcomp.h"
***************
*** 45,65 ****
  */
  {
  
!   cout << "ARPACK++ version 1.2 feb 2000" << endl;
!   cout << "hcompgen: a generalized complex eigenvalue problems solver" << endl;
!   cout << "usage:    hcompgen [parameters] file1 file2" << endl;
!   cout << "parameters:" << endl;
!   cout << "      -n <number of desired eigenvalues>" << endl;
!   cout << "      -c <number of Arnoldi vectors per iteration>" << endl;
!   cout << "      -l <maximum number of iterations>" << endl;
!   cout << "      -s <real part of the shift>" << endl;
!   cout << "      -i <imaginary part of the shift>" << endl;
!   cout << "      -t <stopping criterion>" << endl;
!   cout << "      -u <LU pivot threshold>" << endl;
!   cout << "      -o <column ordering for factorization>" << endl;
!   cout << "      -w <desired portion of the spectrum. " << endl;
!   cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << endl;
!   cout << endl;
  
  } // PrintHelp.
  
--- 46,66 ----
  */
  {
  
!   std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
!   std::cout << "hcompgen: a generalized complex eigenvalue problems solver" << std::endl;
!   std::cout << "usage:    hcompgen [parameters] file1 file2" << std::endl;
!   std::cout << "parameters:" << std::endl;
!   std::cout << "      -n <number of desired eigenvalues>" << std::endl;
!   std::cout << "      -c <number of Arnoldi vectors per iteration>" << std::endl;
!   std::cout << "      -l <maximum number of iterations>" << std::endl;
!   std::cout << "      -s <real part of the shift>" << std::endl;
!   std::cout << "      -i <imaginary part of the shift>" << std::endl;
!   std::cout << "      -t <stopping criterion>" << std::endl;
!   std::cout << "      -u <LU pivot threshold>" << std::endl;
!   std::cout << "      -o <column ordering for factorization>" << std::endl;
!   std::cout << "      -w <desired portion of the spectrum. " << std::endl;
!   std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << std::endl;
!   std::cout << std::endl;
  
  } // PrintHelp.
  
***************
*** 67,73 ****
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigmar,
                      double &sigmai, double &tol, double &thresh,
!                     char* &which, char* &fileA, char* &fileB)
  /*
    Reads parameters from the command line.
  */
--- 68,74 ----
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigmar,
                      double &sigmai, double &tol, double &thresh,
!                     std::string &which, std::string &fileA, std::string &fileB)
  /*
    Reads parameters from the command line.
  */
***************
*** 140,146 ****
            thresh = atof(v[i++]);
            break;
          default :
!           cout << "unrecognized parameter: -" << v[i-1][1] << endl;
            ok = false; 
          }
        }
--- 141,147 ----
            thresh = atof(v[i++]);
            break;
          default :
!           std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
            ok = false; 
          }
        }
***************
*** 174,182 ****
    double sigmai;
    double tol;
    double thresh;
!   char*  which;
!   char*  fileA;
!   char*  fileB;
  
    // Reading parameters.
  
--- 175,183 ----
    double sigmai;
    double tol;
    double thresh;
!   std::string  which;
!   std::string  fileA;
!   std::string  fileB;
  
    // Reading parameters.
  
diff -crB arpack++/examples/harwell/complex/hcompstd.cc arpack++new/examples/harwell/complex/hcompstd.cc
*** arpack++/examples/harwell/complex/hcompstd.cc	2000-02-22 11:28:18.000000000 -0500
--- arpack++new/examples/harwell/complex/hcompstd.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 32,38 ****
        Houston, Texas
  */
  
! #include <iostream.h>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlscomp.h"
--- 32,39 ----
        Houston, Texas
  */
  
! #include <iostream>
! #include <string>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlscomp.h"
***************
*** 45,65 ****
  */
  {
  
!   cout << "ARPACK++ version 1.2 feb 2000" << endl;
!   cout << "hcompstd: a standard complex eigenvalue problems solver" << endl;
!   cout << "usage:    hcompstd [parameters] file" << endl;
!   cout << "parameters:" << endl;
!   cout << "      -n (number of desired eigenvalues)" << endl;
!   cout << "      -c (number of Arnoldi vectors per iteration)" << endl;
!   cout << "      -l (maximum number of iterations)" << endl;
!   cout << "      -s (real part of the shift)" << endl;
!   cout << "      -i (imaginary part of the shift)" << endl;
!   cout << "      -t (stopping criterion)" << endl;
!   cout << "      -u (LU pivot threshold)" << endl;
!   cout << "      -o (column ordering for factorization)" << endl;
!   cout << "      -w (desired portion of the spectrum. " << endl;
!   cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << endl;
!   cout << endl;
  
  } // PrintHelp.
  
--- 46,66 ----
  */
  {
  
!   std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
!   std::cout << "hcompstd: a standard complex eigenvalue problems solver" << std::endl;
!   std::cout << "usage:    hcompstd [parameters] file" << std::endl;
!   std::cout << "parameters:" << std::endl;
!   std::cout << "      -n (number of desired eigenvalues)" << std::endl;
!   std::cout << "      -c (number of Arnoldi vectors per iteration)" << std::endl;
!   std::cout << "      -l (maximum number of iterations)" << std::endl;
!   std::cout << "      -s (real part of the shift)" << std::endl;
!   std::cout << "      -i (imaginary part of the shift)" << std::endl;
!   std::cout << "      -t (stopping criterion)" << std::endl;
!   std::cout << "      -u (LU pivot threshold)" << std::endl;
!   std::cout << "      -o (column ordering for factorization)" << std::endl;
!   std::cout << "      -w (desired portion of the spectrum. " << std::endl;
!   std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << std::endl;
!   std::cout << std::endl;
  
  } // PrintHelp.
  
***************
*** 67,73 ****
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigmar,
                      double &sigmai, double &tol, double &thresh,
!                     char* &which, char* &file)
  /*
    Reads parameters from the command line.
  */
--- 68,74 ----
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigmar,
                      double &sigmai, double &tol, double &thresh,
!                     std::string &which, std::string &file)
  /*
    Reads parameters from the command line.
  */
***************
*** 139,145 ****
            thresh = atof(v[i++]);
            break;
          default :
!           cout << "unrecognized parameter: -" << v[i-1][1] << endl;
            ok = false; 
          }
        }
--- 140,146 ----
            thresh = atof(v[i++]);
            break;
          default :
!           std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
            ok = false; 
          }
        }
***************
*** 172,179 ****
    double sigmai;
    double tol;
    double thresh;
!   char*  which;
!   char*  file;
  
    // Reading parameters.
  
--- 173,180 ----
    double sigmai;
    double tol;
    double thresh;
!   std::string  which;
!   std::string  file;
  
    // Reading parameters.
  
diff -crB arpack++/examples/harwell/complex/Makefile arpack++new/examples/harwell/complex/Makefile
*** arpack++/examples/harwell/complex/Makefile	2000-02-22 11:36:39.000000000 -0500
--- arpack++new/examples/harwell/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 26,32 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 26,32 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core hcompstd hcompgen
  
  # defining pattern rules.
  
diff -crB arpack++/examples/harwell/nonsym/hnsymgen.cc arpack++new/examples/harwell/nonsym/hnsymgen.cc
*** arpack++/examples/harwell/nonsym/hnsymgen.cc	2000-02-22 11:46:51.000000000 -0500
--- arpack++new/examples/harwell/nonsym/hnsymgen.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 33,39 ****
        Houston, Texas
  */
  
! #include <iostream.h>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlgnsym.h"
--- 33,40 ----
        Houston, Texas
  */
  
! #include <iostream>
! #include <string>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlgnsym.h"
***************
*** 46,67 ****
  */
  {
  
!   cout << "ARPACK++ version 1.2 fev 2000" << endl;
!   cout << "hnsymgen: a generalized nonsymmetric eigenproblems solver" << endl;
!   cout << "usage:    hnsymgen [parameters] file1 file2" << endl;
!   cout << "parameters:" << endl;
!   cout << "      -n <number of desired eigenvalues>" << endl;
!   cout << "      -c <number of Arnoldi vectors per iteration>" << endl;
!   cout << "      -l <maximum number of iterations>" << endl;
!   cout << "      -s <real part of the shift>" << endl;
!   cout << "      -i <imaginary part of the shift>" << endl;
!   cout << "      -p <part of inv(A-sB)*v considered (R or I))>" << endl;
!   cout << "      -t <stopping criterion>" << endl;
!   cout << "      -u <LU pivot threshold>" << endl;
!   cout << "      -o <column ordering for factorization>" << endl;
!   cout << "      -w <desired portion of the spectrum. " << endl;
!   cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << endl;
!   cout << endl;
  
  } // PrintHelp.
  
--- 47,68 ----
  */
  {
  
!   std::cout << "ARPACK++ version 1.2 fev 2000" << std::endl;
!   std::cout << "hnsymgen: a generalized nonsymmetric eigenproblems solver" << std::endl;
!   std::cout << "usage:    hnsymgen [parameters] file1 file2" << std::endl;
!   std::cout << "parameters:" << std::endl;
!   std::cout << "      -n <number of desired eigenvalues>" << std::endl;
!   std::cout << "      -c <number of Arnoldi vectors per iteration>" << std::endl;
!   std::cout << "      -l <maximum number of iterations>" << std::endl;
!   std::cout << "      -s <real part of the shift>" << std::endl;
!   std::cout << "      -i <imaginary part of the shift>" << std::endl;
!   std::cout << "      -p <part of inv(A-sB)*v considered (R or I))>" << std::endl;
!   std::cout << "      -t <stopping criterion>" << std::endl;
!   std::cout << "      -u <LU pivot threshold>" << std::endl;
!   std::cout << "      -o <column ordering for factorization>" << std::endl;
!   std::cout << "      -w <desired portion of the spectrum. " << std::endl;
!   std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << std::endl;
!   std::cout << std::endl;
  
  } // PrintHelp.
  
***************
*** 69,75 ****
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigmar, 
                      double &sigmai, char &part, double &tol, double &thresh, 
!                     char* &which, char* &fileA, char* &fileB)
  /*
    Reads parameters from the command line.
  */
--- 70,76 ----
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigmar, 
                      double &sigmai, char &part, double &tol, double &thresh, 
!                     std::string &which, std::string &fileA, std::string &fileB)
  /*
    Reads parameters from the command line.
  */
***************
*** 146,152 ****
            thresh = atof(v[i++]);
            break;
          default :
!           cout << "unrecognized parameter: -" << v[i-1][1] << endl;
            ok = false; 
          }
        }
--- 147,153 ----
            thresh = atof(v[i++]);
            break;
          default :
!           std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
            ok = false; 
          }
        }
***************
*** 181,189 ****
    double tol;
    double thresh;
    char   part;
!   char*  which;
!   char*  fileA;
!   char*  fileB;
  
    // Reading parameters.
  
--- 182,190 ----
    double tol;
    double thresh;
    char   part;
!   std::string  which;
!   std::string  fileA;
!   std::string  fileB;
  
    // Reading parameters.
  
diff -crB arpack++/examples/harwell/nonsym/hnsymstd.cc arpack++new/examples/harwell/nonsym/hnsymstd.cc
*** arpack++/examples/harwell/nonsym/hnsymstd.cc	2000-02-22 11:47:02.000000000 -0500
--- arpack++new/examples/harwell/nonsym/hnsymstd.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 33,39 ****
        Houston, Texas
  */
  
! #include <iostream.h>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlsnsym.h"
--- 33,40 ----
        Houston, Texas
  */
  
! #include <iostream>
! #include <string>
  #include "arerror.h"
  #include "arlnsmat.h"
  #include "arlsnsym.h"
***************
*** 46,72 ****
  */
  {
  
!   cout << "ARPACK++ version 1.2 feb 2000" << endl;
!   cout << "hnsymstd: a standard nonsymmetric eigenproblems solver" << endl;
!   cout << "usage:    hnsymstd [parameters] file" << endl;
!   cout << "parameters:" << endl;
!   cout << "      -n (number of desired eigenvalues)" << endl;
!   cout << "      -c (number of Arnoldi vectors per iteration)" << endl;
!   cout << "      -l (maximum number of iterations)" << endl;
!   cout << "      -s (shift)" << endl;
!   cout << "      -t (stopping criterion)" << endl;
!   cout << "      -u (LU pivot threshold)" << endl;
!   cout << "      -o (column ordering for factorization)" << endl;
!   cout << "      -w (desired portion of the spectrum. " << endl;
!   cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << endl;
!   cout << endl;
  
  } // PrintHelp.
  
  
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigma, double &tol,
!                     double &thresh, char* &which, char* &file)
  /*
    Reads parameters from the command line.
  */
--- 47,73 ----
  */
  {
  
!   std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
!   std::cout << "hnsymstd: a standard nonsymmetric eigenproblems solver" << std::endl;
!   std::cout << "usage:    hnsymstd [parameters] file" << std::endl;
!   std::cout << "parameters:" << std::endl;
!   std::cout << "      -n (number of desired eigenvalues)" << std::endl;
!   std::cout << "      -c (number of Arnoldi vectors per iteration)" << std::endl;
!   std::cout << "      -l (maximum number of iterations)" << std::endl;
!   std::cout << "      -s (shift)" << std::endl;
!   std::cout << "      -t (stopping criterion)" << std::endl;
!   std::cout << "      -u (LU pivot threshold)" << std::endl;
!   std::cout << "      -o (column ordering for factorization)" << std::endl;
!   std::cout << "      -w (desired portion of the spectrum. " << std::endl;
!   std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << std::endl;
!   std::cout << std::endl;
  
  } // PrintHelp.
  
  
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigma, double &tol,
!                     double &thresh, std::string &which, std::string &file)
  /*
    Reads parameters from the command line.
  */
***************
*** 133,139 ****
            thresh = atof(v[i++]);
            break;
          default :
!           cout << "unrecognized parameter: -" << v[i-1][1] << endl;
            ok = false; 
          }
        }
--- 134,140 ----
            thresh = atof(v[i++]);
            break;
          default :
!           std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
            ok = false; 
          }
        }
***************
*** 165,172 ****
    double sigma;
    double tol;
    double thresh;
!   char*  which;
!   char*  file;
  
    // Reading parameters.
  
--- 166,173 ----
    double sigma;
    double tol;
    double thresh;
!   std::string  which;
!   std::string  file;
  
    // Reading parameters.
  
diff -crB arpack++/examples/harwell/nonsym/Makefile arpack++new/examples/harwell/nonsym/Makefile
*** arpack++/examples/harwell/nonsym/Makefile	2000-02-22 11:36:26.000000000 -0500
--- arpack++new/examples/harwell/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 26,32 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 26,32 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core hnsymstd hnsymgen
  
  # defining pattern rules.
  
diff -crB arpack++/examples/harwell/sym/hsymgen.cc arpack++new/examples/harwell/sym/hsymgen.cc
*** arpack++/examples/harwell/sym/hsymgen.cc	2000-02-22 11:50:18.000000000 -0500
--- arpack++new/examples/harwell/sym/hsymgen.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 33,39 ****
        Houston, Texas
  */
  
! #include <iostream.h>
  #include "arerror.h"
  #include "arlsmat.h"
  #include "arlgsym.h"
--- 33,40 ----
        Houston, Texas
  */
  
! #include <iostream>
! #include <string>
  #include "arerror.h"
  #include "arlsmat.h"
  #include "arlgsym.h"
***************
*** 46,67 ****
  */
  {
  
!   cout << "ARPACK++ version 1.2 feb 2000" << endl;
!   cout << "hsymgen: a generalized symmetric eigenproblems solver" << endl;
!   cout << "usage:   hsymgen [parameters] file1 file2" << endl;
!   cout << "parameters:" << endl;
!   cout << "      -n <number of desired eigenvalues>" << endl;
!   cout << "      -c <number of Arnoldi vectors per iteration>" << endl;
!   cout << "      -l <maximum number of iterations>" << endl;
!   cout << "      -s <shift>" << endl;
!   cout << "      -i <invert mode: 'S'hift-invert, 'B'uckling or 'C'ayley)>";
!   cout << endl;
!   cout << "      -t <stopping criterion>" << endl;
!   cout << "      -u <LU pivot threshold>" << endl;
!   cout << "      -o <column ordering for factorization>" << endl;
!   cout << "      -w <desired portion of the spectrum. " << endl;
!   cout << "          acceptable values: LM, SM, LA, SA, BE>" << endl;
!   cout << endl;
  
  } // PrintHelp.
  
--- 47,68 ----
  */
  {
  
!   std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
!   std::cout << "hsymgen: a generalized symmetric eigenproblems solver" << std::endl;
!   std::cout << "usage:   hsymgen [parameters] file1 file2" << std::endl;
!   std::cout << "parameters:" << std::endl;
!   std::cout << "      -n <number of desired eigenvalues>" << std::endl;
!   std::cout << "      -c <number of Arnoldi vectors per iteration>" << std::endl;
!   std::cout << "      -l <maximum number of iterations>" << std::endl;
!   std::cout << "      -s <shift>" << std::endl;
!   std::cout << "      -i <invert mode: 'S'hift-invert, 'B'uckling or 'C'ayley)>";
!   std::cout << std::endl;
!   std::cout << "      -t <stopping criterion>" << std::endl;
!   std::cout << "      -u <LU pivot threshold>" << std::endl;
!   std::cout << "      -o <column ordering for factorization>" << std::endl;
!   std::cout << "      -w <desired portion of the spectrum. " << std::endl;
!   std::cout << "          acceptable values: LM, SM, LA, SA, BE>" << std::endl;
!   std::cout << std::endl;
  
  } // PrintHelp.
  
***************
*** 69,75 ****
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigma,
                      char &mode, double &tol, double &thresh,
!                     char* &which, char* &fileA, char* &fileB)
  /*
    Reads parameters from the command line.
  */
--- 70,76 ----
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigma,
                      char &mode, double &tol, double &thresh,
!                     std::string &which, std::string &fileA, std::string &fileB)
  /*
    Reads parameters from the command line.
  */
***************
*** 122,128 ****
          case 'i':
            mode = v[i++][0];
            if ((mode!='S')&&(mode!='B')&&(mode!='C')) {
!             cout << "invalid invert mode: " << mode << endl;
              ok = false;
            }
            break;
--- 123,129 ----
          case 'i':
            mode = v[i++][0];
            if ((mode!='S')&&(mode!='B')&&(mode!='C')) {
!             std::cout << "invalid invert mode: " << mode << std::endl;
              ok = false;
            }
            break;
***************
*** 145,151 ****
            thresh = atof(v[i++]);
            break;
          default :
!           cout << "unrecognized parameter: -" << v[i-1][1] << endl;
            ok = false;
          }
        }
--- 146,152 ----
            thresh = atof(v[i++]);
            break;
          default :
!           std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
            ok = false;
          }
        }
***************
*** 179,187 ****
    double tol;
    double thresh;
    char   mode;
!   char*  which;
!   char*  fileA;
!   char*  fileB;
  
    // Reading parameters.
  
--- 180,188 ----
    double tol;
    double thresh;
    char   mode;
!   std::string  which;
!   std::string  fileA;
!   std::string  fileB;
  
    // Reading parameters.
  
diff -crB arpack++/examples/harwell/sym/hsymstd.cc arpack++new/examples/harwell/sym/hsymstd.cc
*** arpack++/examples/harwell/sym/hsymstd.cc	2000-02-22 11:43:30.000000000 -0500
--- arpack++new/examples/harwell/sym/hsymstd.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 33,39 ****
        Houston, Texas
  */
  
! #include <iostream.h>
  #include "arerror.h"
  #include "arlsmat.h"
  #include "arlssym.h"
--- 33,40 ----
        Houston, Texas
  */
  
! #include <iostream>
! #include <string>
  #include "arerror.h"
  #include "arlsmat.h"
  #include "arlssym.h"
***************
*** 46,72 ****
  */
  {
  
!   cout << "ARPACK++ version 1.2 feb 2000" << endl;
!   cout << "hsymstd: a standard symmetric eigenvalue problems solver" << endl;
!   cout << "usage:   hsymstd [parameters] file" << endl;
!   cout << "parameters:" << endl;
!   cout << "      -n (number of desired eigenvalues)" << endl;
!   cout << "      -c (number of Arnoldi vectors per iteration)" << endl;
!   cout << "      -l (maximum number of iterations)" << endl;
!   cout << "      -s (shift)" << endl;
!   cout << "      -t (stopping criterion)" << endl;
!   cout << "      -u (LU pivot threshold)" << endl;
!   cout << "      -o (column ordering for factorization)" << endl;
!   cout << "      -w (desired portion of the spectrum. " << endl;
!   cout << "          acceptable values: LM, SM, LA, SA, BE)" << endl;
!   cout << endl;
  
  } // PrintHelp.
  
  
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigma, double &tol,
!                     double &thresh, char* &which, char* &file)
  /*
    Reads parameters from the command line.
  */
--- 47,73 ----
  */
  {
  
!   std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
!   std::cout << "hsymstd: a standard symmetric eigenvalue problems solver" << std::endl;
!   std::cout << "usage:   hsymstd [parameters] file" << std::endl;
!   std::cout << "parameters:" << std::endl;
!   std::cout << "      -n (number of desired eigenvalues)" << std::endl;
!   std::cout << "      -c (number of Arnoldi vectors per iteration)" << std::endl;
!   std::cout << "      -l (maximum number of iterations)" << std::endl;
!   std::cout << "      -s (shift)" << std::endl;
!   std::cout << "      -t (stopping criterion)" << std::endl;
!   std::cout << "      -u (LU pivot threshold)" << std::endl;
!   std::cout << "      -o (column ordering for factorization)" << std::endl;
!   std::cout << "      -w (desired portion of the spectrum. " << std::endl;
!   std::cout << "          acceptable values: LM, SM, LA, SA, BE)" << std::endl;
!   std::cout << std::endl;
  
  } // PrintHelp.
  
  
  bool ReadParameters(int n, char* v[], int &nev, int &ncv, int &maxit,
                      int &order, bool &shift, double &sigma, double &tol,
!                     double &thresh, std::string &which, std::string &file)
  /*
    Reads parameters from the command line.
  */
***************
*** 133,139 ****
            thresh = atof(v[i++]);
            break;
          default :
!           cout << "unrecognized parameter: -" << v[i-1][1] << endl;
            ok = false; 
          }
        }
--- 134,140 ----
            thresh = atof(v[i++]);
            break;
          default :
!           std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
            ok = false; 
          }
        }
***************
*** 165,172 ****
    double sigma;
    double tol;
    double thresh;
!   char*  which;
!   char*  file;
  
    // Reading parameters.
  
--- 166,173 ----
    double sigma;
    double tol;
    double thresh;
!   std::string  which;
!   std::string  file;
  
    // Reading parameters.
  
diff -crB arpack++/examples/harwell/sym/Makefile arpack++new/examples/harwell/sym/Makefile
*** arpack++/examples/harwell/sym/Makefile	2000-02-22 11:51:04.000000000 -0500
--- arpack++new/examples/harwell/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 26,32 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 26,32 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core hsymstd hsymgen
  
  # defining pattern rules.
  
diff -crB arpack++/examples/matprod/complex/cgenprbb.h arpack++new/examples/matprod/complex/cgenprbb.h
*** arpack++/examples/matprod/complex/cgenprbb.h	1997-08-01 11:09:04.000000000 -0400
--- arpack++new/examples/matprod/complex/cgenprbb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 123,129 ****
  {
  
    int  ierr;
!   char *type = "N";
  
    copy(n, v, 1, w, 1);
    gttrs(type, n, 1, Adl, Ad, Adu, Adu2, ipiv, w, n, ierr);
--- 123,129 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
    copy(n, v, 1, w, 1);
    gttrs(type, n, 1, Adl, Ad, Adu, Adu2, ipiv, w, n, ierr);
diff -crB arpack++/examples/matprod/complex/cmatrixb.h arpack++new/examples/matprod/complex/cmatrixb.h
*** arpack++/examples/matprod/complex/cmatrixb.h	1997-08-01 11:07:42.000000000 -0400
--- arpack++new/examples/matprod/complex/cmatrixb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 86,116 ****
    const arcomplex<T> one(1.0, 0.0);
    const arcomplex<T> two(2.0, 0.0);
  
!   if (decsize != ncols()) {
!     decsize = ncols();
      FactorDataDeallocate();
!     Ad   = new arcomplex<T>[ncols()];
!     Adl  = new arcomplex<T>[ncols()];
!     Adu  = new arcomplex<T>[ncols()];
!     Adu2 = new arcomplex<T>[ncols()];
!     ipiv = new int[ncols()];
    }
  
!   h  = one/arcomplex<T>((ncols()+1),0.0);
    h2 = h*h;
    s  = rho/two;
    s1 = -one/h2 - s/h;
    s2 = two/h2 - shift;
    s3 = -one/h2 + s/h;
  
!   for (j=0; j<ncols()-1; j++) {
      Adl[j] = s1;
      Ad[j]  = s2;
      Adu[j] = s3;
    }
!   Ad[ncols()-1]  = s2;
  
!   gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorOP.
  
--- 86,116 ----
    const arcomplex<T> one(1.0, 0.0);
    const arcomplex<T> two(2.0, 0.0);
  
!   if (decsize != this->ncols()) {
!     decsize = this->ncols();
      FactorDataDeallocate();
!     Ad   = new arcomplex<T>[this->ncols()];
!     Adl  = new arcomplex<T>[this->ncols()];
!     Adu  = new arcomplex<T>[this->ncols()];
!     Adu2 = new arcomplex<T>[this->ncols()];
!     ipiv = new int[this->ncols()];
    }
  
!   h  = one/arcomplex<T>((this->ncols()+1),0.0);
    h2 = h*h;
    s  = rho/two;
    s1 = -one/h2 - s/h;
    s2 = two/h2 - shift;
    s3 = -one/h2 + s/h;
  
!   for (j=0; j<this->ncols()-1; j++) {
      Adl[j] = s1;
      Ad[j]  = s2;
      Adu[j] = s3;
    }
!   Ad[this->ncols()-1]  = s2;
  
!   gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorOP.
  
***************
*** 129,135 ****
    const arcomplex<T> one( 1.0, 0.0);
    const arcomplex<T> two( 2.0, 0.0);
  
!   h  = one/arcomplex<T>((ncols()+1),0.0);
    h2 = h*h;
    s  = rho/two;
    dd = two/h2;
--- 129,135 ----
    const arcomplex<T> one( 1.0, 0.0);
    const arcomplex<T> two( 2.0, 0.0);
  
!   h  = one/arcomplex<T>((this->ncols()+1),0.0);
    h2 = h*h;
    s  = rho/two;
    dd = two/h2;
***************
*** 137,146 ****
    du = -one/h2 + s/h;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
  
  } //  MultMv.
  
--- 137,146 ----
    du = -one/h2 + s/h;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
  
  } //  MultMv.
  
***************
*** 154,163 ****
  {
  
    int  ierr;
!   char *type = "N";
  
!   copy(ncols(), v, 1, w, 1);
!   gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, ncols(), ierr);
  
  } // MultOPv.
  
--- 154,163 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
!   copy(this->ncols(), v, 1, w, 1);
!   gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, this->ncols(), ierr);
  
  } // MultOPv.
  
diff -crB arpack++/examples/matprod/complex/cmatrixc.h arpack++new/examples/matprod/complex/cmatrixc.h
*** arpack++/examples/matprod/complex/cmatrixc.h	1997-08-01 11:06:49.000000000 -0400
--- arpack++new/examples/matprod/complex/cmatrixc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 46,62 ****
    const arcomplex<T> two( 2.0, 0.0);
    const arcomplex<T> rho(10.0, 0.0);
  
!   h  = one/arcomplex<T>((ncols()+1),0.0);
    s  = rho/two;
    dd = two/h;
    dl = -one/h - s;
    du = -one/h + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
  
  } //  MultMv.
  
--- 46,62 ----
    const arcomplex<T> two( 2.0, 0.0);
    const arcomplex<T> rho(10.0, 0.0);
  
!   h  = one/arcomplex<T>((this->ncols()+1),0.0);
    s  = rho/two;
    dd = two/h;
    dl = -one/h - s;
    du = -one/h + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
  
  } //  MultMv.
  
diff -crB arpack++/examples/matprod/complex/cmatrixd.h arpack++new/examples/matprod/complex/cmatrixd.h
*** arpack++/examples/matprod/complex/cmatrixd.h	1997-08-01 11:06:07.000000000 -0400
--- arpack++new/examples/matprod/complex/cmatrixd.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 81,88 ****
    const arcomplex<T> one(1.0, 0.0);
    const arcomplex<T> four(4.0, 0.0);
  
!   if (decsize != ncols()) {
!     decsize = ncols();
      FactorDataDeallocate();
      Ad   = new arcomplex<T>[decsize];
      Adl  = new arcomplex<T>[decsize];
--- 81,88 ----
    const arcomplex<T> one(1.0, 0.0);
    const arcomplex<T> four(4.0, 0.0);
  
!   if (decsize != this->ncols()) {
!     decsize = this->ncols();
      FactorDataDeallocate();
      Ad   = new arcomplex<T>[decsize];
      Adl  = new arcomplex<T>[decsize];
***************
*** 91,106 ****
      ipiv = new int[decsize];
    }
  
!   h  = one/arcomplex<T>((ncols()+1),0.0);
  
!   for (j=0; j<ncols()-1; j++) {
      Adl[j] = one*h;
      Ad[j]  = four*h;
      Adu[j] = one*h;
    }
!   Ad[ncols()-1]  = four*h;
  
!   gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorM.
  
--- 91,106 ----
      ipiv = new int[decsize];
    }
  
!   h  = one/arcomplex<T>((this->ncols()+1),0.0);
  
!   for (j=0; j<this->ncols()-1; j++) {
      Adl[j] = one*h;
      Ad[j]  = four*h;
      Adu[j] = one*h;
    }
!   Ad[this->ncols()-1]  = four*h;
  
!   gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorM.
  
***************
*** 116,128 ****
    const arcomplex<T> four(4.0, 0.0);
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
  
!   h = one/arcomplex<T>((ncols()+1),0.0);
!   scal(ncols(), h, w, 1);
  
  } // MultMv.
  
--- 116,128 ----
    const arcomplex<T> four(4.0, 0.0);
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
  
!   h = one/arcomplex<T>((this->ncols()+1),0.0);
!   scal(this->ncols(), h, w, 1);
  
  } // MultMv.
  
***************
*** 132,140 ****
  {
  
    int  ierr;
!   char *type = "N";
  
!   gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, ncols(), ierr);
  
  } // SolveM.
  
--- 132,140 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
!   gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, this->ncols(), ierr);
  
  } // SolveM.
  
diff -crB arpack++/examples/matprod/complex/cmatrixe.h arpack++new/examples/matprod/complex/cmatrixe.h
*** arpack++/examples/matprod/complex/cmatrixe.h	1997-08-01 11:05:21.000000000 -0400
--- arpack++new/examples/matprod/complex/cmatrixe.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 49,65 ****
    const arcomplex<T> one( 1.0, 0.0);
    const arcomplex<T> two( 2.0, 0.0);
  
!   h  = one/arcomplex<T>((ncols()+1),0.0);
    s  = rho/two;
    dd = two/h;
    dl = -one/h - s;
    du = -one/h + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
  
  } //  MultMv.
  
--- 49,65 ----
    const arcomplex<T> one( 1.0, 0.0);
    const arcomplex<T> two( 2.0, 0.0);
  
!   h  = one/arcomplex<T>((this->ncols()+1),0.0);
    s  = rho/two;
    dd = two/h;
    dl = -one/h - s;
    du = -one/h + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
  
  } //  MultMv.
  
diff -crB arpack++/examples/matprod/complex/cmatrixf.h arpack++new/examples/matprod/complex/cmatrixf.h
*** arpack++/examples/matprod/complex/cmatrixf.h	1997-08-01 11:04:52.000000000 -0400
--- arpack++new/examples/matprod/complex/cmatrixf.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 48,60 ****
    const arcomplex<T> four(4.0, 0.0);
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
  
!   h = one/arcomplex<T>((ncols()+1),0.0);
!   scal(ncols(), h, w, 1);
  
  } // MultMv.
  
--- 48,60 ----
    const arcomplex<T> four(4.0, 0.0);
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
  
!   h = one/arcomplex<T>((this->ncols()+1),0.0);
!   scal(this->ncols(), h, w, 1);
  
  } // MultMv.
  
diff -crB arpack++/examples/matprod/nonsym/ngenprbb.h arpack++new/examples/matprod/nonsym/ngenprbb.h
*** arpack++/examples/matprod/nonsym/ngenprbb.h	1997-08-01 11:02:52.000000000 -0400
--- arpack++new/examples/matprod/nonsym/ngenprbb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 124,130 ****
  {
  
    int  ierr;
!   char *type = "N";
  
    copy(n, v, 1, w, 1);
    gttrs(type, n, 1, Adl, Ad, Adu, Adu2, ipiv, w, n, ierr);
--- 124,130 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
    copy(n, v, 1, w, 1);
    gttrs(type, n, 1, Adl, Ad, Adu, Adu2, ipiv, w, n, ierr);
diff -crB arpack++/examples/matprod/nonsym/ngenprbc.h arpack++new/examples/matprod/nonsym/ngenprbc.h
*** arpack++/examples/matprod/nonsym/ngenprbc.h	1997-08-01 15:29:24.000000000 -0400
--- arpack++new/examples/matprod/nonsym/ngenprbc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 121,127 ****
  {
  
    int   i, ierr;
!   char* type = "N";
  
    for (i=0; i<n; i++) {
      ctemp[i] = arcomplex<T>(v[i],0.0);
--- 121,127 ----
  {
  
    int   i, ierr;
!   const char* type = "N";
  
    for (i=0; i<n; i++) {
      ctemp[i] = arcomplex<T>(v[i],0.0);
***************
*** 139,145 ****
  {
  
    int   i, ierr;
!   char* type = "N";
  
    for (i=0; i<n; i++) {
      ctemp[i] = arcomplex<T>(v[i],0.0);
--- 139,145 ----
  {
  
    int   i, ierr;
!   const char* type = "N";
  
    for (i=0; i<n; i++) {
      ctemp[i] = arcomplex<T>(v[i],0.0);
diff -crB arpack++/examples/matprod/nonsym/nmatrixb.h arpack++new/examples/matprod/nonsym/nmatrixb.h
*** arpack++/examples/matprod/nonsym/nmatrixb.h	1997-08-01 11:00:19.000000000 -0400
--- arpack++new/examples/matprod/nonsym/nmatrixb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 83,112 ****
    const T one = 1.0;
    const T two = 2.0;
  
!   if (decsize != ncols()) {
!     decsize = ncols();
      FactorDataDeallocate();
!     Ad   = new T[ncols()];
!     Adl  = new T[ncols()];
!     Adu  = new T[ncols()];
!     Adu2 = new T[ncols()];
!     ipiv = new int[ncols()];
    }
  
!   h  = one/T(ncols()+1);
    s  = rho*h/two;
    s1 = -one - s;
    s2 = two - shift;
    s3 = -one + s;
  
!   for (j=0; j<ncols()-1; j++) {
      Adl[j] = s1;
      Ad[j]  = s2;
      Adu[j] = s3;
    }
!   Ad[ncols()-1]  = s2;
  
!   gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorOP.
  
--- 83,112 ----
    const T one = 1.0;
    const T two = 2.0;
  
!   if (decsize != this->ncols()) {
!     decsize = this->ncols();
      FactorDataDeallocate();
!     Ad   = new T[this->ncols()];
!     Adl  = new T[this->ncols()];
!     Adu  = new T[this->ncols()];
!     Adu2 = new T[this->ncols()];
!     ipiv = new int[this->ncols()];
    }
  
!   h  = one/T(this->ncols()+1);
    s  = rho*h/two;
    s1 = -one - s;
    s2 = two - shift;
    s3 = -one + s;
  
!   for (j=0; j<this->ncols()-1; j++) {
      Adl[j] = s1;
      Ad[j]  = s2;
      Adu[j] = s3;
    }
!   Ad[this->ncols()-1]  = s2;
  
!   gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorOP.
  
***************
*** 125,141 ****
    const T one = 1.0;
    const T two = 2.0;
  
!   h  = one/T(ncols()+1);
    s  = rho*h/two;
    dd = two;
    dl = -one - s;
    du = -one + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
  
    return;
  
--- 125,141 ----
    const T one = 1.0;
    const T two = 2.0;
  
!   h  = one/T(this->ncols()+1);
    s  = rho*h/two;
    dd = two;
    dl = -one - s;
    du = -one + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
  
    return;
  
***************
*** 151,160 ****
  {
  
    int  ierr;
!   char *type = "N";
  
!   copy(ncols(), v, 1, w, 1);
!   gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, ncols(), ierr);
  
  } // MultOPv
  
--- 151,160 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
!   copy(this->ncols(), v, 1, w, 1);
!   gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, this->ncols(), ierr);
  
  } // MultOPv
  
diff -crB arpack++/examples/matprod/nonsym/nmatrixc.h arpack++new/examples/matprod/nonsym/nmatrixc.h
*** arpack++/examples/matprod/nonsym/nmatrixc.h	1997-08-01 10:59:34.000000000 -0400
--- arpack++new/examples/matprod/nonsym/nmatrixc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 49,65 ****
    const T two = 2.0;
    const T rho = 10.0;
  
!   h  = one/T(ncols()+1);
    s  = rho/two;
    dd = two/h;
    dl = -one/h - s;
    du = -one/h + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
  
  } //  MultMv.
  
--- 49,65 ----
    const T two = 2.0;
    const T rho = 10.0;
  
!   h  = one/T(this->ncols()+1);
    s  = rho/two;
    dd = two/h;
    dl = -one/h - s;
    du = -one/h + s;
  
    w[0] = dd*v[0] + du*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
    }
!   w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
  
  } //  MultMv.
  
diff -crB arpack++/examples/matprod/nonsym/nmatrixd.h arpack++new/examples/matprod/nonsym/nmatrixd.h
*** arpack++/examples/matprod/nonsym/nmatrixd.h	1997-08-01 10:58:54.000000000 -0400
--- arpack++new/examples/matprod/nonsym/nmatrixd.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 77,98 ****
    const T one  = 1.0;
    const T four = 4.0;
  
!   if (decsize != ncols()) {
!     decsize = ncols();
      FactorDataDeallocate();
!     Md   = new T[ncols()];
!     Me   = new T[ncols()];
    }
  
!   h  = one/T(ncols()+1);
  
!   for (i=0; i<ncols()-1; i++) {
      Md[i] = four*h;
      Me[i] = h;
    }
!   Md[ncols()-1] = four*h;
  
!   pttrf(ncols(), Md, Me, ierr);
  
  } // FactorM.
  
--- 77,98 ----
    const T one  = 1.0;
    const T four = 4.0;
  
!   if (decsize != this->ncols()) {
!     decsize = this->ncols();
      FactorDataDeallocate();
!     Md   = new T[this->ncols()];
!     Me   = new T[this->ncols()];
    }
  
!   h  = one/T(this->ncols()+1);
  
!   for (i=0; i<this->ncols()-1; i++) {
      Md[i] = four*h;
      Me[i] = h;
    }
!   Md[this->ncols()-1] = four*h;
  
!   pttrf(this->ncols(), Md, Me, ierr);
  
  } // FactorM.
  
***************
*** 108,120 ****
    const T four = 4.0;
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
  
!   h = one/T(ncols()+1);
!   scal(ncols(), h, w, 1);
  
  } // MultMv.
  
--- 108,120 ----
    const T four = 4.0;
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
  
!   h = one/T(this->ncols()+1);
!   scal(this->ncols(), h, w, 1);
  
  } // MultMv.
  
***************
*** 125,131 ****
  
    int  ierr;
  
!   pttrs(ncols(), 1, Md, Me, v, ncols(), ierr);
  
  } // SolveM.
  
--- 125,131 ----
  
    int  ierr;
  
!   pttrs(this->ncols(), 1, Md, Me, v, this->ncols(), ierr);
  
  } // SolveM.
  
diff -crB arpack++/examples/matprod/nonsym/nmatrixe.h arpack++new/examples/matprod/nonsym/nmatrixe.h
*** arpack++/examples/matprod/nonsym/nmatrixe.h	1997-08-01 10:58:15.000000000 -0400
--- arpack++new/examples/matprod/nonsym/nmatrixe.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 43,52 ****
    const T two   = 2.0;
  
    w[0] = two*v[0] + three*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = -two*v[j-1] + two*v[j] + three*v[j+1];
    }
!   w[ncols()-1] = -two*v[ncols()-2] + two*v[ncols()-1];
  
  } //  MultMv.
  
--- 43,52 ----
    const T two   = 2.0;
  
    w[0] = two*v[0] + three*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = -two*v[j-1] + two*v[j] + three*v[j+1];
    }
!   w[this->ncols()-1] = -two*v[this->ncols()-2] + two*v[this->ncols()-1];
  
  } //  MultMv.
  
diff -crB arpack++/examples/matprod/nonsym/nmatrixf.h arpack++new/examples/matprod/nonsym/nmatrixf.h
*** arpack++/examples/matprod/nonsym/nmatrixf.h	1997-08-01 10:57:51.000000000 -0400
--- arpack++new/examples/matprod/nonsym/nmatrixf.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 46,55 ****
    const T four = 4.0;
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
  
  } // MultMv.
  
--- 46,55 ----
    const T four = 4.0;
  
    w[0] = four*v[0] + one*v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
    }
!   w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
  
  } // MultMv.
  
diff -crB arpack++/examples/matprod/nonsym/nmatrixv.h arpack++new/examples/matprod/nonsym/nmatrixv.h
*** arpack++/examples/matprod/nonsym/nmatrixv.h	1997-08-01 10:57:28.000000000 -0400
--- arpack++new/examples/matprod/nonsym/nmatrixv.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 66,78 ****
    int  i,j;
    T    h,k,s,t,z;
  
!   h  = 1.0/T(nrows()+1);
!   k  = 1.0/T(ncols()+1);
  
!   for (i=0; i!=nrows(); i++) w[i] = 0.0;
  
    t = 0.0;
!   for (j=0; j!=ncols(); j++) {
      t += k;
      s  = 0.0;
      z  = v[j];
--- 66,78 ----
    int  i,j;
    T    h,k,s,t,z;
  
!   h  = 1.0/T(this->nrows()+1);
!   k  = 1.0/T(this->ncols()+1);
  
!   for (i=0; i!=this->nrows(); i++) w[i] = 0.0;
  
    t = 0.0;
!   for (j=0; j!=this->ncols(); j++) {
      t += k;
      s  = 0.0;
      z  = v[j];
***************
*** 80,86 ****
        s    += h;
        w[i] += k*s*(t-1.0)*z;
      }
!     for (i=j+1; i!=nrows(); i++) {
        s    += h;
        w[i] += k*t*(s-1.0)*z;
      }
--- 80,86 ----
        s    += h;
        w[i] += k*s*(t-1.0)*z;
      }
!     for (i=j+1; i!=this->nrows(); i++) {
        s    += h;
        w[i] += k*t*(s-1.0)*z;
      }
***************
*** 102,112 ****
    int  i,j;
    T    h,k,s,t,z;
  
!   h  = 1.0/T(nrows()+1);
!   k  = 1.0/T(ncols()+1);
  
    t = 0.0;
!   for (j=0; j!=ncols(); j++) {
      t += k;
      z  = 0.0;
      s  = 0.0;
--- 102,112 ----
    int  i,j;
    T    h,k,s,t,z;
  
!   h  = 1.0/T(this->nrows()+1);
!   k  = 1.0/T(this->ncols()+1);
  
    t = 0.0;
!   for (j=0; j!=this->ncols(); j++) {
      t += k;
      z  = 0.0;
      s  = 0.0;
***************
*** 114,120 ****
        s += h;
        z += k*s*(t-1.0)*v[i];
      }
!     for (i=j+1; i!=nrows(); i++) {
        s += h;
        z += k*t*(s-1.0)*v[i];
      }
--- 114,120 ----
        s += h;
        z += k*s*(t-1.0)*v[i];
      }
!     for (i=j+1; i!=this->nrows(); i++) {
        s += h;
        z += k*t*(s-1.0)*v[i];
      }
***************
*** 134,140 ****
  
  {
  
!   T* t = new T[nrows()];
  
    MultMv(v,t);
    MultMtv(t,w);
--- 134,140 ----
  
  {
  
!   T* t = new T[this->nrows()];
  
    MultMv(v,t);
    MultMtv(t,w);
diff -crB arpack++/examples/matprod/sym/sgenprbb.h arpack++new/examples/matprod/sym/sgenprbb.h
*** arpack++/examples/matprod/sym/sgenprbb.h	2000-02-21 15:40:40.000000000 -0500
--- arpack++new/examples/matprod/sym/sgenprbb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 123,129 ****
  {
  
    int  ierr;
!   char *type = "N";
  
    copy(n, v, 1, w, 1);
    gttrs(type, n, 1, Adl, Ad, Adu, Adu2, ipiv, w, n, ierr);
--- 123,129 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
    copy(n, v, 1, w, 1);
    gttrs(type, n, 1, Adl, Ad, Adu, Adu2, ipiv, w, n, ierr);
diff -crB arpack++/examples/matprod/sym/smatrixb.h arpack++new/examples/matprod/sym/smatrixb.h
*** arpack++/examples/matprod/sym/smatrixb.h	2000-02-21 15:34:54.000000000 -0500
--- arpack++new/examples/matprod/sym/smatrixb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 80,104 ****
    const ART one = 1.0;
    const ART two = 2.0;
  
!   if (decsize != ncols()) {
!     decsize = ncols();
      FactorDataDeallocate();
!     Ad   = new ART[ncols()];
!     Adl  = new ART[ncols()];
!     Adu  = new ART[ncols()];
!     Adu2 = new ART[ncols()];
!     ipiv = new int[ncols()];
    }
  
!   h2 = ART((ncols()+1)*(ncols()+1));
  
!   for (i=0; i<ncols(); i++) {
      Ad[i]  = two*h2 - shift;
      Adl[i] = -one*h2;
    }
  
!   copy(ncols(), Adl, 1, Adu, 1);
!   gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorOP.
  
--- 80,104 ----
    const ART one = 1.0;
    const ART two = 2.0;
  
!   if (decsize != this->ncols()) {
!     decsize = this->ncols();
      FactorDataDeallocate();
!     Ad   = new ART[this->ncols()];
!     Adl  = new ART[this->ncols()];
!     Adu  = new ART[this->ncols()];
!     Adu2 = new ART[this->ncols()];
!     ipiv = new int[this->ncols()];
    }
  
!   h2 = ART((this->ncols()+1)*(this->ncols()+1));
  
!   for (i=0; i<this->ncols(); i++) {
      Ad[i]  = two*h2 - shift;
      Adl[i] = -one*h2;
    }
  
!   copy(this->ncols(), Adl, 1, Adu, 1);
!   gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorOP.
  
***************
*** 117,131 ****
    const ART two = 2.0;
  
    w[0] =  two*v[0] - v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = - v[j-1] + two*v[j] - v[j+1];
    }
!   w[ncols()-1] = - v[ncols()-2] + two*v[ncols()-1];
  
    // Scaling the vector w by (1 / h^2).
  
!   h2 = ART((ncols()+1)*(ncols()+1));
!   scal(ncols(), h2, w, 1L);
  
    return;
  
--- 117,131 ----
    const ART two = 2.0;
  
    w[0] =  two*v[0] - v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = - v[j-1] + two*v[j] - v[j+1];
    }
!   w[this->ncols()-1] = - v[this->ncols()-2] + two*v[this->ncols()-1];
  
    // Scaling the vector w by (1 / h^2).
  
!   h2 = ART((this->ncols()+1)*(this->ncols()+1));
!   scal(this->ncols(), h2, w, 1L);
  
    return;
  
***************
*** 141,150 ****
  {
  
    int  ierr;
!   char *type = "N";
  
!   copy(ncols(), v, 1, w, 1);
!   gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, ncols(), ierr);
  
  } // MultOPv
  
--- 141,150 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
!   copy(this->ncols(), v, 1, w, 1);
!   gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, this->ncols(), ierr);
  
  } // MultOPv
  
diff -crB arpack++/examples/matprod/sym/smatrixc.h arpack++new/examples/matprod/sym/smatrixc.h
*** arpack++/examples/matprod/sym/smatrixc.h	2000-02-21 15:42:08.000000000 -0500
--- arpack++new/examples/matprod/sym/smatrixc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 50,64 ****
    const ART two = 2.0;
  
    w[0] =  two*v[0] - v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = - v[j-1] + two*v[j] - v[j+1];
    }
!   w[ncols()-1] = - v[ncols()-2] + two*v[ncols()-1];
  
    // Scaling the vector w by (1 / h).
  
!   h2 = ART(ncols()+1);
!   scal(ncols(), h2, w, 1L);
  
    return;
  
--- 50,64 ----
    const ART two = 2.0;
  
    w[0] =  two*v[0] - v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = - v[j-1] + two*v[j] - v[j+1];
    }
!   w[this->ncols()-1] = - v[this->ncols()-2] + two*v[this->ncols()-1];
  
    // Scaling the vector w by (1 / h).
  
!   h2 = ART(this->ncols()+1);
!   scal(this->ncols(), h2, w, 1L);
  
    return;
  
diff -crB arpack++/examples/matprod/sym/smatrixd.h arpack++new/examples/matprod/sym/smatrixd.h
*** arpack++/examples/matprod/sym/smatrixd.h	2000-02-21 15:31:52.000000000 -0500
--- arpack++new/examples/matprod/sym/smatrixd.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 76,102 ****
    const ART four = 4.0;
    const ART six  = 6.0;
  
!   if (decsize != ncols()) {
!     decsize = ncols();
      FactorDataDeallocate();
!     Ad   = new ART[ncols()];
!     Adl  = new ART[ncols()];
!     Adu  = new ART[ncols()];
!     Adu2 = new ART[ncols()];
!     ipiv = new int[ncols()];
    }
  
!   h  = one/ART(ncols()+1);
    r2 = h/six;
    r1 = r2*four;
  
!   for (i=0; i<ncols(); i++) {
      Ad[i]  = r1;
      Adl[i] = r2;
    }
  
!   copy(ncols(), Adl, 1, Adu, 1);
!   gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorM.
  
--- 76,102 ----
    const ART four = 4.0;
    const ART six  = 6.0;
  
!   if (decsize != this->ncols()) {
!     decsize = this->ncols();
      FactorDataDeallocate();
!     Ad   = new ART[this->ncols()];
!     Adl  = new ART[this->ncols()];
!     Adu  = new ART[this->ncols()];
!     Adu2 = new ART[this->ncols()];
!     ipiv = new int[this->ncols()];
    }
  
!   h  = one/ART(this->ncols()+1);
    r2 = h/six;
    r1 = r2*four;
  
!   for (i=0; i<this->ncols(); i++) {
      Ad[i]  = r1;
      Adl[i] = r2;
    }
  
!   copy(this->ncols(), Adl, 1, Adu, 1);
!   gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
  
  } // FactorM.
  
***************
*** 108,116 ****
  {
  
    int  ierr;
!   char *type = "N";
  
!   gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, ncols(), ierr);
  
  } // SolveM.
  
--- 108,116 ----
  {
  
    int  ierr;
!   const char *type = "N";
  
!   gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, this->ncols(), ierr);
  
  } // SolveM.
  
***************
*** 128,142 ****
    const ART six  = 6.0;
  
    w[0] = four*v[0] + v[1];
!   for (j=1; j<ncols()-1; j++) {
      w[j] = v[j-1] + four*v[j] + v[j+1];
    }
!   w[ncols()-1] = v[ncols()-2] + four*v[ncols()-1];
  
    // Scaling the vector w by h.
  
!   h = one / (ART(ncols()+1)*six);
!   scal(ncols(), h, w, 1L);
  
    return;
  
--- 128,142 ----
    const ART six  = 6.0;
  
    w[0] = four*v[0] + v[1];
!   for (j=1; j<this->ncols()-1; j++) {
      w[j] = v[j-1] + four*v[j] + v[j+1];
    }
!   w[this->ncols()-1] = v[this->ncols()-2] + four*v[this->ncols()-1];
  
    // Scaling the vector w by h.
  
!   h = one / (ART(this->ncols()+1)*six);
!   scal(this->ncols(), h, w, 1L);
  
    return;
  
diff -crB arpack++/examples/matrices/complex/lcompsol.h arpack++new/examples/matrices/complex/lcompsol.h
*** arpack++/examples/matrices/complex/lcompsol.h	2000-02-22 06:49:50.000000000 -0500
--- arpack++new/examples/matrices/complex/lcompsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef LCOMPSOL_H
  #define LCOMPSOL_H
  
! #include <math.h>
  #include "arcomp.h"
  #include "blas1c.h"
  #include "lapackc.h"
--- 18,24 ----
  #ifndef LCOMPSOL_H
  #define LCOMPSOL_H
  
! #include <cmath>
  #include "arcomp.h"
  #include "blas1c.h"
  #include "lapackc.h"
***************
*** 40,46 ****
  void Solution(ARMATRIX &A, ARluCompStdEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex eigen-problems
!   on standard "cout" stream.
  */
  
  {
--- 40,46 ----
  void Solution(ARMATRIX &A, ARluCompStdEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex eigen-problems
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 53,84 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARluCompStdEig \n";
!   cout << "Complex eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 53,84 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluCompStdEig \n";
!   std::cout << "Complex eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 97,106 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
--- 97,106 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
***************
*** 114,120 ****
  void Solution(MATRA &A, MATRB &B, ARluCompGenEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex generalized
!   eigen-problems on standard "cout" stream.
  */
  
  {
--- 114,120 ----
  void Solution(MATRA &A, MATRB &B, ARluCompGenEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex generalized
!   eigen-problems on standard "std::cout" stream.
  */
  
  {
***************
*** 128,160 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl; 
!   cout << "Testing ARPACK++ class ARluCompGenEig \n" << endl;
!   cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 128,160 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl; 
!   std::cout << "Testing ARPACK++ class ARluCompGenEig \n" << std::endl;
!   std::cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 175,184 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] Bx;
--- 175,184 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/matrices/nonsym/bnmatrxa.h arpack++new/examples/matrices/nonsym/bnmatrxa.h
*** arpack++/examples/matrices/nonsym/bnmatrxa.h	2000-02-22 07:19:18.000000000 -0500
--- arpack++new/examples/matrices/nonsym/bnmatrxa.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 29,35 ****
  #ifndef BNMATRXA_H
  #define BNMATRXA_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixA(ARINT nx, ARFLOAT rho, ARINT& n, ARINT& nL, ARINT& nU, 
--- 29,35 ----
  #ifndef BNMATRXA_H
  #define BNMATRXA_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixA(ARINT nx, ARFLOAT rho, ARINT& n, ARINT& nL, ARINT& nU, 
diff -crB arpack++/examples/matrices/nonsym/dnmatrxa.h arpack++new/examples/matrices/nonsym/dnmatrxa.h
*** arpack++/examples/matrices/nonsym/dnmatrxa.h	2000-02-22 07:15:31.000000000 -0500
--- arpack++new/examples/matrices/nonsym/dnmatrxa.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 29,35 ****
  #ifndef DNMATRXA_H
  #define DNMATRXA_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixA(ARINT nx, ARFLOAT rho, ARINT& n, ARFLOAT* &A)
--- 29,35 ----
  #ifndef DNMATRXA_H
  #define DNMATRXA_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixA(ARINT nx, ARFLOAT rho, ARINT& n, ARFLOAT* &A)
diff -crB arpack++/examples/matrices/nonsym/lnmatrxa.h arpack++new/examples/matrices/nonsym/lnmatrxa.h
*** arpack++/examples/matrices/nonsym/lnmatrxa.h	2000-02-22 07:11:45.000000000 -0500
--- arpack++new/examples/matrices/nonsym/lnmatrxa.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 9,15 ****
  #ifndef LNMATRXA_H
  #define LNMATRXA_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  
--- 9,15 ----
  #ifndef LNMATRXA_H
  #define LNMATRXA_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  
diff -crB arpack++/examples/matrices/nonsym/lnmatrxb.h arpack++new/examples/matrices/nonsym/lnmatrxb.h
*** arpack++/examples/matrices/nonsym/lnmatrxb.h	2000-02-22 07:11:03.000000000 -0500
--- arpack++new/examples/matrices/nonsym/lnmatrxb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 29,35 ****
  #ifndef LNMATRXB_H
  #define LNMATRXB_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void BlockTridMatrix(ARINT nx, ARINT& n, ARINT& nnz,
--- 29,35 ----
  #ifndef LNMATRXB_H
  #define LNMATRXB_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void BlockTridMatrix(ARINT nx, ARINT& n, ARINT& nnz,
diff -crB arpack++/examples/matrices/nonsym/lnsymsol.h arpack++new/examples/matrices/nonsym/lnsymsol.h
*** arpack++/examples/matrices/nonsym/lnsymsol.h	2000-02-22 07:05:25.000000000 -0500
--- arpack++new/examples/matrices/nonsym/lnsymsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef LNSYMSOL_H
  #define LNSYMSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #ifdef ARLNSMAT_H
--- 18,24 ----
  #ifndef LNSYMSOL_H
  #define LNSYMSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #ifdef ARLNSMAT_H
***************
*** 40,46 ****
  void Solution(ARMATRIX &A, ARluNonSymStdEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
!   on standard "cout" stream.
  */
  
  {
--- 40,46 ----
  void Solution(ARMATRIX &A, ARluNonSymStdEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 53,90 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARluNonSymStdEig \n";
!   cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
        }
        else {
!         cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
        }
      }
!     cout << endl;
    }
    
    if (Prob.EigenvectorsFound()) {
--- 53,90 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluNonSymStdEig \n";
!   std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
        }
        else {
!         std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
        }
      }
!     std::cout << std::endl;
    }
    
    if (Prob.EigenvectorsFound()) {
***************
*** 122,131 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
--- 122,131 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
***************
*** 139,145 ****
  void Solution(MATRA &A, MATRB &B, ARluNonSymGenEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problems on standard "cout" stream.
  */
  
  {
--- 139,145 ----
  void Solution(MATRA &A, MATRB &B, ARluNonSymGenEig<ARFLOAT> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problems on standard "std::cout" stream.
  */
  
  {
***************
*** 153,195 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARluNonSymGenEig \n";
!   cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   cout << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode" << endl;
      break;
    case 3:
!     cout << "Shift and invert mode (using the real part of OP)" << endl;
      break;
    case 4:
!     cout << "Shift and invert mode (using the imaginary part of OP)" << endl;
    }
!   cout << endl;
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
        }
        else {
!         cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
        }
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 153,195 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluNonSymGenEig \n";
!   std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   std::cout << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode" << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode (using the real part of OP)" << std::endl;
      break;
    case 4:
!     std::cout << "Shift and invert mode (using the imaginary part of OP)" << std::endl;
    }
!   std::cout << std::endl;
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
        }
        else {
!         std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
        }
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 232,241 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << i << ") - lambda(" << i;
!       cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] Bx;
--- 232,241 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << i << ") - lambda(" << i;
!       std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/matrices/nonsym/lsvdsol.h arpack++new/examples/matrices/nonsym/lsvdsol.h
*** arpack++/examples/matrices/nonsym/lsvdsol.h	2000-02-22 07:06:13.000000000 -0500
--- arpack++new/examples/matrices/nonsym/lsvdsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  #ifndef LSVDSOL_H
  #define LSVDSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "arssym.h"
--- 19,25 ----
  #ifndef LSVDSOL_H
  #define LSVDSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "arssym.h"
***************
*** 28,34 ****
  template<class ARMATRIX, class ARFLOAT, class ARFOP>
  void Solution(ARMATRIX &A, ARSymStdEig<ARFLOAT, ARFOP> &Prob)
  /*
!   Prints singular values and vectors on standard "cout" stream.
  */
  
  {
--- 28,34 ----
  template<class ARMATRIX, class ARFLOAT, class ARFOP>
  void Solution(ARMATRIX &A, ARSymStdEig<ARFLOAT, ARFOP> &Prob)
  /*
!   Prints singular values and vectors on standard "std::cout" stream.
  */
  
  {
***************
*** 42,65 ****
    nAx   = (n>m)?n:m;
    nconv = Prob.ConvergedEigenvalues();
  
!   cout << endl << endl << "Testing ARPACK++ class ARSymStdEig \n";
!   cout << "SVD problems: A = U*S*V'" << endl;
  
!   cout << "Dimension of the system            : " << Prob.GetN()   << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv         << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing singular values.
  
!     cout << "Singular values:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  sigma[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 42,65 ----
    nAx   = (n>m)?n:m;
    nconv = Prob.ConvergedEigenvalues();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymStdEig \n";
!   std::cout << "SVD problems: A = U*S*V'" << std::endl;
  
!   std::cout << "Dimension of the system            : " << Prob.GetN()   << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv         << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing singular values.
  
!     std::cout << "Singular values:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  sigma[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 82,91 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
!       cout << ")*u(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      // Printing the residual norm || A'*u - sigma*v ||
      // for the nconv accurately computed vectors u and v.
--- 82,91 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
!       std::cout << ")*u(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << std::endl;
  
      // Printing the residual norm || A'*u - sigma*v ||
      // for the nconv accurately computed vectors u and v.
***************
*** 99,108 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A'*u(" << (i+1) << ") - sigma(" << (i+1);
!       cout << ")*v(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] ResNorm;
--- 99,108 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A'*u(" << (i+1) << ") - sigma(" << (i+1);
!       std::cout << ")*v(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] ResNorm;
diff -crB arpack++/examples/matrices/sym/bsmatrxa.h arpack++new/examples/matrices/sym/bsmatrxa.h
*** arpack++/examples/matrices/sym/bsmatrxa.h	2000-02-22 07:27:38.000000000 -0500
--- arpack++new/examples/matrices/sym/bsmatrxa.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 31,37 ****
  #ifndef BSMATRXA_H
  #define BSMATRXA_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixA(ARINT nx, ARINT& n, ARINT& nD, ARFLOAT* &A, char uplo='L')
--- 31,37 ----
  #ifndef BSMATRXA_H
  #define BSMATRXA_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixA(ARINT nx, ARINT& n, ARINT& nD, ARFLOAT* &A, char uplo='L')
diff -crB arpack++/examples/matrices/sym/bsmatrxb.h arpack++new/examples/matrices/sym/bsmatrxb.h
*** arpack++/examples/matrices/sym/bsmatrxb.h	2000-02-22 07:27:05.000000000 -0500
--- arpack++new/examples/matrices/sym/bsmatrxb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 22,28 ****
  #ifndef BSMATRXB_H
  #define BSMATRXB_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixB(ARINT n, ARINT& nD, ARFLOAT* &A, char uplo='L')
--- 22,28 ----
  #ifndef BSMATRXB_H
  #define BSMATRXB_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixB(ARINT n, ARINT& nD, ARFLOAT* &A, char uplo='L')
diff -crB arpack++/examples/matrices/sym/bsmatrxc.h arpack++new/examples/matrices/sym/bsmatrxc.h
*** arpack++/examples/matrices/sym/bsmatrxc.h	2000-02-22 07:26:36.000000000 -0500
--- arpack++new/examples/matrices/sym/bsmatrxc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 22,28 ****
  #ifndef BSMATRXC_H
  #define BSMATRXC_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixC(ARINT n, ARINT& nD, ARFLOAT* &A, char uplo='L')
--- 22,28 ----
  #ifndef BSMATRXC_H
  #define BSMATRXC_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void BandMatrixC(ARINT n, ARINT& nD, ARFLOAT* &A, char uplo='L')
diff -crB arpack++/examples/matrices/sym/dsmatrxa.h arpack++new/examples/matrices/sym/dsmatrxa.h
*** arpack++/examples/matrices/sym/dsmatrxa.h	2000-02-22 07:25:58.000000000 -0500
--- arpack++new/examples/matrices/sym/dsmatrxa.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 27,33 ****
  #ifndef DSMATRXA_H
  #define DSMATRXA_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixA(ARINT nx, ARINT& n, ARFLOAT* &A, char uplo = 'L')
--- 27,33 ----
  #ifndef DSMATRXA_H
  #define DSMATRXA_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixA(ARINT nx, ARINT& n, ARFLOAT* &A, char uplo = 'L')
diff -crB arpack++/examples/matrices/sym/dsmatrxb.h arpack++new/examples/matrices/sym/dsmatrxb.h
*** arpack++/examples/matrices/sym/dsmatrxb.h	2000-02-22 07:25:27.000000000 -0500
--- arpack++new/examples/matrices/sym/dsmatrxb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef DSMATRXB_H
  #define DSMATRXB_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixB(ARINT n, ARFLOAT* &A, char uplo = 'L')
--- 18,24 ----
  #ifndef DSMATRXB_H
  #define DSMATRXB_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixB(ARINT n, ARFLOAT* &A, char uplo = 'L')
diff -crB arpack++/examples/matrices/sym/dsmatrxc.h arpack++new/examples/matrices/sym/dsmatrxc.h
*** arpack++/examples/matrices/sym/dsmatrxc.h	2000-02-22 07:24:55.000000000 -0500
--- arpack++new/examples/matrices/sym/dsmatrxc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef DSMATRXC_H
  #define DSMATRXC_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixC(ARINT n, ARFLOAT* &A, char uplo='L')
--- 18,24 ----
  #ifndef DSMATRXC_H
  #define DSMATRXC_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void DenseMatrixC(ARINT n, ARFLOAT* &A, char uplo='L')
diff -crB arpack++/examples/matrices/sym/lsmatrxa.h arpack++new/examples/matrices/sym/lsmatrxa.h
*** arpack++/examples/matrices/sym/lsmatrxa.h	2000-02-22 07:24:25.000000000 -0500
--- arpack++new/examples/matrices/sym/lsmatrxa.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 27,33 ****
  #ifndef LSMATRXA_H
  #define LSMATRXA_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixA(ARINT nx, ARINT& n, ARINT& nnz, ARFLOAT* &A, 
--- 27,33 ----
  #ifndef LSMATRXA_H
  #define LSMATRXA_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixA(ARINT nx, ARINT& n, ARINT& nnz, ARFLOAT* &A, 
diff -crB arpack++/examples/matrices/sym/lsmatrxb.h arpack++new/examples/matrices/sym/lsmatrxb.h
*** arpack++/examples/matrices/sym/lsmatrxb.h	2000-02-22 07:23:35.000000000 -0500
--- arpack++new/examples/matrices/sym/lsmatrxb.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef LSMATRXB_H
  #define LSMATRXB_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixB(ARINT n, ARINT& nnz, ARFLOAT* &A, 
--- 18,24 ----
  #ifndef LSMATRXB_H
  #define LSMATRXB_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixB(ARINT n, ARINT& nnz, ARFLOAT* &A, 
diff -crB arpack++/examples/matrices/sym/lsmatrxc.h arpack++new/examples/matrices/sym/lsmatrxc.h
*** arpack++/examples/matrices/sym/lsmatrxc.h	2000-02-22 07:23:01.000000000 -0500
--- arpack++new/examples/matrices/sym/lsmatrxc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef LSMATRXC_H
  #define LSMATRXC_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixC(ARINT n, ARINT& nnz, ARFLOAT* &A, 
--- 20,26 ----
  #ifndef LSMATRXC_H
  #define LSMATRXC_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixC(ARINT n, ARINT& nnz, ARFLOAT* &A, 
diff -crB arpack++/examples/matrices/sym/lsmatrxd.h arpack++new/examples/matrices/sym/lsmatrxd.h
*** arpack++/examples/matrices/sym/lsmatrxd.h	2000-02-22 07:21:37.000000000 -0500
--- arpack++new/examples/matrices/sym/lsmatrxd.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef LSMATRXD_H
  #define LSMATRXD_H
  
! #include <math.h>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixD(ARINT n, ARINT& nnz, ARFLOAT* &A, 
--- 18,24 ----
  #ifndef LSMATRXD_H
  #define LSMATRXD_H
  
! #include <cmath>
  
  template<class ARFLOAT, class ARINT>
  void SymmetricMatrixD(ARINT n, ARINT& nnz, ARFLOAT* &A, 
diff -crB arpack++/examples/matrices/sym/lsymsol.h arpack++new/examples/matrices/sym/lsymsol.h
*** arpack++/examples/matrices/sym/lsymsol.h	2000-02-22 07:22:25.000000000 -0500
--- arpack++new/examples/matrices/sym/lsymsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef LSYMSOL_H
  #define LSYMSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #ifdef ARLSMAT_H
--- 18,24 ----
  #ifndef LSYMSOL_H
  #define LSYMSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #ifdef ARLSMAT_H
***************
*** 53,85 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARluSymStdEig \n";
!   cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl;
    }
!   cout << endl;
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 53,85 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluSymStdEig \n";
!   std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl;
    }
!   std::cout << std::endl;
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 97,106 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
--- 97,106 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
***************
*** 126,165 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARluSymGenEig \n";
!   cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   cout << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode" << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl;
      break;
    case 4:
!     cout << "Buckling mode" << endl;
      break;
    case 5:
!     cout << "Cayley mode" << endl;
    }
!   cout << endl;
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 126,165 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluSymGenEig \n";
!   std::cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   std::cout << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode" << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl;
      break;
    case 4:
!     std::cout << "Buckling mode" << std::endl;
      break;
    case 5:
!     std::cout << "Cayley mode" << std::endl;
    }
!   std::cout << std::endl;
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 179,188 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << i << ") - lambda(" << i;
!       cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] Bx;
--- 179,188 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << i << ") - lambda(" << i;
!       std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/product/complex/compgsol.h arpack++new/examples/product/complex/compgsol.h
*** arpack++/examples/product/complex/compgsol.h	2000-02-21 14:52:13.000000000 -0500
--- arpack++new/examples/product/complex/compgsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  #define COMPGSOL_H
  
  #include "arcomp.h"
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
--- 19,25 ----
  #define COMPGSOL_H
  
  #include "arcomp.h"
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
***************
*** 29,35 ****
  void Solution(MATRA &A, MATRB &B, ARCompGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex generalized
!   eigen-problems on standard "cout" stream.
  */
  
  {
--- 29,35 ----
  void Solution(MATRA &A, MATRB &B, ARCompGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex generalized
!   eigen-problems on standard "std::cout" stream.
  */
  
  {
***************
*** 43,74 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARCompGenEig" << endl;
!   cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 43,74 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARCompGenEig" << std::endl;
!   std::cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 89,98 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] Bx;
--- 89,98 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/product/complex/compsol.h arpack++new/examples/product/complex/compsol.h
*** arpack++/examples/product/complex/compsol.h	2000-02-21 14:51:37.000000000 -0500
--- arpack++new/examples/product/complex/compsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  #define COMPSOL_H
  
  #include "arcomp.h"
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
--- 19,25 ----
  #define COMPSOL_H
  
  #include "arcomp.h"
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
***************
*** 29,35 ****
  void Solution(ARMATRIX &A, ARCompStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex eigen-problems
!   on standard "cout" stream.
  */
  
  {
--- 29,35 ----
  void Solution(ARMATRIX &A, ARCompStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints eigenvalues and eigenvectors of complex eigen-problems
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 42,73 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARCompStdEig \n";
!   cout << "Complex eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 42,73 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARCompStdEig \n";
!   std::cout << "Complex eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 86,95 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
--- 86,95 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
diff -crB arpack++/examples/product/complex/Makefile arpack++new/examples/product/complex/Makefile
*** arpack++/examples/product/complex/Makefile	2000-02-18 14:11:19.000000000 -0500
--- arpack++new/examples/product/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 33,39 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 33,39 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core compgreg compgshf compreg compshf
  
  # defining pattern rules.
  
diff -crB arpack++/examples/product/nonsym/Makefile arpack++new/examples/product/nonsym/Makefile
*** arpack++/examples/product/nonsym/Makefile	2000-02-18 14:02:44.000000000 -0500
--- arpack++new/examples/product/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 44,50 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 44,50 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core nsymgreg nsymgsci nsymgscr nsymgshf nsymreg nsymshf svd
  
  # defining pattern rules.
  
diff -crB arpack++/examples/product/nonsym/nsymgsol.h arpack++new/examples/product/nonsym/nsymgsol.h
*** arpack++/examples/product/nonsym/nsymgsol.h	2000-02-21 14:46:05.000000000 -0500
--- arpack++new/examples/product/nonsym/nsymgsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef NSYMGSOL_H
  #define NSYMGSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
--- 18,24 ----
  #ifndef NSYMGSOL_H
  #define NSYMGSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
***************
*** 28,34 ****
  void Solution(MATRA &A, MATRB &B, ARNonSymGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problems on standard "cout" stream.
  */
  
  {
--- 28,34 ----
  void Solution(MATRA &A, MATRB &B, ARNonSymGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric generalized
!   eigen-problems on standard "std::cout" stream.
  */
  
  {
***************
*** 42,84 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARNonSymGenEig" << endl;
!   cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   cout << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode" << endl;
      break;
    case 3:
!     cout << "Shift and invert mode (using real part of OP)" << endl;
      break;
    case 4:
!     cout << "Shift and invert mode (using imaginary part of OP)" << endl;
    }
!   cout << endl;
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
        }
        else {
!         cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
        }
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 42,84 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARNonSymGenEig" << std::endl;
!   std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   std::cout << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode" << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode (using real part of OP)" << std::endl;
      break;
    case 4:
!     std::cout << "Shift and invert mode (using imaginary part of OP)" << std::endl;
    }
!   std::cout << std::endl;
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
        }
        else {
!         std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
        }
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 121,130 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << i << ") - lambda(" << i;
!       cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] Bx;
--- 121,130 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << i << ") - lambda(" << i;
!       std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/product/nonsym/nsymsol.h arpack++new/examples/product/nonsym/nsymsol.h
*** arpack++/examples/product/nonsym/nsymsol.h	2000-02-21 14:46:37.000000000 -0500
--- arpack++new/examples/product/nonsym/nsymsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef NSYMSOL_H
  #define NSYMSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
--- 18,24 ----
  #ifndef NSYMSOL_H
  #define NSYMSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
***************
*** 28,34 ****
  void Solution(ARMATRIX &A, ARNonSymStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
!   on standard "cout" stream.
  */
  
  {
--- 28,34 ----
  void Solution(ARMATRIX &A, ARNonSymStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 41,78 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARNonSymStdEig \n";
!   cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n             << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv         << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
        }
        else {
!         cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
        }
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 41,78 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARNonSymStdEig \n";
!   std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n             << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv         << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
        if (Prob.EigenvalueImag(i)>=0.0) {
!         std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
        }
        else {
!         std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
        }
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 110,119 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
--- 110,119 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
diff -crB arpack++/examples/product/nonsym/nsymvsol.h arpack++new/examples/product/nonsym/nsymvsol.h
*** arpack++/examples/product/nonsym/nsymvsol.h	2000-02-21 14:45:21.000000000 -0500
--- arpack++new/examples/product/nonsym/nsymvsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  #ifndef NSYMVSOL_H
  #define NSYMVSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
--- 19,25 ----
  #ifndef NSYMVSOL_H
  #define NSYMVSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
***************
*** 29,35 ****
  void Solution(ARMATRIX &A, ARNonSymStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints singular values and singular vectors of nonsymmetric 
!   real matrices on standard "cout" stream.
  */
  
  {
--- 29,35 ----
  void Solution(ARMATRIX &A, ARNonSymStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints singular values and singular vectors of nonsymmetric 
!   real matrices on standard "std::cout" stream.
  */
  
  {
***************
*** 44,58 ****
    m     = A.nrows();
    nconv = Prob.ConvergedEigenvalues();
  
!   cout << endl << endl << "Testing ARPACK++ class ARNonSymStdEig \n";
!   cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << endl;
  
!   cout << "Dimension of the system              : " << n             << endl;
!   cout << "Number of 'requested' singular values: " << Prob.GetNev() << endl;
!   cout << "Number of 'converged' singular values: " << nconv         << endl;
!   cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << endl;
!   cout << "Number of iterations taken           : " << Prob.GetIter() << endl;
!   cout << endl;
  
    value = new ARFLOAT[nconv];
    Ax    = new ARFLOAT[m];
--- 44,58 ----
    m     = A.nrows();
    nconv = Prob.ConvergedEigenvalues();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARNonSymStdEig \n";
!   std::cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << std::endl;
  
!   std::cout << "Dimension of the system              : " << n             << std::endl;
!   std::cout << "Number of 'requested' singular values: " << Prob.GetNev() << std::endl;
!   std::cout << "Number of 'converged' singular values: " << nconv         << std::endl;
!   std::cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << std::endl;
!   std::cout << "Number of iterations taken           : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    value = new ARFLOAT[nconv];
    Ax    = new ARFLOAT[m];
***************
*** 62,73 ****
  
      // Printing singular values.
  
!     cout << "Singular values:" << endl;
      for (i=0; i<nconv; i++) {
        value[i] = sqrt(Prob.EigenvalueReal(i));
!       cout << "  sigma[" << (i+1) << "]: " << value[i] << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 62,73 ----
  
      // Printing singular values.
  
!     std::cout << "Singular values:" << std::endl;
      for (i=0; i<nconv; i++) {
        value[i] = sqrt(Prob.EigenvalueReal(i));
!       std::cout << "  sigma[" << (i+1) << "]: " << value[i] << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 91,98 ****
  
        // Printing the norm.
  
!       cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
!       cout << ")*u(" << (i+1) << ")||: " << ResNorm << endl;
      }
  
    }
--- 91,98 ----
  
        // Printing the norm.
  
!       std::cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
!       std::cout << ")*u(" << (i+1) << ")||: " << ResNorm << std::endl;
      }
  
    }
diff -crB arpack++/examples/product/simple/Makefile arpack++new/examples/product/simple/Makefile
*** arpack++/examples/product/simple/Makefile	2000-02-18 13:43:27.000000000 -0500
--- arpack++new/examples/product/simple/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 19,25 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core symsimp
  
  # defining pattern rules.
  
diff -crB arpack++/examples/product/simple/symsimp.cc arpack++new/examples/product/simple/symsimp.cc
*** arpack++/examples/product/simple/symsimp.cc	2000-02-18 13:43:13.000000000 -0500
--- arpack++new/examples/product/simple/symsimp.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 96,102 ****
  template<class FLOAT, class EIGPROB>
  void Solution(SymMatrix<FLOAT> &A, EIGPROB &Prob)
  /*
!   This function prints eigenvalues and eigenvetors on standard "cout" 
    stream and exemplifies how to retrieve information from ARPACK++ classes.
  */
  
--- 96,102 ----
  template<class FLOAT, class EIGPROB>
  void Solution(SymMatrix<FLOAT> &A, EIGPROB &Prob)
  /*
!   This function prints eigenvalues and eigenvetors on standard "std::cout" 
    stream and exemplifies how to retrieve information from ARPACK++ classes.
  */
  
***************
*** 119,139 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARSymEig \n";
!   cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3: 
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n             << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv         << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << endl;
!   cout << endl;
  
    /*
      EigenvaluesFound is a boolean function that indicates
--- 119,139 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymEig \n";
!   std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3: 
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n             << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv         << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << std::endl;
!   std::cout << std::endl;
  
    /*
      EigenvaluesFound is a boolean function that indicates
***************
*** 144,154 ****
    */
  
    if (Prob.EigenvaluesFound()) {
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    /*
--- 144,154 ----
    */
  
    if (Prob.EigenvaluesFound()) {
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    /*
***************
*** 174,183 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
--- 174,183 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
diff -crB arpack++/examples/product/sym/Makefile arpack++new/examples/product/sym/Makefile
*** arpack++/examples/product/sym/Makefile	2000-02-18 13:55:22.000000000 -0500
--- arpack++new/examples/product/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 39,45 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 39,45 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core symgbklg symgcayl symgreg symgshft symreg symshft
  
  # defining pattern rules.
  
diff -crB arpack++/examples/product/sym/symgsol.h arpack++new/examples/product/sym/symgsol.h
*** arpack++/examples/product/sym/symgsol.h	2000-02-21 14:40:51.000000000 -0500
--- arpack++new/examples/product/sym/symgsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef SYMGSOL_H
  #define SYMGSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "argsym.h"
  
--- 18,24 ----
  #ifndef SYMGSOL_H
  #define SYMGSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "argsym.h"
  
***************
*** 26,32 ****
  void Solution(MATRA &A, MATRB &B, ARSymGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
  /*
    Prints eigenvalues and eigenvectors of symmetric generalized
!   eigen-problems on standard "cout" stream.
  */
  
  {
--- 26,32 ----
  void Solution(MATRA &A, MATRB &B, ARSymGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
  /*
    Prints eigenvalues and eigenvectors of symmetric generalized
!   eigen-problems on standard "std::cout" stream.
  */
  
  {
***************
*** 39,77 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARSymGenEig \n";
!   cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   cout << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
      break;
    case 4:
!     cout << "Buckling mode" << endl << endl;
      break;
    case 5:
!     cout << "Cayley mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 39,77 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymGenEig \n";
!   std::cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
!   std::cout << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
      break;
    case 4:
!     std::cout << "Buckling mode" << std::endl << std::endl;
      break;
    case 5:
!     std::cout << "Cayley mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 91,100 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
      }
!     cout << endl;
  
      delete[] Ax;
      delete[] Bx;
--- 91,100 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
      }
!     std::cout << std::endl;
  
      delete[] Ax;
      delete[] Bx;
diff -crB arpack++/examples/product/sym/symsol.h arpack++new/examples/product/sym/symsol.h
*** arpack++/examples/product/sym/symsol.h	2000-02-21 14:41:31.000000000 -0500
--- arpack++new/examples/product/sym/symsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef SYMSOL_H
  #define SYMSOL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "matprod.h"
  #include "arssym.h"
--- 18,24 ----
  #ifndef SYMSOL_H
  #define SYMSOL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "matprod.h"
  #include "arssym.h"
***************
*** 27,33 ****
  void Solution(ARMATRIX &A, ARSymStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints eigenvalues and eigenvectors of symmetric eigen-problems
!   on standard "cout" stream.
  */
  
  {
--- 27,33 ----
  void Solution(ARMATRIX &A, ARSymStdEig<ARFLOAT, ARMATRIX> &Prob)
  /*
    Prints eigenvalues and eigenvectors of symmetric eigen-problems
!   on standard "std::cout" stream.
  */
  
  {
***************
*** 40,71 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARSymStdEig \n";
!   cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3: 
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
    if (Prob.EigenvectorsFound()) {
--- 40,71 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymStdEig \n";
!   std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3: 
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing eigenvalues.
  
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
    if (Prob.EigenvectorsFound()) {
***************
*** 83,92 ****
      }
  
      for (i=0; i<nconv; i++) {
!       cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
--- 83,92 ----
      }
  
      for (i=0; i<nconv; i++) {
!       std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
!       std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
      }
!     std::cout << "\n";
  
      delete[] Ax;
      delete[] ResNorm;
diff -crB arpack++/examples/reverse/complex/Makefile arpack++new/examples/reverse/complex/Makefile
*** arpack++/examples/reverse/complex/Makefile	2000-02-18 14:16:37.000000000 -0500
--- arpack++new/examples/reverse/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 37,43 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *.o *~ core
  
  # defining pattern rules.
  
--- 37,43 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *.o *~ core rcompreg rcompshf rcompgre rcompgsh
  
  # defining pattern rules.
  
diff -crB arpack++/examples/reverse/complex/rcompgsl.h arpack++new/examples/reverse/complex/rcompgsl.h
*** arpack++/examples/reverse/complex/rcompgsl.h	2000-02-22 08:34:53.000000000 -0500
--- arpack++new/examples/reverse/complex/rcompgsl.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 23,29 ****
  template<class ARFLOAT>
  void Solution(ARrcCompGenEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "cout" stream.
  */
  
  {
--- 23,29 ----
  template<class ARFLOAT>
  void Solution(ARrcCompGenEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "std::cout" stream.
  */
  
  {
***************
*** 34,63 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARrcCompGenEig" << endl;
!   cout << "Complex eigenvalue problem: A*x - B*x*lambda" << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode";
      break;
    case 3:
!     cout << "Shift and invert mode";
    }
!   cout << endl << endl;
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
  } // Solution
--- 34,63 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcCompGenEig" << std::endl;
!   std::cout << "Complex eigenvalue problem: A*x - B*x*lambda" << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode";
      break;
    case 3:
!     std::cout << "Shift and invert mode";
    }
!   std::cout << std::endl << std::endl;
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
  } // Solution
diff -crB arpack++/examples/reverse/complex/rcompsol.h arpack++new/examples/reverse/complex/rcompsol.h
*** arpack++/examples/reverse/complex/rcompsol.h	2000-02-22 08:34:31.000000000 -0500
--- arpack++new/examples/reverse/complex/rcompsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 23,29 ****
  template<class ARFLOAT>
  void Solution(ARrcCompStdEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "cout" stream.
  */
  
  {
--- 23,29 ----
  template<class ARFLOAT>
  void Solution(ARrcCompStdEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "std::cout" stream.
  */
  
  {
***************
*** 34,62 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARrcCompStdEig " << endl;
!   cout << "Complex eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
  } // Solution
--- 34,62 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcCompStdEig " << std::endl;
!   std::cout << "Complex eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
  } // Solution
diff -crB arpack++/examples/reverse/nonsym/Makefile arpack++new/examples/reverse/nonsym/Makefile
*** arpack++/examples/reverse/nonsym/Makefile	2000-02-18 14:30:14.000000000 -0500
--- arpack++new/examples/reverse/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 46,52 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *.o *~ core
  
  # defining pattern rules.
  
--- 46,52 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *.o *~ core rnsymreg rnsymshf rnsymgre rnsymgsh rnsymgsc rsvd
  
  # defining pattern rules.
  
diff -crB arpack++/examples/reverse/nonsym/rnsymgsl.h arpack++new/examples/reverse/nonsym/rnsymgsl.h
*** arpack++/examples/reverse/nonsym/rnsymgsl.h	2000-02-22 08:42:34.000000000 -0500
--- arpack++new/examples/reverse/nonsym/rnsymgsl.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 23,29 ****
  template<class ARFLOAT>
  void Solution(ARrcNonSymGenEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "cout" stream.
  */
  
  {
--- 23,29 ----
  template<class ARFLOAT>
  void Solution(ARrcNonSymGenEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "std::cout" stream.
  */
  
  {
***************
*** 34,66 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARrcNonSymGenEig" << endl;
!   cout << "Real nonsymmetric generalized eigenvalue problem: A*x - B*x*lambda" << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode";
      break;
    case 3:
!     cout << "Shift and invert mode (using real part of OP)";
      break;
    case 4:
!     cout << "Shift and invert mode (using imaginary part of OP)";
    }
!   cout << endl << endl;
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
  } // Solution
--- 34,66 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcNonSymGenEig" << std::endl;
!   std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - B*x*lambda" << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode";
      break;
    case 3:
!     std::cout << "Shift and invert mode (using real part of OP)";
      break;
    case 4:
!     std::cout << "Shift and invert mode (using imaginary part of OP)";
    }
!   std::cout << std::endl << std::endl;
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
  } // Solution
diff -crB arpack++/examples/reverse/nonsym/rnsymsol.h arpack++new/examples/reverse/nonsym/rnsymsol.h
*** arpack++/examples/reverse/nonsym/rnsymsol.h	2000-02-22 08:42:06.000000000 -0500
--- arpack++new/examples/reverse/nonsym/rnsymsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 23,29 ****
  template<class ARFLOAT>
  void Solution(ARrcNonSymStdEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "cout" stream.
  */
  
  {
--- 23,29 ----
  template<class ARFLOAT>
  void Solution(ARrcNonSymStdEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "std::cout" stream.
  */
  
  {
***************
*** 34,62 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARrcNonSymStdEig " << endl;
!   cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
  } // Solution
--- 34,62 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcNonSymStdEig " << std::endl;
!   std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
  } // Solution
diff -crB arpack++/examples/reverse/nonsym/rnsymvsl.h arpack++new/examples/reverse/nonsym/rnsymvsl.h
*** arpack++/examples/reverse/nonsym/rnsymvsl.h	2000-02-22 08:41:49.000000000 -0500
--- arpack++new/examples/reverse/nonsym/rnsymvsl.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  #ifndef RNSYMVSL_H
  #define RNSYMVSL_H
  
! #include <math.h>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
--- 19,25 ----
  #ifndef RNSYMVSL_H
  #define RNSYMVSL_H
  
! #include <cmath>
  #include "blas1c.h"
  #include "lapackc.h"
  #include "matprod.h"
***************
*** 29,35 ****
  void Solution(ARrcNonSymStdEig<ARFLOAT> &Prob)
  /*
    Prints singular values and singular vectors of nonsymmetric 
!   real matrices on standard "cout" stream.
  */
  
  {
--- 29,35 ----
  void Solution(ARrcNonSymStdEig<ARFLOAT> &Prob)
  /*
    Prints singular values and singular vectors of nonsymmetric 
!   real matrices on standard "std::cout" stream.
  */
  
  {
***************
*** 38,62 ****
  
    nconv = Prob.ConvergedEigenvalues();
  
!   cout << endl << endl << "Testing ARPACK++ class ARrcNonSymStdEig \n";
!   cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << endl;
  
!   cout << "Dimension of the system              : " << Prob.GetN()   << endl;
!   cout << "Number of 'requested' singular values: " << Prob.GetNev() << endl;
!   cout << "Number of 'converged' singular values: " << nconv         << endl;
!   cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing singular values.
  
!     cout << "Singular values:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  sigma[" << (i+1) << "]: ";
!       cout << sqrt(Prob.EigenvalueReal(i)) << endl;
      }
!     cout << endl;
    }
  
  } // Solution
--- 38,62 ----
  
    nconv = Prob.ConvergedEigenvalues();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcNonSymStdEig \n";
!   std::cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << std::endl;
  
!   std::cout << "Dimension of the system              : " << Prob.GetN()   << std::endl;
!   std::cout << "Number of 'requested' singular values: " << Prob.GetNev() << std::endl;
!   std::cout << "Number of 'converged' singular values: " << nconv         << std::endl;
!   std::cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
  
      // Printing singular values.
  
!     std::cout << "Singular values:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  sigma[" << (i+1) << "]: ";
!       std::cout << sqrt(Prob.EigenvalueReal(i)) << std::endl;
      }
!     std::cout << std::endl;
    }
  
  } // Solution
diff -crB arpack++/examples/reverse/sym/Makefile arpack++new/examples/reverse/sym/Makefile
*** arpack++/examples/reverse/sym/Makefile	2000-02-18 14:24:58.000000000 -0500
--- arpack++new/examples/reverse/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 45,51 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *.o *~ core
  
  # defining pattern rules.
  
--- 45,51 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *.o *~ core rsymgbkl rsymgcay rsymgreg rsymgshf rsymreg rsymshf
  
  # defining pattern rules.
  
diff -crB arpack++/examples/reverse/sym/rsymgsol.h arpack++new/examples/reverse/sym/rsymgsol.h
*** arpack++/examples/reverse/sym/rsymgsol.h	2000-02-22 08:53:25.000000000 -0500
--- arpack++new/examples/reverse/sym/rsymgsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 23,29 ****
  template<class ARFLOAT>
  void Solution(ARrcSymGenEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "cout" stream.
  */
  
  {
--- 23,29 ----
  template<class ARFLOAT>
  void Solution(ARrcSymGenEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "std::cout" stream.
  */
  
  {
***************
*** 34,68 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARrcSymGenEig" << endl;
!   cout << "Real symmetric eigenvalue problem: A*x - B*x*lambda" << endl;
    switch (mode) {
    case 2:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3:
!     cout << "Shift and invert mode" << endl << endl;
      break;
    case 4:
!     cout << "Buckling mode" << endl << endl;
      break;
    case 5:
!     cout << "Cayley mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
  } // Solution
--- 34,68 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcSymGenEig" << std::endl;
!   std::cout << "Real symmetric eigenvalue problem: A*x - B*x*lambda" << std::endl;
    switch (mode) {
    case 2:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3:
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
      break;
    case 4:
!     std::cout << "Buckling mode" << std::endl << std::endl;
      break;
    case 5:
!     std::cout << "Cayley mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
  } // Solution
diff -crB arpack++/examples/reverse/sym/rsymsol.h arpack++new/examples/reverse/sym/rsymsol.h
*** arpack++/examples/reverse/sym/rsymsol.h	2000-02-22 08:54:13.000000000 -0500
--- arpack++new/examples/reverse/sym/rsymsol.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 23,29 ****
  template<class ARFLOAT>
  void Solution(ARrcSymStdEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "cout" stream.
  */
  
  {
--- 23,29 ----
  template<class ARFLOAT>
  void Solution(ARrcSymStdEig<ARFLOAT> &Prob)
  /*
!   Prints eigenvalues on standard "std::cout" stream.
  */
  
  {
***************
*** 34,62 ****
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   cout << endl << endl << "Testing ARPACK++ class ARrcSymStdEig" << endl;
!   cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
    switch (mode) {
    case 1:
!     cout << "Regular mode" << endl << endl;
      break;
    case 3: 
!     cout << "Shift and invert mode" << endl << endl;
    }
  
!   cout << "Dimension of the system            : " << n              << endl;
!   cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
!   cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
!   cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
!   cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
!   cout << endl;
  
    if (Prob.EigenvaluesFound()) {
!     cout << "Eigenvalues:" << endl;
      for (i=0; i<nconv; i++) {
!       cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
      }
!     cout << endl;
    }
  
  } // Solution
--- 34,62 ----
    nconv = Prob.ConvergedEigenvalues();
    mode  = Prob.GetMode();
  
!   std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcSymStdEig" << std::endl;
!   std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
    switch (mode) {
    case 1:
!     std::cout << "Regular mode" << std::endl << std::endl;
      break;
    case 3: 
!     std::cout << "Shift and invert mode" << std::endl << std::endl;
    }
  
!   std::cout << "Dimension of the system            : " << n              << std::endl;
!   std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
!   std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
!   std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
!   std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
!   std::cout << std::endl;
  
    if (Prob.EigenvaluesFound()) {
!     std::cout << "Eigenvalues:" << std::endl;
      for (i=0; i<nconv; i++) {
!       std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
      }
!     std::cout << std::endl;
    }
  
  } // Solution
diff -crB arpack++/examples/superlu/complex/Makefile arpack++new/examples/superlu/complex/Makefile
*** arpack++/examples/superlu/complex/Makefile	2000-02-22 09:21:50.000000000 -0500
--- arpack++new/examples/superlu/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 32,38 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 32,38 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core lcompreg lcompshf lcompgre lcompgsh
  
  # defining pattern rules.
  
diff -crB arpack++/examples/superlu/nonsym/lsvd.cc arpack++new/examples/superlu/nonsym/lsvd.cc
*** arpack++/examples/superlu/nonsym/lsvd.cc	2000-03-02 12:51:33.000000000 -0500
--- arpack++new/examples/superlu/nonsym/lsvd.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 44,50 ****
  #include "arssym.h"
  #include "lnmatrxv.h"
  #include "arlnsmat.h"
! #include <math.h>
  
  
  int main()
--- 44,50 ----
  #include "arssym.h"
  #include "lnmatrxv.h"
  #include "arlnsmat.h"
! #include <cmath>
  
  
  int main()
***************
*** 94,108 ****
  
    // Printing some information about the problem.
  
!   cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
!   cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
!   cout << "  greatest singular value: " << svalue[5] << endl;
!   cout << "  smallest singular value: " << svalue[0] << endl;
!   cout << "  condition number of A  : " << cond << endl;
!   cout << "MATLAB solution:" << endl;
!   cout << "  greatest singular value:  9.89757224207690 \n";
!   cout << "  smallest singular value:  1.41683937261247 \n";
!   cout << "  condition number of A  :  6.98566995906319 \n";
  
  } // main.
  
--- 94,108 ----
  
    // Printing some information about the problem.
  
!   std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
!   std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
!   std::cout << "  greatest singular value: " << svalue[5] << std::endl;
!   std::cout << "  smallest singular value: " << svalue[0] << std::endl;
!   std::cout << "  condition number of A  : " << cond << std::endl;
!   std::cout << "MATLAB solution:" << std::endl;
!   std::cout << "  greatest singular value:  9.89757224207690 \n";
!   std::cout << "  smallest singular value:  1.41683937261247 \n";
!   std::cout << "  condition number of A  :  6.98566995906319 \n";
  
  } // main.
  
diff -crB arpack++/examples/superlu/nonsym/Makefile arpack++new/examples/superlu/nonsym/Makefile
*** arpack++/examples/superlu/nonsym/Makefile	2000-02-22 09:39:02.000000000 -0500
--- arpack++new/examples/superlu/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 43,49 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 43,49 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core lnsymreg lnsymshf lnsymgre lnsymgsh lnsymgsc lsvd lsvd2
  
  # defining pattern rules.
  
diff -crB arpack++/examples/superlu/sym/lsymgshf.cc arpack++new/examples/superlu/sym/lsymgshf.cc
*** arpack++/examples/superlu/sym/lsymgshf.cc	2000-02-22 09:44:14.000000000 -0500
--- arpack++new/examples/superlu/sym/lsymgshf.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 57,66 ****
--- 57,70 ----
  #include "arlgsym.h"
  #include "lsymsol.h"
  
+ #include <iostream>
+ using namespace std;
  
  int main()
  {
  
+ cout << "start" << endl;
+ 
    int    n;              // Dimension of the problem.
    int    nnzA,   nnzB;   // Number of nonzero elements in A and B.
    int    *irowA, *irowB; // pointer to an array that stores the row
***************
*** 74,91 ****
  
    n = 100;
    SymmetricMatrixC(n, nnzA, valA, irowA, pcolA);
    ARluSymMatrix<double> A(n, nnzA, valA, irowA, pcolA);
  
    SymmetricMatrixD(n, nnzB, valB, irowB, pcolB);
    ARluSymMatrix<double> B(n, nnzB, valB, irowB, pcolB);
  
-   // Defining what we need: the four eigenvectors nearest to 0.0.
  
    ARluSymGenEig<double> dprob('S', 4L, A, B, 0.0);
  
    // Finding eigenvalues and eigenvectors.
! 
    dprob.FindEigenvectors();
  
    // Printing solution.
  
--- 78,102 ----
  
    n = 100;
    SymmetricMatrixC(n, nnzA, valA, irowA, pcolA);
+ 
    ARluSymMatrix<double> A(n, nnzA, valA, irowA, pcolA);
  
+ 
    SymmetricMatrixD(n, nnzB, valB, irowB, pcolB);
+ 
    ARluSymMatrix<double> B(n, nnzB, valB, irowB, pcolB);
  
  
+   // Defining what we need: the four eigenvectors nearest to 0.0.
+ cout << " Defining LU Problem: " << endl;
    ARluSymGenEig<double> dprob('S', 4L, A, B, 0.0);
+ cout << " ... Done" << endl;
+   
  
    // Finding eigenvalues and eigenvectors.
! cout << "Finding Eigenvectors:" << endl;
    dprob.FindEigenvectors();
+ cout << "... Done " << endl;
  
    // Printing solution.
  
diff -crB arpack++/examples/superlu/sym/Makefile arpack++new/examples/superlu/sym/Makefile
*** arpack++/examples/superlu/sym/Makefile	2000-02-22 09:45:12.000000000 -0500
--- arpack++new/examples/superlu/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 38,44 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 38,44 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core lsymgbkl lsymgcay lsymgreg lsymgshf lsymreg lsymshf
  
  # defining pattern rules.
  
diff -crB arpack++/examples/umfpack/complex/Makefile arpack++new/examples/umfpack/complex/Makefile
*** arpack++/examples/umfpack/complex/Makefile	2000-02-22 09:51:57.000000000 -0500
--- arpack++new/examples/umfpack/complex/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 32,38 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 32,38 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core ucompreg ucompshf ucompgre ucompgsh
  
  # defining pattern rules.
  
diff -crB arpack++/examples/umfpack/nonsym/Makefile arpack++new/examples/umfpack/nonsym/Makefile
*** arpack++/examples/umfpack/nonsym/Makefile	2000-02-22 10:00:11.000000000 -0500
--- arpack++new/examples/umfpack/nonsym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 40,46 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 40,46 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core unsymreg unsymshf unsymgre unsymgsh unsymgsc usvd
  
  # defining pattern rules.
  
diff -crB arpack++/examples/umfpack/nonsym/usvd.cc arpack++new/examples/umfpack/nonsym/usvd.cc
*** arpack++/examples/umfpack/nonsym/usvd.cc	2000-02-22 10:03:23.000000000 -0500
--- arpack++new/examples/umfpack/nonsym/usvd.cc	2013-01-04 11:51:23.000000000 -0500
***************
*** 44,50 ****
  #include "arssym.h"
  #include "lnmatrxv.h"
  #include "arunsmat.h"
! #include <math.h>
  
  
  int main()
--- 44,50 ----
  #include "arssym.h"
  #include "lnmatrxv.h"
  #include "arunsmat.h"
! #include <cmath>
  
  
  int main()
***************
*** 94,108 ****
  
    // Printing some information about the problem.
  
!   cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
!   cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
!   cout << "  greatest singular value: " << svalue[5] << endl;
!   cout << "  smallest singular value: " << svalue[0] << endl;
!   cout << "  condition number of A  : " << cond << endl;
!   cout << "MATLAB solution:" << endl;
!   cout << "  greatest singular value:  9.89757224207690 \n";
!   cout << "  smallest singular value:  1.41683937261247 \n";
!   cout << "  condition number of A  :  6.98566995906319 \n";
  
  } // main.
  
--- 94,108 ----
  
    // Printing some information about the problem.
  
!   std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
!   std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
!   std::cout << "  greatest singular value: " << svalue[5] << std::endl;
!   std::cout << "  smallest singular value: " << svalue[0] << std::endl;
!   std::cout << "  condition number of A  : " << cond << std::endl;
!   std::cout << "MATLAB solution:" << std::endl;
!   std::cout << "  greatest singular value:  9.89757224207690 \n";
!   std::cout << "  smallest singular value:  1.41683937261247 \n";
!   std::cout << "  condition number of A  :  6.98566995906319 \n";
  
  } // main.
  
diff -crB arpack++/examples/umfpack/sym/Makefile arpack++new/examples/umfpack/sym/Makefile
*** arpack++/examples/umfpack/sym/Makefile	2000-02-22 10:07:07.000000000 -0500
--- arpack++new/examples/umfpack/sym/Makefile	2013-01-04 11:51:23.000000000 -0500
***************
*** 38,44 ****
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core
  
  # defining pattern rules.
  
--- 38,44 ----
  
  .PHONY:	clean
  clean:
! 	rm -f *~ *.o core usymreg usymshf usymgreg usymgshf usymgbkl usymgcay
  
  # defining pattern rules.
  
diff -crB arpack++/include/arbgcomp.h arpack++new/include/arbgcomp.h
*** arpack++/include/arbgcomp.h	2000-02-20 08:34:16.000000000 -0500
--- arpack++new/include/arbgcomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARBGCOMP_H
  #define ARBGCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arbnsmat.h"
  #include "arbnspen.h"
--- 18,25 ----
  #ifndef ARBGCOMP_H
  #define ARBGCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arbnsmat.h"
  #include "arbnspen.h"
***************
*** 65,78 ****
  
    ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 66,79 ----
  
    ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 103,110 ****
    ARCompGenEig<ARFLOAT, ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
  
  } // Copy.
  
--- 104,111 ----
    ARCompGenEig<ARFLOAT, ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
  
  } // Copy.
  
***************
*** 114,120 ****
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   objOP->FactorAsB(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
--- 115,121 ----
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   this->objOP->FactorAsB(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
***************
*** 148,162 ****
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
--- 149,163 ----
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const std::string& whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
***************
*** 169,182 ****
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
                     &Pencil, 
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>,ARFLOAT>::MultBv, 
--- 170,183 ----
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
                     &Pencil, 
                     &ARbdNonSymPencil<arcomplex<ARFLOAT>,ARFLOAT>::MultBv, 
***************
*** 192,198 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 193,199 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arbgnsym.h arpack++new/include/arbgnsym.h
*** arpack++/include/arbgnsym.h	2000-02-20 08:18:20.000000000 -0500
--- arpack++new/include/arbgnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARBGNSYM_H
  #define ARBGNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arbnsmat.h"
  #include "arbnspen.h"
--- 18,25 ----
  #ifndef ARBGNSYM_H
  #define ARBGNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arbnsmat.h"
  #include "arbnspen.h"
***************
*** 64,84 ****
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
--- 65,85 ----
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
***************
*** 110,118 ****
    ARNonSymGenEig<ARFLOAT, ARbdNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARbdNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
  
  } // Copy.
  
--- 111,119 ----
    ARNonSymGenEig<ARFLOAT, ARbdNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARbdNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
  
  } // Copy.
  
***************
*** 123,132 ****
  {
  
    if (sigmaIp == 0.0) {
!     objOP->FactorAsB(sigmaRp);
    }
    else {
!     objOP->FactorAsB(sigmaRp, sigmaIp, part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
--- 124,133 ----
  {
  
    if (sigmaIp == 0.0) {
!     this->objOP->FactorAsB(sigmaRp);
    }
    else {
!     this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
***************
*** 172,185 ****
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 173,186 ----
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 191,203 ****
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 192,204 ----
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 210,222 ****
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp, 
!                  ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp, int ncvp, 
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 211,223 ----
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp, 
!                  ARFLOAT sigmaRp, ARFLOAT sigmaIp, const std::string& whichp, int ncvp, 
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 231,237 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 232,238 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arbgsym.h arpack++new/include/arbgsym.h
*** arpack++/include/arbgsym.h	2000-02-20 08:10:22.000000000 -0500
--- arpack++new/include/arbgsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARBGSYM_H
  #define ARBGSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arbsmat.h"
  #include "arbspen.h"
--- 18,25 ----
  #ifndef ARBGSYM_H
  #define ARBGSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arbsmat.h"
  #include "arbspen.h"
***************
*** 66,78 ****
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 ARbdSymMatrix<ARFLOAT>& B, char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 ARbdSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM", 
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
--- 67,79 ----
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 ARbdSymMatrix<ARFLOAT>& B, const std::string& whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 ARbdSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const std::string& whichp = "LM", 
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
***************
*** 104,112 ****
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>,
                ARbdSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
  
  } // Copy.
  
--- 105,113 ----
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>,
                ARbdSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
  
  } // Copy.
  
***************
*** 115,121 ****
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
--- 116,122 ----
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   this->objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
***************
*** 138,144 ****
  
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>, ARbdSymPencil<ARFLOAT> >::
      SetShiftInvertMode(sigmap, &Pencil, &ARbdSymPencil<ARFLOAT>::MultInvAsBv);
!   ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultBv);
  
  } // SetShiftInvertMode.
  
--- 139,145 ----
  
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>, ARbdSymPencil<ARFLOAT> >::
      SetShiftInvertMode(sigmap, &Pencil, &ARbdSymPencil<ARFLOAT>::MultInvAsBv);
!   this->ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultBv);
  
  } // SetShiftInvertMode.
  
***************
*** 150,156 ****
  
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>, ARbdSymPencil<ARFLOAT> >::
      SetBucklingMode(sigmap, &Pencil, &ARbdSymPencil<ARFLOAT>::MultInvAsBv);
!   ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
  
  } // SetBucklingMode.
  
--- 151,157 ----
  
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>, ARbdSymPencil<ARFLOAT> >::
      SetBucklingMode(sigmap, &Pencil, &ARbdSymPencil<ARFLOAT>::MultInvAsBv);
!   this->ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
  
  } // SetBucklingMode.
  
***************
*** 163,169 ****
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>, ARbdSymPencil<ARFLOAT> >::
      SetCayleyMode(sigmap, &Pencil, &ARbdSymPencil<ARFLOAT>::MultInvAsBv,
                    &Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
!   ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultBv);
  
  } // SetCayleyMode.
  
--- 164,170 ----
    ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>, ARbdSymPencil<ARFLOAT> >::
      SetCayleyMode(sigmap, &Pencil, &ARbdSymPencil<ARFLOAT>::MultInvAsBv,
                    &Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
!   this->ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultBv);
  
  } // SetCayleyMode.
  
***************
*** 171,185 ****
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!               ARbdSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   InvertMode = 'S';
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 172,186 ----
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!               ARbdSymMatrix<ARFLOAT>& B, const std::string& whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->InvertMode = 'S';
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 191,210 ****
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
                ARbdSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   InvertMode = CheckInvertMode(InvertModep);
!   switch (InvertMode) {
    case 'B':
!     ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
    case 'S':
      ChangeShift(sigmap);
      break;
--- 192,211 ----
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,
                ARbdSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   this->InvertMode = this->CheckInvertMode(InvertModep);
!   switch (this->InvertMode) {
    case 'B':
!     this->ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
    case 'S':
      ChangeShift(sigmap);
      break;
***************
*** 221,227 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 222,228 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arbnsmat.h arpack++new/include/arbnsmat.h
*** arpack++/include/arbnsmat.h	2000-02-20 18:00:46.000000000 -0500
--- arpack++new/include/arbnsmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARBNSMAT_H
  #define ARBNSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
--- 20,26 ----
  #ifndef ARBNSMAT_H
  #define ARBNSMAT_H
  
! #include <cstddef>
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
***************
*** 123,131 ****
  
    // Copying very fundamental variables and user-defined parameters.
  
!   m         = other.m;
!   n         = other.n;
!   defined   = other.defined;
    factored  = other.factored;
    ndiagL    = other.ndiagL;
    ndiagU    = other.ndiagU;
--- 123,131 ----
  
    // Copying very fundamental variables and user-defined parameters.
  
!   this->m         = other.m;
!    this->n         = other.n;
!    this->defined   = other.defined;
    factored  = other.factored;
    ndiagL    = other.ndiagL;
    ndiagU    = other.ndiagU;
***************
*** 139,149 ****
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[n*lda];
!   ipiv = new int[n];
  
!   copy(n*lda, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
--- 139,149 ----
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[ this->n*lda];
!   ipiv = new int[ this->n];
  
!   copy( this->n*lda, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i< this->n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
***************
*** 158,164 ****
  
    inca = ndiagL+ndiagU+1;
    for (i = 0; i < inca; i++) {
!     copy(n, &A[i], inca, &Ainv[ndiagL+i], lda);
    }
  
  } // ExpandA.
--- 158,164 ----
  
    inca = ndiagL+ndiagU+1;
    for (i = 0; i < inca; i++) {
!     copy( this->n, &A[i], inca, &Ainv[ndiagL+i], lda);
    }
  
  } // ExpandA.
***************
*** 174,180 ****
  
    // Subtracting sigma from diagonal elements.
  
!   for (int i=(ndiagL+ndiagU); i<(lda*n); i+=lda) Ainv[i] -= sigma; 
  
  } // SubtractAsI.
  
--- 174,180 ----
  
    // Subtracting sigma from diagonal elements.
  
!   for (int i=(ndiagL+ndiagU); i<(lda* this->n); i+=lda) Ainv[i] -= sigma; 
  
  } // SubtractAsI.
  
***************
*** 184,191 ****
  {
  
    ClearMem();
!   Ainv = new ARTYPE[lda*n];
!   ipiv = new int[n];
  
  } // CreateStructure.
  
--- 184,191 ----
  {
  
    ClearMem();
!   Ainv = new ARTYPE[lda* this->n];
!   ipiv = new int[ this->n];
  
  } // CreateStructure.
  
***************
*** 212,218 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::FactorA");
    }
  
--- 212,218 ----
  
    // Quitting the function if A was not defined.
  
!   if (! this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::FactorA");
    }
  
***************
*** 226,232 ****
  
    // Decomposing A.
  
!   gbtrf(n, n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
--- 226,232 ----
  
    // Decomposing A.
  
!   gbtrf( this->n,  this->n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
***************
*** 243,249 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARbdNonSymMatrix::FactorAsI");
    }
--- 243,249 ----
  
    // Quitting the function if A was not defined.
  
!   if (! this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARbdNonSymMatrix::FactorAsI");
    }
***************
*** 258,264 ****
  
    // Decomposing AsI.
  
!   gbtrf(n, n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
--- 258,264 ----
  
    // Decomposing AsI.
  
!   gbtrf( this->n,  this->n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
***************
*** 281,293 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   gbmv("N", m, n, ndiagL, ndiagU, one, A,
         ndiagL+ndiagU+1, v, 1, zero, w, 1);
  
  } // MultMv.
--- 281,293 ----
  
    // Quitting the function if A was not defined.
  
!   if (! this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   gbmv("N",  this->m,  this->n, ndiagL, ndiagU, one, A,
         ndiagL+ndiagU+1, v, 1, zero, w, 1);
  
  } // MultMv.
***************
*** 305,317 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMtv");
    }
  
    // Determining w = M'.v.
  
!   gbmv("T", m, n, ndiagL, ndiagU, one, A,
         ndiagL+ndiagU+1, v, 1, zero, w, 1);   
  
  } // MultMtv.
--- 305,317 ----
  
    // Quitting the function if A was not defined.
  
!   if (! this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMtv");
    }
  
    // Determining w = M'.v.
  
!   gbmv("T",  this->m,  this->n, ndiagL, ndiagU, one, A,
         ndiagL+ndiagU+1, v, 1, zero, w, 1);   
  
  } // MultMtv.
***************
*** 321,327 ****
  void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[m];
  
    MultMv(v,t);
    MultMtv(t,w);
--- 321,327 ----
  void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[ this->m];
  
    MultMv(v,t);
    MultMtv(t,w);
***************
*** 335,341 ****
  void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[n];
  
    MultMtv(v,t);
    MultMv(t,w);
--- 335,341 ----
  void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[ this->n];
  
    MultMtv(v,t);
    MultMv(t,w);
***************
*** 349,356 ****
  void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[m],w);
!   MultMtv(v,&w[m]);
  
  } // Mult0MMt0v.
  
--- 349,356 ----
  void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[ this->m],w);
!   MultMtv(v,&w[ this->m]);
  
  } // Mult0MMt0v.
  
***************
*** 368,378 ****
  
    // Overwritting w with v.
  
!   copy(n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   gbtrs("N", n, ndiagL, ndiagU, 1, Ainv, lda, ipiv, w, m, info);
  
    // Handling errors.
  
--- 368,378 ----
  
    // Overwritting w with v.
  
!   copy( this->n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   gbtrs("N",  this->n, ndiagL, ndiagU, 1, Ainv, lda, ipiv, w,  this->m, info);
  
    // Handling errors.
  
***************
*** 388,400 ****
  
    // Defining member variables.
  
!   m         = np;
!   n         = np;
    ndiagL    = ndiagLp;
    ndiagU    = ndiagUp;
    lda       = 2*ndiagL+ndiagU+1;
    A         = Ap;
!   defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
--- 388,400 ----
  
    // Defining member variables.
  
!    this->m         = np;
!    this->n         = np;
    ndiagL    = ndiagLp;
    ndiagU    = ndiagUp;
    lda       = 2*ndiagL+ndiagU+1;
    A         = Ap;
!    this->defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
***************
*** 420,426 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 420,426 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!      this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arbscomp.h arpack++new/include/arbscomp.h
*** arpack++/include/arbscomp.h	2000-02-20 08:29:32.000000000 -0500
--- arpack++new/include/arbscomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARBSCOMP_H
  #define ARBSCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arscomp.h"
  #include "arbnsmat.h"
--- 18,25 ----
  #ifndef ARBSCOMP_H
  #define ARBSCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arscomp.h"
  #include "arbnsmat.h"
***************
*** 48,60 ****
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 49,61 ----
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 84,90 ****
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   objOP->FactorAsI(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
--- 85,91 ----
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   this->objOP->FactorAsI(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
***************
*** 96,102 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
!     SetRegularMode(objOP,&ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 97,103 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
!     SetRegularMode(this->objOP,&ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 108,114 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
             ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP,
                         &ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 109,115 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
             ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP,
                         &ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 117,129 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                char* whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A,
                     &ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 118,130 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                const std::string& whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A,
                     &ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 133,145 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, 
                     &ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
--- 134,146 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, 
                     &ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
***************
*** 153,159 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 154,160 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arbsmat.h arpack++new/include/arbsmat.h
*** arpack++/include/arbsmat.h	2000-02-20 07:46:20.000000000 -0500
--- arpack++new/include/arbsmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARBSMAT_H
  #define ARBSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
--- 20,26 ----
  #ifndef ARBSMAT_H
  #define ARBSMAT_H
  
! #include <cstddef>
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
***************
*** 114,122 ****
  
    // Copying very fundamental variables and user-defined parameters.
  
!   m         = other.m;
!   n         = other.n;
!   defined   = other.defined;
    factored  = other.factored;
    uplo      = other.uplo;
    nsdiag    = other.nsdiag;
--- 114,122 ----
  
    // Copying very fundamental variables and user-defined parameters.
  
!   this->m         = other.m;
!   this->n         = other.n;
!   this->defined   = other.defined;
    factored  = other.factored;
    uplo      = other.uplo;
    nsdiag    = other.nsdiag;
***************
*** 130,140 ****
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[n*lda];
!   ipiv = new int[n];
  
!   copy(n*lda, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
--- 130,140 ----
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[this->n*lda];
!   ipiv = new int[this->n];
  
!   copy(this->n*lda, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
***************
*** 149,161 ****
  
      // Copying the main diagonal of A to Ainv.
  
!     copy(n, &A[nsdiag], nsdiag+1, &Ainv[2*nsdiag], lda);
  
      // Copying the superdiagonals of A to Ainv.
  
      for (i = 0; i < nsdiag; i++) {
!       copy(n, &A[i], nsdiag+1, &Ainv[nsdiag+i], lda);
!       copy(n-nsdiag+i, &A[i+(nsdiag-i)*(nsdiag+1)], nsdiag+1, 
             &Ainv[3*nsdiag-i], lda);
      }
  
--- 149,161 ----
  
      // Copying the main diagonal of A to Ainv.
  
!     copy(this->n, &A[nsdiag], nsdiag+1, &Ainv[2*nsdiag], lda);
  
      // Copying the superdiagonals of A to Ainv.
  
      for (i = 0; i < nsdiag; i++) {
!       copy(this->n, &A[i], nsdiag+1, &Ainv[nsdiag+i], lda);
!       copy(this->n-nsdiag+i, &A[i+(nsdiag-i)*(nsdiag+1)], nsdiag+1, 
             &Ainv[3*nsdiag-i], lda);
      }
  
***************
*** 164,176 ****
  
      // Copying the main diagonal of A to Ainv.
  
!     copy(n, &A[0], nsdiag+1, &Ainv[2*nsdiag], lda);
  
      // Copying the subdiagonals of A to Ainv.
  
      for (i = 1; i <= nsdiag; i++) {
!       copy(n, &A[i], nsdiag+1, &Ainv[2*nsdiag+i], lda);
!       copy(n-i, &A[i], nsdiag+1, &Ainv[2*nsdiag-i+i*lda], lda);
      }
  
    }
--- 164,176 ----
  
      // Copying the main diagonal of A to Ainv.
  
!     copy(this->n, &A[0], nsdiag+1, &Ainv[2*nsdiag], lda);
  
      // Copying the subdiagonals of A to Ainv.
  
      for (i = 1; i <= nsdiag; i++) {
!       copy(this->n, &A[i], nsdiag+1, &Ainv[2*nsdiag+i], lda);
!       copy(this->n-i, &A[i], nsdiag+1, &Ainv[2*nsdiag-i+i*lda], lda);
      }
  
    }
***************
*** 188,194 ****
  
    // Subtracting sigma from diagonal elements.
  
!   for (int i=(2*nsdiag); i<(lda*n); i+=lda) Ainv[i] -= sigma; 
  
  } // SubtractAsI.
  
--- 188,194 ----
  
    // Subtracting sigma from diagonal elements.
  
!   for (int i=(2*nsdiag); i<(lda*this->n); i+=lda) Ainv[i] -= sigma; 
  
  } // SubtractAsI.
  
***************
*** 198,205 ****
  {
  
    ClearMem();
!   Ainv = new ARTYPE[lda*n];
!   ipiv = new int[n];
  
  } // CreateStructure.
  
--- 198,205 ----
  {
  
    ClearMem();
!   Ainv = new ARTYPE[lda*this->n];
!   ipiv = new int[this->n];
  
  } // CreateStructure.
  
***************
*** 226,232 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorA");
    }
  
--- 226,232 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorA");
    }
  
***************
*** 240,246 ****
  
    // Decomposing A.
  
!   gbtrf(n, n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
--- 240,246 ----
  
    // Decomposing A.
  
!   gbtrf(this->n, this->n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
***************
*** 257,263 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorAsI");
    }
  
--- 257,263 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorAsI");
    }
  
***************
*** 271,277 ****
  
    // Decomposing AsI.
  
!   gbtrf(n, n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
--- 271,277 ----
  
    // Decomposing AsI.
  
!   gbtrf(this->n, this->n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
  
    // Handling errors.
  
***************
*** 291,303 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   sbmv(&uplo, n, nsdiag, one, A, nsdiag+1, v, 1, zero, w, 1);
  
  } // MultMv.
  
--- 291,303 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   sbmv(&uplo, this->n, nsdiag, one, A, nsdiag+1, v, 1, zero, w, 1);
  
  } // MultMv.
  
***************
*** 315,325 ****
  
    // Overwritting w with v.
  
!   copy(n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   gbtrs("N", n, nsdiag, nsdiag, 1, Ainv, lda, ipiv, w, m, info);
  
    // Handling errors.
  
--- 315,325 ----
  
    // Overwritting w with v.
  
!   copy(this->n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   gbtrs("N", this->n, nsdiag, nsdiag, 1, Ainv, lda, ipiv, w, this->m, info);
  
    // Handling errors.
  
***************
*** 335,347 ****
  
    // Defining member variables.
  
!   m         = np;
!   n         = np;
    nsdiag    = nsdiagp;
    lda       = 3*nsdiag+1;
    uplo      = uplop;
    A         = Ap;
!   defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
--- 335,347 ----
  
    // Defining member variables.
  
!   this->m         = np;
!   this->n         = np;
    nsdiag    = nsdiagp;
    lda       = 3*nsdiag+1;
    uplo      = uplop;
    A         = Ap;
!   this->defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
***************
*** 367,373 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 367,373 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arbsnsym.h arpack++new/include/arbsnsym.h
*** arpack++/include/arbsnsym.h	2000-02-20 08:14:28.000000000 -0500
--- arpack++new/include/arbsnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARBSNSYM_H
  #define ARBSNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arsnsym.h"
  #include "arbnsmat.h"
--- 18,25 ----
  #ifndef ARBSNSYM_H
  #define ARBSNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arsnsym.h"
  #include "arbnsmat.h"
***************
*** 46,58 ****
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 47,59 ----
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 81,93 ****
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 82,94 ----
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!    this->sigmaR    = sigmaRp;
!    this->sigmaI    = 0.0;
!    this->mode      = 3;
!    this->iparam[7] =  this->mode;
  
!    this->objOP->FactorAsI( this->sigmaR);
!    this->Restart();
  
  } // ChangeShift.
  
***************
*** 97,103 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode(objOP, &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 98,104 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode( this->objOP, &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 107,113 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, 
                         &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 108,114 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap,  this->objOP, 
                         &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 116,129 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A, 
!                    &(ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv),
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
--- 117,130 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!    this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A, 
!                    &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
***************
*** 132,143 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, 
                     &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
--- 133,144 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, 
                     &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
***************
*** 151,157 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 152,158 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!      this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arbssym.h arpack++new/include/arbssym.h
*** arpack++/include/arbssym.h	2000-02-20 08:08:20.000000000 -0500
--- arpack++new/include/arbssym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARBSSYM_H
  #define ARBSSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arssym.h"
  #include "arbsmat.h"
--- 18,25 ----
  #ifndef ARBSSYM_H
  #define ARBSSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arssym.h"
  #include "arbsmat.h"
***************
*** 46,58 ****
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 47,59 ----
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 81,93 ****
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 82,94 ----
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = 0.0;
!   this->mode      = 3;
!   this->iparam[7] = this->mode;
  
!   this->objOP->FactorAsI(this->sigmaR);
!   this->Restart();
  
  } // ChangeShift.
  
***************
*** 97,103 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
!     SetRegularMode(objOP, &ARbdSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 98,104 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
!     SetRegularMode(this->objOP, &ARbdSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 107,113 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, &ARbdSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
--- 108,114 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP, &ARbdSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
***************
*** 115,126 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
--- 116,127 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
***************
*** 129,140 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
--- 130,141 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
***************
*** 147,153 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 148,154 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arch.h arpack++new/include/arch.h
*** arpack++/include/arch.h	2000-03-03 15:35:38.000000000 -0500
--- arpack++new/include/arch.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 29,35 ****
  // If the Standard Template Library is not available at your system
  // and you do not want to install it, comment out the following line.
  
! #include <vector.h>
  
  // If your STL vector class defines a variable other than
  // __SGI_STL_VECTOR_H, please change this variable name 
--- 29,35 ----
  // If the Standard Template Library is not available at your system
  // and you do not want to install it, comment out the following line.
  
! #include <vector>
  
  // If your STL vector class defines a variable other than
  // __SGI_STL_VECTOR_H, please change this variable name 
diff -crB arpack++/include/arcomp.h arpack++new/include/arcomp.h
*** arpack++/include/arcomp.h	2000-02-20 08:05:08.000000000 -0500
--- arpack++new/include/arcomp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,27 ****
  #ifndef ARCOMP_H
  #define ARCOMP_H
  
! #include <complex.h>
  
  #ifdef __GNUG__
    
! #define arcomplex complex
  
  #endif
  
--- 17,27 ----
  #ifndef ARCOMP_H
  #define ARCOMP_H
  
! #include <complex>
  
  #ifdef __GNUG__
    
! #define arcomplex std::complex
  
  #endif
  
diff -crB arpack++/include/ardfmat.h arpack++new/include/ardfmat.h
*** arpack++/include/ardfmat.h	2000-02-21 15:00:20.000000000 -0500
--- arpack++new/include/ardfmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,29 ****
  #ifndef ARDFMAT_H
  #define ARDFMAT_H
  
! #include <stddef.h>
! #include <fstream.h>
! #include <stdlib.h>
! #include <string.h>
! #include <stdio.h>
  #include "arch.h"
  #include "arerror.h"
  
--- 19,30 ----
  #ifndef ARDFMAT_H
  #define ARDFMAT_H
  
! #include <cstddef>
! #include <fstream>
! #include <cstdlib>
! #include <cstring>
! #include <cstdio>
! #include <string>
  #include "arch.h"
  #include "arerror.h"
  
***************
*** 35,42 ****
  
    // const int linelength = 256;
  
!   char*    datafile;  // Filename.
!   ifstream file;      // File handler.
    int      m;         // Number of rows.
    int      n;         // Number of columns.
    int      blksize;   // Size of each matrix block that is read at once.
--- 36,43 ----
  
    // const int linelength = 256;
  
!   std::string   datafile;  // Filename.
!   std::ifstream file;      // File handler.
    int      m;         // Number of rows.
    int      n;         // Number of columns.
    int      blksize;   // Size of each matrix block that is read at once.
***************
*** 55,67 ****
  
    void SetComplexPointers(char* num, char* &realp, char* &imagp);
  			  			  
!   bool ReadEntry(ifstream& file, double& val);
  
!   bool ReadEntry(ifstream& file, float& val);
  
!   bool ReadEntry(ifstream& file, arcomplex<double>& val);
  
!   bool ReadEntry(ifstream& file, arcomplex<float>& val);
    
   public:
    
--- 56,68 ----
  
    void SetComplexPointers(char* num, char* &realp, char* &imagp);
  			  			  
!   bool ReadEntry(std::ifstream& file, double& val);
  
!   bool ReadEntry(std::ifstream& file, float& val);
  
!   bool ReadEntry(std::ifstream& file, arcomplex<double>& val);
  
!   bool ReadEntry(std::ifstream& file, arcomplex<float>& val);
    
   public:
    
***************
*** 73,79 ****
  
    bool IsRowOrdered() const { return roword; }
  
!   char* Filename() const { return datafile; }
  
    void Rewind();
  
--- 74,80 ----
  
    bool IsRowOrdered() const { return roword; }
  
!   std::string Filename() const { return datafile; }
  
    void Rewind();
  
***************
*** 96,109 ****
    void ReadBlock();
    // Function that reads a block of blksize rows/columns of the matrix.
  
!   void Define(char* filename, int blksizep = 0);
    // Function that reads the matrix dimension. Define also read all
    // of the matrix elements when blocksize = 0.
    
    ARdfMatrix();
    // Short constructor.
  
!   ARdfMatrix(char* filename, int blksizep = 0);
    // Long constructor.
  
    ~ARdfMatrix();
--- 97,110 ----
    void ReadBlock();
    // Function that reads a block of blksize rows/columns of the matrix.
  
!   void Define(const std::string& filename, int blksizep = 0);
    // Function that reads the matrix dimension. Define also read all
    // of the matrix elements when blocksize = 0.
    
    ARdfMatrix();
    // Short constructor.
  
!   ARdfMatrix(const std::string& filename, int blksizep = 0);
    // Long constructor.
  
    ~ARdfMatrix();
***************
*** 145,151 ****
  
  
  template<class ARTYPE>
! inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, double& val)
  {
  
    char num[LINELEN];
--- 146,152 ----
  
  
  template<class ARTYPE>
! inline bool ARdfMatrix<ARTYPE>::ReadEntry(std::ifstream& file, double& val)
  {
  
    char num[LINELEN];
***************
*** 165,171 ****
  
  
  template<class ARTYPE>
! inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, float& val)
  {
  
    double dval;
--- 166,172 ----
  
  
  template<class ARTYPE>
! inline bool ARdfMatrix<ARTYPE>::ReadEntry(std::ifstream& file, float& val)
  {
  
    double dval;
***************
*** 180,186 ****
  
  template<class ARTYPE>
  inline bool ARdfMatrix<ARTYPE>::
! ReadEntry(ifstream& file, arcomplex<double>& val)
  {
  
    char  num[LINELEN];
--- 181,187 ----
  
  template<class ARTYPE>
  inline bool ARdfMatrix<ARTYPE>::
! ReadEntry(std::ifstream& file, arcomplex<double>& val)
  {
  
    char  num[LINELEN];
***************
*** 204,210 ****
  
  template<class ARTYPE>
  inline bool ARdfMatrix<ARTYPE>::
! ReadEntry(ifstream& file, arcomplex<float>& val)
  {
  
    char  num[LINELEN];
--- 205,211 ----
  
  template<class ARTYPE>
  inline bool ARdfMatrix<ARTYPE>::
! ReadEntry(std::ifstream& file, arcomplex<float>& val)
  {
  
    char  num[LINELEN];
***************
*** 325,331 ****
  
  
  template<class ARTYPE>
! void ARdfMatrix<ARTYPE>::Define(char* filename, int blksizep)
  {
  
    // Declaring variables.
--- 326,332 ----
  
  
  template<class ARTYPE>
! void ARdfMatrix<ARTYPE>::Define(const std::string& filename, int blksizep)
  {
  
    // Declaring variables.
***************
*** 336,342 ****
    // Opening the file.
  
    datafile = filename;
!   file.open(datafile);
    
    if (!file) {
      throw ArpackError(ArpackError::CANNOT_OPEN_FILE, "ARdfMatrix");
--- 337,343 ----
    // Opening the file.
  
    datafile = filename;
!   file.open(datafile.c_str());
    
    if (!file) {
      throw ArpackError(ArpackError::CANNOT_OPEN_FILE, "ARdfMatrix");
***************
*** 430,436 ****
  
  
  template<class ARTYPE>
! ARdfMatrix<ARTYPE>::ARdfMatrix(char* filename, int blksizep) 
  { 
  
    val = NULL;
--- 431,437 ----
  
  
  template<class ARTYPE>
! ARdfMatrix<ARTYPE>::ARdfMatrix(const std::string& filename, int blksizep) 
  { 
  
    val = NULL;
diff -crB arpack++/include/ardgcomp.h arpack++new/include/ardgcomp.h
*** arpack++/include/ardgcomp.h	2000-02-20 18:30:26.000000000 -0500
--- arpack++new/include/ardgcomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARDGCOMP_H
  #define ARDGCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "ardnsmat.h"
  #include "ardnspen.h"
--- 18,25 ----
  #ifndef ARDGCOMP_H
  #define ARDGCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "ardnsmat.h"
  #include "ardnspen.h"
***************
*** 65,78 ****
  
    ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 66,79 ----
  
    ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 103,110 ****
    ARCompGenEig<ARFLOAT, ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
  
  } // Copy.
  
--- 104,111 ----
    ARCompGenEig<ARFLOAT, ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
  
  } // Copy.
  
***************
*** 114,120 ****
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   objOP->FactorAsB(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
--- 115,121 ----
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   this->objOP->FactorAsB(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
***************
*** 148,162 ****
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
--- 149,163 ----
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const std::string& whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
***************
*** 169,182 ****
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
                     &Pencil, 
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
--- 170,183 ----
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
                     &Pencil, 
                     &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
***************
*** 192,198 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 193,199 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/ardgnsym.h arpack++new/include/ardgnsym.h
*** arpack++/include/ardgnsym.h	2000-02-20 18:18:48.000000000 -0500
--- arpack++new/include/ardgnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARDGNSYM_H
  #define ARDGNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "ardnsmat.h"
  #include "ardnspen.h"
--- 18,25 ----
  #ifndef ARDGNSYM_H
  #define ARDGNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "ardnsmat.h"
  #include "ardnspen.h"
***************
*** 64,84 ****
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
--- 65,85 ----
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
***************
*** 110,118 ****
    ARNonSymGenEig<ARFLOAT, ARdsNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARdsNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
  
  } // Copy.
  
--- 111,119 ----
    ARNonSymGenEig<ARFLOAT, ARdsNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARdsNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
  
  } // Copy.
  
***************
*** 123,132 ****
  {
  
    if (sigmaIp == 0.0) {
!     objOP->FactorAsB(sigmaRp);
    }
    else {
!     objOP->FactorAsB(sigmaRp, sigmaIp, part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
--- 124,133 ----
  {
  
    if (sigmaIp == 0.0) {
!     this->objOP->FactorAsB(sigmaRp);
    }
    else {
!     this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
***************
*** 172,185 ****
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 173,186 ----
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 191,203 ****
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 192,204 ----
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 210,223 ****
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
!                  char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp, 
                   int ncvp, ARFLOAT tolp, int maxitp, ARFLOAT* residp, 
                   bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 211,224 ----
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
!                  char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp, const std::string& whichp, 
                   int ncvp, ARFLOAT tolp, int maxitp, ARFLOAT* residp, 
                   bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 232,238 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 233,239 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/ardgsym.h arpack++new/include/ardgsym.h
*** arpack++/include/ardgsym.h	2000-02-20 18:11:24.000000000 -0500
--- arpack++new/include/ardgsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARDGSYM_H
  #define ARDGSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "ardsmat.h"
  #include "ardspen.h"
--- 18,25 ----
  #ifndef ARDGSYM_H
  #define ARDGSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "ardsmat.h"
  #include "ardspen.h"
***************
*** 66,78 ****
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 ARdsSymMatrix<ARFLOAT>& B, char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 ARdsSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM", 
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
--- 67,79 ----
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 ARdsSymMatrix<ARFLOAT>& B, const std::string& whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 ARdsSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const std::string& whichp = "LM", 
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
***************
*** 104,112 ****
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>,
                ARdsSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
  
  } // Copy.
  
--- 105,113 ----
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>,
                ARdsSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
  
  } // Copy.
  
***************
*** 115,121 ****
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
--- 116,122 ----
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   this->objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
***************
*** 138,144 ****
  
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>, ARdsSymPencil<ARFLOAT> >::
      SetShiftInvertMode(sigmap, &Pencil, &ARdsSymPencil<ARFLOAT>::MultInvAsBv);
!   ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultBv);
  
  } // SetShiftInvertMode.
  
--- 139,145 ----
  
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>, ARdsSymPencil<ARFLOAT> >::
      SetShiftInvertMode(sigmap, &Pencil, &ARdsSymPencil<ARFLOAT>::MultInvAsBv);
!   this->ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultBv);
  
  } // SetShiftInvertMode.
  
***************
*** 150,156 ****
  
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>, ARdsSymPencil<ARFLOAT> >::
      SetBucklingMode(sigmap, &Pencil, &ARdsSymPencil<ARFLOAT>::MultInvAsBv);
!   ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
  
  } // SetBucklingMode.
  
--- 151,157 ----
  
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>, ARdsSymPencil<ARFLOAT> >::
      SetBucklingMode(sigmap, &Pencil, &ARdsSymPencil<ARFLOAT>::MultInvAsBv);
!   this->ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
  
  } // SetBucklingMode.
  
***************
*** 163,169 ****
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>, ARdsSymPencil<ARFLOAT> >::
      SetCayleyMode(sigmap, &Pencil, &ARdsSymPencil<ARFLOAT>::MultInvAsBv,
                    &Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
!   ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultBv);
  
  } // SetCayleyMode.
  
--- 164,170 ----
    ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>, ARdsSymPencil<ARFLOAT> >::
      SetCayleyMode(sigmap, &Pencil, &ARdsSymPencil<ARFLOAT>::MultInvAsBv,
                    &Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
!   this->ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultBv);
  
  } // SetCayleyMode.
  
***************
*** 171,185 ****
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!               ARdsSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   InvertMode = 'S';
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 172,186 ----
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!               ARdsSymMatrix<ARFLOAT>& B, const std::string& whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->InvertMode = 'S';
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 191,210 ****
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
                ARdsSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   InvertMode = CheckInvertMode(InvertModep);
!   switch (InvertMode) {
    case 'B':
!     ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
    case 'S':
      ChangeShift(sigmap);
      break;
--- 192,211 ----
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,
                ARdsSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   this->InvertMode = this->CheckInvertMode(InvertModep);
!   switch (this->InvertMode) {
    case 'B':
!     this->ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
    case 'S':
      ChangeShift(sigmap);
      break;
***************
*** 221,227 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 222,228 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/ardnsmat.h arpack++new/include/ardnsmat.h
*** arpack++/include/ardnsmat.h	2000-02-21 14:58:26.000000000 -0500
--- arpack++new/include/ardnsmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARDNSMAT_H
  #define ARDNSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
--- 20,27 ----
  #ifndef ARDNSMAT_H
  #define ARDNSMAT_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
***************
*** 86,92 ****
    ARdsNonSymMatrix(int mp, int np, ARTYPE* Ap);
    // Long constructor (rectangular matrix).
  
!   ARdsNonSymMatrix(char* file, int blksizep = 0);
    // Long constructor (Matrix stored in a file).
  
    ARdsNonSymMatrix(const ARdsNonSymMatrix& other) { Copy(other); }
--- 87,93 ----
    ARdsNonSymMatrix(int mp, int np, ARTYPE* Ap);
    // Long constructor (rectangular matrix).
  
!   ARdsNonSymMatrix(const std::string& file, int blksizep = 0);
    // Long constructor (Matrix stored in a file).
  
    ARdsNonSymMatrix(const ARdsNonSymMatrix& other) { Copy(other); }
***************
*** 126,134 ****
  
    // Copying very fundamental variables and user-defined parameters.
  
!   m         = other.m;
!   n         = other.n;
!   defined   = other.defined;
    factored  = other.factored;
    info      = other.info;
    A         = other.A;
--- 127,135 ----
  
    // Copying very fundamental variables and user-defined parameters.
  
!   this->m         = other.m;
!   this->n         = other.n;
!   this->defined   = other.defined;
    factored  = other.factored;
    info      = other.info;
    A         = other.A;
***************
*** 145,155 ****
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[m*n];
!   ipiv = new int[n];
  
!   copy(m*n, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
--- 146,156 ----
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[this->m*this->n];
!   ipiv = new int[this->n];
  
!   copy(this->m*this->n, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
***************
*** 159,166 ****
  {
  
    ClearMem();
!   Ainv = new ARTYPE[m*n];
!   ipiv = new int[n];
  
  } // CreateStructure.
  
--- 160,167 ----
  {
  
    ClearMem();
!   Ainv = new ARTYPE[this->m*this->n];
!   ipiv = new int[this->n];
  
  } // CreateStructure.
  
***************
*** 187,197 ****
  
    // Quitting the function if A was not defined or is rectangular.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::FactorA");
    }
  
!   if (m!=n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARdsNonSymMatrix::FactorA");
    }
--- 188,198 ----
  
    // Quitting the function if A was not defined or is rectangular.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::FactorA");
    }
  
!   if (this->m!=this->n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARdsNonSymMatrix::FactorA");
    }
***************
*** 207,217 ****
  
    // Copying A to Ainv;
  
!   ::copy(m*n, A, 1, Ainv, 1);
  
    // Decomposing A.
  
!   getrf(m, n, Ainv, m, ipiv, info);
  
    // Handling errors.
  
--- 208,218 ----
  
    // Copying A to Ainv;
  
!   ::copy(this->m*this->n, A, 1, Ainv, 1);
  
    // Decomposing A.
  
!   getrf(this->m, this->n, Ainv, this->m, ipiv, info);
  
    // Handling errors.
  
***************
*** 228,239 ****
  
    // Quitting the function if A was not defined or is rectangular.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARdsNonSymMatrix::FactorAsI");
    }
  
!   if (m!=n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARdsNonSymMatrix::FactorAsI");
    }
--- 229,240 ----
  
    // Quitting the function if A was not defined or is rectangular.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARdsNonSymMatrix::FactorAsI");
    }
  
!   if (this->m!=this->n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARdsNonSymMatrix::FactorAsI");
    }
***************
*** 249,260 ****
  
    // Subtracting sigma*I from A.
  
!   ::copy(m*n,A,1,Ainv,1);
!   for (int i=0; i<(m*n); i+=m+1) Ainv[i]-=sigma;
  
    // Decomposing AsI.
  
!   getrf(m, n, Ainv, m, ipiv, info);
  
    // Handling errors.
  
--- 250,261 ----
  
    // Subtracting sigma*I from A.
  
!   ::copy(this->m*this->n,A,1,Ainv,1);
!   for (int i=0; i<(this->m*this->n); i+=this->m+1) Ainv[i]-=sigma;
  
    // Decomposing AsI.
  
!   getrf(this->m, this->n, Ainv, this->m, ipiv, info);
  
    // Handling errors.
  
***************
*** 279,285 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMv");
    }
  
--- 280,286 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMv");
    }
  
***************
*** 287,300 ****
  
    if (mat.IsOutOfCore()) {
  
!     if (m>n) { 
  
        // Matrix is "tall".
  
        mat.Rewind();
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("N", mat.RowsInMemory(), n, one, mat.Entries(), 
               mat.RowsInMemory(), v, 1, zero, &w[mat.FirstIndex()], 1);
        }
  
--- 288,301 ----
  
    if (mat.IsOutOfCore()) {
  
!     if (this->m>this->n) { 
  
        // Matrix is "tall".
  
        mat.Rewind();
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("N", mat.RowsInMemory(), this->n, one, mat.Entries(), 
               mat.RowsInMemory(), v, 1, zero, &w[mat.FirstIndex()], 1);
        }
  
***************
*** 305,316 ****
  
        mat.Rewind();
        t = new ARTYPE[mat.ColsInMemory()];
!       for (i=0; i<m; i++) w[i] = zero;
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("N", m, mat.ColsInMemory(), one, mat.Entries(), 
!              m, &v[mat.FirstIndex()], 1, zero, t, 1);
!         axpy(m, one, t, 1, w, 1); 
        }
        delete[] t;
  
--- 306,317 ----
  
        mat.Rewind();
        t = new ARTYPE[mat.ColsInMemory()];
!       for (i=0; i<this->m; i++) w[i] = zero;
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("N", this->m, mat.ColsInMemory(), one, mat.Entries(), 
!              this->m, &v[mat.FirstIndex()], 1, zero, t, 1);
!         axpy(this->m, one, t, 1, w, 1); 
        }
        delete[] t;
  
***************
*** 319,325 ****
    }
    else {
  
!     gemv("N", m, n, one, A, m, v, 1, zero, w, 1);
  
    }
  
--- 320,326 ----
    }
    else {
  
!     gemv("N", this->m, this->n, one, A, this->m, v, 1, zero, w, 1);
  
    }
  
***************
*** 340,346 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMtv");
    }
  
--- 341,347 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMtv");
    }
  
***************
*** 348,362 ****
  
    if (mat.IsOutOfCore()) {
  
!     if (m<=n) { 
  
        // Matrix is "fat".
  
        mat.Rewind();
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("T", m, mat.ColsInMemory(), one, mat.Entries(), 
!              m, v, 1, zero, &w[mat.FirstIndex()], 1);
        }
  
      }
--- 349,363 ----
  
    if (mat.IsOutOfCore()) {
  
!     if (this->m<=this->n) { 
  
        // Matrix is "fat".
  
        mat.Rewind();
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("T", this->m, mat.ColsInMemory(), one, mat.Entries(), 
!              this->m, v, 1, zero, &w[mat.FirstIndex()], 1);
        }
  
      }
***************
*** 366,375 ****
  
        mat.Rewind();
        t = new ARTYPE[mat.ColsInMemory()];
!       for (i=0; i<m; i++) w[i] = zero;
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("T", mat.RowsInMemory(), n, one, mat.Entries(), 
               mat.RowsInMemory(), &v[mat.FirstIndex()], 1, zero, t, 1);
          axpy(mat.RowsInMemory(), one, t, 1, w, 1); 
        }
--- 367,376 ----
  
        mat.Rewind();
        t = new ARTYPE[mat.ColsInMemory()];
!       for (i=0; i<this->m; i++) w[i] = zero;
        for (i=0; i<mat.NBlocks(); i++) {
          mat.ReadBlock();
!         gemv("T", mat.RowsInMemory(), this->n, one, mat.Entries(), 
               mat.RowsInMemory(), &v[mat.FirstIndex()], 1, zero, t, 1);
          axpy(mat.RowsInMemory(), one, t, 1, w, 1); 
        }
***************
*** 380,386 ****
    }
    else {
  
!     gemv("T", m, n, one, A, m, v, 1, zero, w, 1);
  
    }
  
--- 381,387 ----
    }
    else {
  
!     gemv("T", this->m, this->n, one, A, this->m, v, 1, zero, w, 1);
  
    }
  
***************
*** 400,421 ****
    one  = (ARTYPE)0 + 1.0;
    zero = (ARTYPE)0;
  
!   if (mat.IsOutOfCore() && (m>n)) {
  
      // Special code for "tall" matrices.
  
      t = new ARTYPE[mat.BlockSize()];
!     s = new ARTYPE[n];
  
      mat.Rewind();
!     for (i=0; i<n; i++) w[i] = zero;
      for (i=0; i<mat.NBlocks(); i++) {
        mat.ReadBlock();
!       gemv("N", mat.RowsInMemory(), n, one, mat.Entries(), 
             mat.RowsInMemory(), v, 1, zero, t, 1);
!       gemv("T", mat.RowsInMemory(), n, one, mat.Entries(), 
             mat.RowsInMemory(), t, 1, zero, s, 1);
!       axpy(n, one, s, 1, w, 1); 
  
      }
  
--- 401,422 ----
    one  = (ARTYPE)0 + 1.0;
    zero = (ARTYPE)0;
  
!   if (mat.IsOutOfCore() && (this->m>this->n)) {
  
      // Special code for "tall" matrices.
  
      t = new ARTYPE[mat.BlockSize()];
!     s = new ARTYPE[this->n];
  
      mat.Rewind();
!     for (i=0; i<this->n; i++) w[i] = zero;
      for (i=0; i<mat.NBlocks(); i++) {
        mat.ReadBlock();
!       gemv("N", mat.RowsInMemory(), this->n, one, mat.Entries(), 
             mat.RowsInMemory(), v, 1, zero, t, 1);
!       gemv("T", mat.RowsInMemory(), this->n, one, mat.Entries(), 
             mat.RowsInMemory(), t, 1, zero, s, 1);
!       axpy(this->n, one, s, 1, w, 1); 
  
      }
  
***************
*** 425,431 ****
    }
    else {
  
!     t = new ARTYPE[m];
  
      MultMv(v,t);
      MultMtv(t,w);
--- 426,432 ----
    }
    else {
  
!     t = new ARTYPE[this->m];
  
      MultMv(v,t);
      MultMtv(t,w);
***************
*** 450,471 ****
    one  = (ARTYPE)0 + 1.0;
    zero = (ARTYPE)0;
  
!   if (mat.IsOutOfCore() && (m<=n)) {
  
      // Special code for "fat" matrices.
  
      t = new ARTYPE[mat.BlockSize()];
!     s = new ARTYPE[m];
  
      mat.Rewind();
!     for (i=0; i<m; i++) w[i] = zero;
      for (i=0; i<mat.NBlocks(); i++) {
        mat.ReadBlock();
!       gemv("T", m, mat.ColsInMemory(), one, mat.Entries(), 
!            m, v, 1, zero, t, 1);
!       gemv("N", m, mat.ColsInMemory(), one, mat.Entries(), 
!            m, t, 1, zero, s, 1);
!       axpy(m, one, s, 1, w, 1); 
  
      }
  
--- 451,472 ----
    one  = (ARTYPE)0 + 1.0;
    zero = (ARTYPE)0;
  
!   if (mat.IsOutOfCore() && (this->m<=this->n)) {
  
      // Special code for "fat" matrices.
  
      t = new ARTYPE[mat.BlockSize()];
!     s = new ARTYPE[this->m];
  
      mat.Rewind();
!     for (i=0; i<this->m; i++) w[i] = zero;
      for (i=0; i<mat.NBlocks(); i++) {
        mat.ReadBlock();
!       gemv("T", this->m, mat.ColsInMemory(), one, mat.Entries(), 
!            this->m, v, 1, zero, t, 1);
!       gemv("N", this->m, mat.ColsInMemory(), one, mat.Entries(), 
!            this->m, t, 1, zero, s, 1);
!       axpy(this->m, one, s, 1, w, 1); 
  
      }
  
***************
*** 475,481 ****
    }
    else {
  
!     t = new ARTYPE[n];
  
      MultMtv(v,t);
      MultMv(t,w);
--- 476,482 ----
    }
    else {
  
!     t = new ARTYPE[this->n];
  
      MultMtv(v,t);
      MultMv(t,w);
***************
*** 491,498 ****
  void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[m],w);
!   MultMtv(v,&w[m]);
  
  } // Mult0MMt0v.
  
--- 492,499 ----
  void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[this->m],w);
!   MultMtv(v,&w[this->m]);
  
  } // Mult0MMt0v.
  
***************
*** 510,520 ****
  
    // Overwritting w with v.
  
!   copy(n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   getrs("N", n, 1, Ainv, m, ipiv, w, m, info);
  
    // Handling errors.
  
--- 511,521 ----
  
    // Overwritting w with v.
  
!   copy(this->n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   getrs("N", this->n, 1, Ainv, this->m, ipiv, w, this->m, info);
  
    // Handling errors.
  
***************
*** 530,539 ****
  
    // Defining member variables.
  
!   n         = np;
!   m         = np;
    A         = Ap;
!   defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
--- 531,540 ----
  
    // Defining member variables.
  
!   this->n         = np;
!   this->m         = np;
    A         = Ap;
!   this->defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
***************
*** 548,557 ****
  
    // Defining member variables.
  
!   m         = mp;
!   n         = np;
    A         = Ap;
!   defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0;
--- 549,558 ----
  
    // Defining member variables.
  
!   this->m         = mp;
!   this->n         = np;
    A         = Ap;
!   this->defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0;
***************
*** 582,588 ****
  
  
  template<class ARTYPE, class ARFLOAT>
! ARdsNonSymMatrix<ARTYPE, ARFLOAT>::ARdsNonSymMatrix(char* file, int blksizep)
  {
  
    factored = false;
--- 583,589 ----
  
  
  template<class ARTYPE, class ARFLOAT>
! ARdsNonSymMatrix<ARTYPE, ARFLOAT>::ARdsNonSymMatrix(const std::string& file, int blksizep)
  {
  
    factored = false;
diff -crB arpack++/include/ardscomp.h arpack++new/include/ardscomp.h
*** arpack++/include/ardscomp.h	2000-02-20 18:22:42.000000000 -0500
--- arpack++new/include/ardscomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARDSCOMP_H
  #define ARDSCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arscomp.h"
  #include "ardnsmat.h"
--- 18,25 ----
  #ifndef ARDSCOMP_H
  #define ARDSCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arscomp.h"
  #include "ardnsmat.h"
***************
*** 48,60 ****
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 49,61 ----
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 84,90 ****
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   objOP->FactorAsI(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
--- 85,91 ----
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   this->objOP->FactorAsI(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
***************
*** 96,102 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetRegularMode(objOP, 
                     &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
--- 97,103 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetRegularMode(this->objOP, 
                     &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
***************
*** 109,115 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP,
                         &ARdsNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 110,116 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP,
                         &ARdsNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 118,130 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                char* whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A,
                     &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 119,131 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                const std::string& whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A,
                     &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 134,146 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, 
                     &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
--- 135,147 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, 
                     &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
***************
*** 154,160 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 155,161 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/ardsmat.h arpack++new/include/ardsmat.h
*** arpack++/include/ardsmat.h	2000-02-20 17:56:02.000000000 -0500
--- arpack++new/include/ardsmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARDSMAT_H
  #define ARDSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
--- 20,27 ----
  #ifndef ARDSMAT_H
  #define ARDSMAT_H
  
! #include <cstddef>
! 
  #include "arch.h"
  #include "armat.h"
  #include "arerror.h"
***************
*** 110,118 ****
  
    // Copying very fundamental variables and user-defined parameters.
  
!   m         = other.m;
!   n         = other.n;
!   defined   = other.defined;
    factored  = other.factored;
    uplo      = other.uplo;
    info      = other.info;
--- 111,119 ----
  
    // Copying very fundamental variables and user-defined parameters.
  
!   this->m         = other.m;
!   this->n         = other.n;
!   this->defined   = other.defined;
    factored  = other.factored;
    uplo      = other.uplo;
    info      = other.info;
***************
*** 124,134 ****
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[(n*n+n)/2];
!   ipiv = new int[n];
  
!   copy((n*n+n)/2, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
--- 125,135 ----
  
    // Copying vectors.
  
!   Ainv = new ARTYPE[(this->n*this->n+this->n)/2];
!   ipiv = new int[this->n];
  
!   copy((this->n*this->n+this->n)/2, other.Ainv, 1, Ainv, 1);
!   for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
  
  } // Copy.
  
***************
*** 141,155 ****
  
    // Copying A to Ainv.
  
!   ::copy((n*n+n)/2 ,A, 1, Ainv, 1);
  
    // Subtracting sigma from diagonal elements.
  
    if (uplo=='L') {
!     for (i=0, j=0; i<n; j+=(n-(i++))) Ainv[j] -= sigma;
    }
    else {
!     for (i=0, j=0; i<n; j+=(++i)) Ainv[j] -= sigma;
    }
  
  } // SubtractAsI.
--- 142,156 ----
  
    // Copying A to Ainv.
  
!   ::copy((this->n*this->n+this->n)/2 ,A, 1, Ainv, 1);
  
    // Subtracting sigma from diagonal elements.
  
    if (uplo=='L') {
!     for (i=0, j=0; i<this->n; j+=(this->n-(i++))) Ainv[j] -= sigma;
    }
    else {
!     for (i=0, j=0; i<this->n; j+=(++i)) Ainv[j] -= sigma;
    }
  
  } // SubtractAsI.
***************
*** 160,167 ****
  {
  
    ClearMem();
!   Ainv = new ARTYPE[(n*n+n)/2];
!   ipiv = new int[n];
  
  } // CreateStructure.
  
--- 161,168 ----
  {
  
    ClearMem();
!   Ainv = new ARTYPE[(this->n*this->n+this->n)/2];
!   ipiv = new int[this->n];
  
  } // CreateStructure.
  
***************
*** 188,194 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorA");
    }
  
--- 189,195 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorA");
    }
  
***************
*** 198,208 ****
  
    // Copying A to Ainv;
  
!   ::copy((n*n+n)/2 ,A, 1, Ainv, 1);
  
    // Decomposing A.
  
!   sptrf(&uplo, n, Ainv, ipiv, info);
  
    // Handling errors.
  
--- 199,209 ----
  
    // Copying A to Ainv;
  
!   ::copy((this->n*this->n+this->n)/2 ,A, 1, Ainv, 1);
  
    // Decomposing A.
  
!   sptrf(&uplo, this->n, Ainv, ipiv, info);
  
    // Handling errors.
  
***************
*** 219,225 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorAsI");
    }
  
--- 220,226 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorAsI");
    }
  
***************
*** 233,239 ****
  
    // Decomposing AsI.
  
!   sptrf(&uplo, n, Ainv, ipiv, info);
  
    // Handling errors.
  
--- 234,240 ----
  
    // Decomposing AsI.
  
!   sptrf(&uplo, this->n, Ainv, ipiv, info);
  
    // Handling errors.
  
***************
*** 254,279 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::MultMv");
    }
  
    // Determining w = M.v (unfortunately, the BLAS does not 
    // have a routine that works with packed matrices).
  
!   for (i=0; i<n; i++) w[i] = zero;
  
    if (uplo=='L') {
   
!     for (i=0, j=0; i<n; j+=(n-(i++))) {
!       w[i] += dot(n-i, &A[j], 1, &v[i], 1);
!       axpy(n-i-1, v[i], &A[j+1], 1, &w[i+1], 1);
      }
   
    }  
    else { // uplo = 'U'
  
!     for (i=0, j=0; i<n; j+=(++i)) {
        w[i] += dot(i+1, &A[j], 1, v, 1);
        axpy(i, v[i], &A[j], 1, w, 1);
      }
--- 255,280 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::MultMv");
    }
  
    // Determining w = M.v (unfortunately, the BLAS does not 
    // have a routine that works with packed matrices).
  
!   for (i=0; i<this->n; i++) w[i] = zero;
  
    if (uplo=='L') {
   
!     for (i=0, j=0; i<this->n; j+=(this->n-(i++))) {
!       w[i] += dot(this->n-i, &A[j], 1, &v[i], 1);
!       axpy(this->n-i-1, v[i], &A[j+1], 1, &w[i+1], 1);
      }
   
    }  
    else { // uplo = 'U'
  
!     for (i=0, j=0; i<this->n; j+=(++i)) {
        w[i] += dot(i+1, &A[j], 1, v, 1);
        axpy(i, v[i], &A[j], 1, w, 1);
      }
***************
*** 296,306 ****
  
    // Overwritting w with v.
  
!   copy(n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   sptrs(&uplo, n, 1, Ainv, ipiv, w, n, info);
  
    // Handling errors.
  
--- 297,307 ----
  
    // Overwritting w with v.
  
!   copy(this->n, v, 1, w, 1);
  
    // Solving A.w = v (or AsI.w = v).
  
!   sptrs(&uplo, this->n, 1, Ainv, ipiv, w, this->n, info);
  
    // Handling errors.
  
***************
*** 316,326 ****
  
    // Defining member variables.
  
!   m         = np;
!   n         = np;
    uplo      = uplop;
    A         = Ap;
!   defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
--- 317,327 ----
  
    // Defining member variables.
  
!   this->m         = np;
!   this->n         = np;
    uplo      = uplop;
    A         = Ap;
!   this->defined   = true;
    Ainv      = NULL;
    ipiv      = NULL;
    info      = 0; 
***************
*** 345,351 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 346,352 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/ardsnsym.h arpack++new/include/ardsnsym.h
*** arpack++/include/ardsnsym.h	2000-02-20 18:14:18.000000000 -0500
--- arpack++new/include/ardsnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARDSNSYM_H
  #define ARDSNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arsnsym.h"
  #include "ardnsmat.h"
--- 18,25 ----
  #ifndef ARDSNSYM_H
  #define ARDSNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arsnsym.h"
  #include "ardnsmat.h"
***************
*** 46,58 ****
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 47,59 ----
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 81,93 ****
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 82,94 ----
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = 0.0;
!   this->mode      = 3;
!   this->iparam[7] = this->mode;
  
!   this->objOP->FactorAsI(this->sigmaR);
!   this->Restart();
  
  } // ChangeShift.
  
***************
*** 97,103 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode(objOP, &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 98,104 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode(this->objOP, &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 107,113 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, 
                         &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 108,114 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP, 
                         &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 116,128 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A, 
                     &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 117,129 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A, 
                     &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 132,143 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, 
                     &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
--- 133,144 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, 
                     &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
***************
*** 151,157 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 152,158 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/ardssym.h arpack++new/include/ardssym.h
*** arpack++/include/ardssym.h	2000-02-20 18:09:40.000000000 -0500
--- arpack++new/include/ardssym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARDSSYM_H
  #define ARDSSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arssym.h"
  #include "ardsmat.h"
--- 18,25 ----
  #ifndef ARDSSYM_H
  #define ARDSSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arssym.h"
  #include "ardsmat.h"
***************
*** 46,58 ****
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 47,59 ----
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 81,93 ****
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 82,94 ----
  ChangeShift(ARFLOAT sigmaRp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = 0.0;
!   this->mode      = 3;
!   this->iparam[7] = this->mode;
  
!   this->objOP->FactorAsI(this->sigmaR);
!   this->Restart();
  
  } // ChangeShift.
  
***************
*** 97,103 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
!     SetRegularMode(objOP, &ARdsSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 98,104 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
!     SetRegularMode(this->objOP, &ARdsSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 107,113 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, &ARdsSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
--- 108,114 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP, &ARdsSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
***************
*** 115,126 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
--- 116,127 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
***************
*** 129,140 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
--- 130,141 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
***************
*** 147,153 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 148,154 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arerror.h arpack++new/include/arerror.h
*** arpack++/include/arerror.h	2000-03-01 13:59:37.000000000 -0500
--- arpack++new/include/arerror.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 29,37 ****
  #ifndef ARERROR_H
  #define ARERROR_H
  
  #include "arch.h"
- #include <iostream.h>
- #include <stdlib.h>
  
  class ArpackError {
  
--- 29,39 ----
  #ifndef ARERROR_H
  #define ARERROR_H
  
+ #include <iostream>
+ #include <cstdlib>
+ #include <string>
+ 
  #include "arch.h"
  
  class ArpackError {
  
***************
*** 126,143 ****
  
    static ErrorCode code;
  
!   static void Print(const char* where, const char* message);
    // Writes error messages on cerr stream.
  
   public:
  
!   static void Set(ErrorCode error, char* where="AREigenProblem");
    // Set error code and write error messages.
  
    static int Status() { return (int) code; }
    // Returns current value of error code.
  
!   ArpackError(ErrorCode error, char* where="AREigenProblem") {
      Set(error,where);
    }
    // Constructor that set error code.
--- 128,145 ----
  
    static ErrorCode code;
  
!   static void Print(const std::string& where, const std::string& message);
    // Writes error messages on cerr stream.
  
   public:
  
!   static void Set(ErrorCode error, const std::string& where="AREigenProblem");
    // Set error code and write error messages.
  
    static int Status() { return (int) code; }
    // Returns current value of error code.
  
!   ArpackError(ErrorCode error, const std::string& where="AREigenProblem") {
      Set(error,where);
    }
    // Constructor that set error code.
***************
*** 147,163 ****
  
  };
  
! inline void ArpackError::Print(const char* where, const char* message)
  {
  
  #ifndef ARPACK_SILENT_MODE
!   cerr << "Arpack error in " << where << "." << endl;
!   cerr << "-> " << message << "." << endl;
  #endif
  
  } // Print
  
! void ArpackError::Set(ErrorCode error, char* where)
  {
  
    code = error;
--- 149,165 ----
  
  };
  
! inline void ArpackError::Print(const std::string& where, const std::string& message)
  {
  
  #ifndef ARPACK_SILENT_MODE
!   std::cerr << "Arpack error in " << where << "." << std::endl;
!   std::cerr << "-> " << message << "." << std::endl;
  #endif
  
  } // Print
  
! void ArpackError::Set(ErrorCode error, const std::string& where)
  {
  
    code = error;
diff -crB arpack++/include/argcomp.h arpack++new/include/argcomp.h
*** arpack++/include/argcomp.h	2000-02-20 18:49:24.000000000 -0500
--- arpack++new/include/argcomp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARGCOMP_H
  #define ARGCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arscomp.h"
  #include "argeig.h"
--- 17,24 ----
  #ifndef ARGCOMP_H
  #define ARGCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arscomp.h"
  #include "argeig.h"
***************
*** 38,44 ****
                 void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
                 ARFB* objBp,
                 void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!                char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
--- 39,45 ----
                 void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
                 ARFB* objBp,
                 void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!                const std::string& whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
***************
*** 48,54 ****
                 ARFB* objBp,
                 void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
                 arcomplex<ARFLOAT> sigmap,
!                char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                 int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                 bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 49,55 ----
                 ARFB* objBp,
                 void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
                 arcomplex<ARFLOAT> sigmap,
!                const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                 int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                 bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 78,89 ****
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
               ARFB* objBp,
               void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[], arcomplex<ARFLOAT>[]),
!              char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 79,90 ----
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
               ARFB* objBp,
               void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[], arcomplex<ARFLOAT>[]),
!              const std::string& whichp, int ncvp, ARFLOAT tolp,
               int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 96,102 ****
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
               ARFB* objBp,
               void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[], arcomplex<ARFLOAT>[]),
!              arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp, ARFLOAT tolp,
               int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
--- 97,103 ----
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
               ARFB* objBp,
               void (ARFB::* MultBxp)(arcomplex<ARFLOAT>[], arcomplex<ARFLOAT>[]),
!              arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
               int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
***************
*** 114,120 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 115,121 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/argeig.h arpack++new/include/argeig.h
*** arpack++/include/argeig.h	2000-02-20 18:39:06.000000000 -0500
--- arpack++new/include/argeig.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  #ifndef ARGEIG_H
  #define ARGEIG_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "arrgeig.h"
--- 19,26 ----
  #ifndef ARGEIG_H
  #define ARGEIG_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arerror.h"
  #include "arrgeig.h"
***************
*** 63,69 ****
  
    virtual void DefineParameters(int np, int nevp, ARFOP* objOPp,
                                  TypeOPx MultOPxp, ARFB* objBp, 
!                                 TypeBx MultBxp, char* whichp="LM", 
                                  int ncvp=0, ARFLOAT tolp=0.0,
                                  int maxitp=0, ARTYPE* residp=NULL,
                                  bool ishiftp=true);
--- 64,70 ----
  
    virtual void DefineParameters(int np, int nevp, ARFOP* objOPp,
                                  TypeOPx MultOPxp, ARFB* objBp, 
!                                 TypeBx MultBxp, const std::string& whichp="LM", 
                                  int ncvp=0, ARFLOAT tolp=0.0,
                                  int maxitp=0, ARTYPE* residp=NULL,
                                  bool ishiftp=true);
***************
*** 122,128 ****
  void ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::
  DefineParameters(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]), ARFB* objBp,
!                  void (ARFB::* MultBxp)(ARTYPE[], ARTYPE[]), char* whichp,
                   int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp, 
                   bool ishiftp)
  
--- 123,129 ----
  void ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::
  DefineParameters(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]), ARFB* objBp,
!                  void (ARFB::* MultBxp)(ARTYPE[], ARTYPE[]), const std::string& whichp,
                   int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp, 
                   bool ishiftp)
  
***************
*** 149,155 ****
  
    objB   = objBp;
    MultBx = MultBxp;
!   Restart();
  
  } // ChangeMultBx.
  
--- 150,156 ----
  
    objB   = objBp;
    MultBx = MultBxp;
!   this->Restart();
  
  } // ChangeMultBx.
  
***************
*** 158,203 ****
  int ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::FindArnoldiBasis()
  {
  
!   if (!BasisOK) Restart();
  
    // Changing to auto shift mode.
  
!   if (!AutoShift) {
      ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
!     AutoShift=true;
    }
  
    // ARPACK main loop.
  
!   while (!BasisOK) {
  
      // Calling Aupp.
  
!     try { TakeStep(); }
      catch (ArpackError) {
        ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
        return 0;
      }
  
!     switch (ido) {
      case -1:
  
        // Performing y <- OP*B*x for the first time when mode != 2.
  
!       if (mode != 2) {
!         ipntr[3] = ipntr[2]+n; // not a clever idea, but...
!         (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[3]]);
        }
  
      case  1:
  
        // Performing y <- OP*w.
  
!       if (mode == 2) { // w = x if mode = 2.
!         (objOP->*MultOPx)(&workd[ipntr[1]],&workd[ipntr[2]]);
        }
        else {           // w = B*x otherwise.
!         (objOP->*MultOPx)(&workd[ipntr[3]],&workd[ipntr[2]]);
        }
        break;
  
--- 159,204 ----
  int ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::FindArnoldiBasis()
  {
  
!   if (!this->BasisOK) this->Restart();
  
    // Changing to auto shift mode.
  
!   if (!this->AutoShift) {
      ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
!     this->AutoShift=true;
    }
  
    // ARPACK main loop.
  
!   while (!this->BasisOK) {
  
      // Calling Aupp.
  
!     try { this->TakeStep(); }
      catch (ArpackError) {
        ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
        return 0;
      }
  
!     switch (this->ido) {
      case -1:
  
        // Performing y <- OP*B*x for the first time when mode != 2.
  
!       if (this->mode != 2) {
!         this->ipntr[3] = this->ipntr[2]+this->n; // not a clever idea, but...
!         (this->objB->*MultBx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[3]]);
        }
  
      case  1:
  
        // Performing y <- OP*w.
  
!       if (this->mode == 2) { // w = x if mode = 2.
!         (this->objOP->*(this->MultOPx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
        }
        else {           // w = B*x otherwise.
!         (this->objOP->*(this->MultOPx))(&this->workd[this->ipntr[3]],&this->workd[this->ipntr[2]]);
        }
        break;
  
***************
*** 205,215 ****
  
        // Performing y <- B*x.
  
!       (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[2]]);
  
      }
    }
!   return nconv;
  
  } // FindArnoldiBasis.
  
--- 206,216 ----
  
        // Performing y <- B*x.
  
!       (this->objB->*MultBx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
  
      }
    }
!   return this->nconv;
  
  } // FindArnoldiBasis.
  
***************
*** 220,226 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 221,227 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/argnsym.h arpack++new/include/argnsym.h
*** arpack++/include/argnsym.h	2000-02-21 13:21:34.000000000 -0500
--- arpack++new/include/argnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARGNSYM_H
  #define ARGNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "blas1c.h"
  #include "lapackc.h"
--- 17,24 ----
  #ifndef ARGNSYM_H
  #define ARGNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "blas1c.h"
  #include "lapackc.h"
***************
*** 94,113 ****
  
   // d.3) Constructors and destructor.
  
!   ARNonSymGenEig() { part = 'R'; }
    // Short constructor (Does nothing but calling base classes constructors).
  
    ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                   ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                  char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                   ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                  ARFLOAT sigmap, char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (real shift and invert mode).
--- 95,114 ----
  
   // d.3) Constructors and destructor.
  
!   ARNonSymGenEig() { this->part = 'R'; }
    // Short constructor (Does nothing but calling base classes constructors).
  
    ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                   ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                  const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                   ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                  ARFLOAT sigmap, const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (real shift and invert mode).
***************
*** 116,122 ****
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp,
                   void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
                   void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]), char partp,
!                  ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
--- 117,123 ----
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp,
                   void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
                   void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]), char partp,
!                  ARFLOAT sigmaRp, ARFLOAT sigmaIp, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
***************
*** 148,154 ****
    ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
    objA   = other.objA;
    MultAx = other.MultAx;
!   part   = other.part;
  
  } // Copy.
  
--- 149,155 ----
    ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
    objA   = other.objA;
    MultAx = other.MultAx;
!   this->part   = other.part;
  
  } // Copy.
  
***************
*** 161,182 ****
    ARFLOAT  numr, numi, denr, deni;
    ARFLOAT* Ax;
  
!   Ax = new ARFLOAT[n];
  
!   for (j=0; j<nconv; j++) {
  
!     ColJ   = j*n;
!     ColJp1 = ColJ+n;
  
!     if (EigValI[j] == (ARFLOAT)0.0) {
  
        // Eigenvalue is real. Computing EigVal = x'(Ax)/x'(Mx).
  
!       (objB->*MultAx)(&EigVec[ColJ], Ax);
!       numr = dot(n, &EigVec[ColJ], 1, Ax, 1);
!       (objB->*MultBx)(&EigVec[ColJ], Ax);
!       denr = dot(n, &EigVec[ColJ], 1, Ax, 1);
!       EigValR[j] =  numr / denr;
  
      }
      else {
--- 162,183 ----
    ARFLOAT  numr, numi, denr, deni;
    ARFLOAT* Ax;
  
!   Ax = new ARFLOAT[this->n];
  
!   for (j=0; j<this->nconv; j++) {
  
!     ColJ   = j*this->n;
!     ColJp1 = ColJ+this->n;
  
!     if (this->EigValI[j] == (ARFLOAT)0.0) {
  
        // Eigenvalue is real. Computing EigVal = x'(Ax)/x'(Mx).
  
!       (this->objB->*MultAx)(&this->EigVec[ColJ], Ax);
!       numr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
!       (this->objB->*(this->MultBx))(&this->EigVec[ColJ], Ax);
!       denr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
!       this->EigValR[j] =  numr / denr;
  
      }
      else {
***************
*** 185,216 ****
  
        // Computing x'(Ax).
  
!       (objB->*MultAx)(&EigVec[ColJ], Ax);
!       numr = dot(n, &EigVec[ColJ], 1, Ax, 1);
!       numi = dot(n, &EigVec[ColJp1], 1, Ax, 1);
!       (objB->*MultAx)(&EigVec[ColJp1], Ax);
!       numr = numr + dot(n, &EigVec[ColJp1], 1, Ax, 1);
!       numi = -numi + dot(n, &EigVec[ColJ], 1, Ax, 1);
  
        // Computing x'(Mx).
  
!       (objB->*MultBx)(&EigVec[ColJ], Ax);
!       denr = dot(n, &EigVec[ColJ], 1, Ax, 1);
!       deni = dot(n, &EigVec[ColJp1], 1, Ax, 1);
!       (objB->*MultBx)(&EigVec[ColJp1], Ax);
!       denr = denr + dot(n, &EigVec[ColJp1], 1, Ax, 1);
!       deni = -deni + dot(n, &EigVec[ColJ], 1, Ax, 1);
  
        // Computing the first eigenvalue of the conjugate pair.
  
!       EigValR[j] = (numr*denr+numi*deni) / lapy2(denr, deni);
!       EigValI[j] = (numi*denr-numr*deni) / lapy2(denr, deni);
  
        // Getting the second eigenvalue of the conjugate pair by taking
        // the conjugate of the first.
  
!       EigValR[j+1] = EigValR[j];
!       EigValI[j+1] = -EigValI[j];
        j++;
  
      }
--- 186,217 ----
  
        // Computing x'(Ax).
  
!       (this->objB->*MultAx)(&this->EigVec[ColJ], Ax);
!       numr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
!       numi = dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
!       (this->objB->*MultAx)(&this->EigVec[ColJp1], Ax);
!       numr = numr + dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
!       numi = -numi + dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
  
        // Computing x'(Mx).
  
!       (this->objB->*(this->MultBx))(&this->EigVec[ColJ], Ax);
!       denr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
!       deni = dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
!       (this->objB->*(this->MultBx))(&this->EigVec[ColJp1], Ax);
!       denr = denr + dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
!       deni = -deni + dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
  
        // Computing the first eigenvalue of the conjugate pair.
  
!       this->EigValR[j] = (numr*denr+numi*deni) / lapy2(denr, deni);
!       this->EigValI[j] = (numi*denr-numr*deni) / lapy2(denr, deni);
  
        // Getting the second eigenvalue of the conjugate pair by taking
        // the conjugate of the first.
  
!       this->EigValR[j+1] = this->EigValR[j];
!       this->EigValI[j+1] = -this->EigValI[j];
        j++;
  
      }
***************
*** 228,237 ****
                     void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
  {
  
!   part    = 'R';
!   objOP   = objOPp;
!   MultOPx = MultOPxp;
!   ChangeShift(sigmaRp);
  
  } // SetShiftInvertMode.
  
--- 229,238 ----
                     void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
  {
  
!   this->part    = 'R';
!   this->objOP   = objOPp;
!   this->MultOPx = MultOPxp;
!   this->ChangeShift(sigmaRp);
  
  } // SetShiftInvertMode.
  
***************
*** 244,255 ****
                      ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]))
  {
  
!   objOP   = objOPp;
!   MultOPx = MultOPxp;
    objA    = objAp;
    MultAx  = MultAxp;
!   part    = CheckPart(partp);
!   ChangeShift(sigmaRp, sigmaIp);
  
  } // SetComplexShiftMode.
  
--- 245,256 ----
                      ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]))
  {
  
!   this->objOP   = objOPp;
!   this->MultOPx = MultOPxp;
    objA    = objAp;
    MultAx  = MultAxp;
!   this->part    = this->CheckPart(partp);
!   this->ChangeShift(sigmaRp, sigmaIp);
  
  } // SetComplexShiftMode.
  
***************
*** 258,266 ****
  inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvalues()
  {
  
!   nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvalues();
!   if (sigmaI != 0.0) RecoverEigenvalues();
!   return nconv;
  
  } // FindEigenvalues.
  
--- 259,267 ----
  inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvalues()
  {
  
!   this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvalues();
!   if (this->sigmaI != 0.0) RecoverEigenvalues();
!   return this->nconv;
  
  } // FindEigenvalues.
  
***************
*** 269,277 ****
  inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvectors(bool schurp)
  {
  
!   nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvectors(schurp);
!   if (sigmaI != 0.0) RecoverEigenvalues();
!   return nconv;
  
  } // FindEigenvectors.
  
--- 270,278 ----
  inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvectors(bool schurp)
  {
  
!   this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvectors(schurp);
!   if (this->sigmaI != 0.0) RecoverEigenvalues();
!   return this->nconv;
  
  } // FindEigenvectors.
  
***************
*** 280,288 ****
  int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindSchurVectors()
  {
  
!   nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindSchurVectors();
!   if (sigmaI != 0.0) RecoverEigenvalues();
!   return nconv;
  
  } // FindSchurVectors.
  
--- 281,289 ----
  int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindSchurVectors()
  {
  
!   this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindSchurVectors();
!   if (this->sigmaI != 0.0) RecoverEigenvalues();
!   return this->nconv;
  
  } // FindSchurVectors.
  
***************
*** 292,304 ****
  ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                 ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 ARFLOAT* residp, bool ishiftp)
  
  {
  
!   part = 'R';                // Considering mode = 3 in ChangeShift.
!   NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 293,305 ----
  ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                 ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                const std::string& whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->part = 'R';                // Considering mode = 3 in ChangeShift.
!   this->NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 310,316 ****
  ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                 ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                ARFLOAT sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
--- 311,317 ----
  ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                 ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!                ARFLOAT sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 330,336 ****
                 ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]),
                 ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
                 char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp,
!                char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 ARFLOAT* residp, bool ishiftp)
  
  {
--- 331,337 ----
                 ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]),
                 ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
                 char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp,
!                const std::string& whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 349,355 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 350,356 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/argsym.h arpack++new/include/argsym.h
*** arpack++/include/argsym.h	2000-02-21 13:22:35.000000000 -0500
--- arpack++new/include/argsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARGSYM_H
  #define ARGSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arssym.h"
  #include "arrgsym.h"
--- 17,24 ----
  #ifndef ARGSYM_H
  #define ARGSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arssym.h"
  #include "arrgsym.h"
***************
*** 79,98 ****
  
   // d.3) Constructors and destructor.
  
!   ARSymGenEig() { InvertMode = 'S'; }
    // Short constructor that does almost nothing.
  
    ARSymGenEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
                void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!               char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARSymGenEig(char invertmodep, int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!               ARFLOAT sigmap, char* whichp = "LM", int ncvp = 0,
                ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                bool ishiftp = true);
    // Long constructor (shift-and-invert and buckling mode).
--- 80,99 ----
  
   // d.3) Constructors and destructor.
  
!   ARSymGenEig() { this->InvertMode = 'S'; }
    // Short constructor that does almost nothing.
  
    ARSymGenEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
                void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!               const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARSymGenEig(char invertmodep, int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
                ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!               ARFLOAT sigmap, const std::string& whichp = "LM", int ncvp = 0,
                ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                bool ishiftp = true);
    // Long constructor (shift-and-invert and buckling mode).
***************
*** 101,107 ****
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp,
                void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
                void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]), ARFLOAT sigmap,
!               char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (cayley mode).
  
--- 102,108 ----
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]), ARFB* objAp,
                void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]), ARFB* objBp,
                void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]), ARFLOAT sigmap,
!               const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (cayley mode).
  
***************
*** 132,138 ****
    ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
    objA       = other.objA;
    MultAx     = other.MultAx;
!   InvertMode = other.InvertMode;
  
  } // Copy.
  
--- 133,139 ----
    ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
    objA       = other.objA;
    MultAx     = other.MultAx;
!   this->InvertMode = other.InvertMode;
  
  } // Copy.
  
***************
*** 143,152 ****
                     void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
  {
  
!   InvertMode = 'S';
!   objOP      = objOPp;
!   MultOPx    = MultOPxp;
!   ChangeShift(sigmap);
  
  } // SetShiftInvertMode.
  
--- 144,153 ----
                     void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
  {
  
!   this->InvertMode = 'S';
!   this->objOP      = objOPp;
!   this->MultOPx    = MultOPxp;
!   this->ChangeShift(sigmap);
  
  } // SetShiftInvertMode.
  
***************
*** 158,167 ****
  
  {
  
!   InvertMode = 'B';
!   objOP      = objOPp;
!   MultOPx    = MultOPxp;
!   ChangeShift(sigmap);
  
  } // SetBucklingMode.
  
--- 159,168 ----
  
  {
  
!   this->InvertMode = 'B';
!   this->objOP      = objOPp;
!   this->MultOPx    = MultOPxp;
!   this->ChangeShift(sigmap);
  
  } // SetBucklingMode.
  
***************
*** 174,185 ****
  
  {
  
!   InvertMode = 'C';
!   objOP      = objOPp;
!   MultOPx    = MultOPxp;
    objA       = objAp;
    MultAx     = MultAxp;
!   ChangeShift(sigmap);
  
  } // SetCayleyMode.
  
--- 175,186 ----
  
  {
  
!   this->InvertMode = 'C';
!   this->objOP      = objOPp;
!   this->MultOPx    = MultOPxp;
    objA       = objAp;
    MultAx     = MultAxp;
!   this->ChangeShift(sigmap);
  
  } // SetCayleyMode.
  
***************
*** 190,253 ****
  
    ARFLOAT* temp;
  
!   if (mode != 5) {  // Using base function if not in Cayley mode.
      return ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::FindArnoldiBasis();
    }
    else {
  
!     temp = new ARFLOAT[n+1];
  
!     if (!BasisOK) Restart();
  
      // Changing to auto shift mode.
  
!     if (!AutoShift) {
        ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
!       AutoShift=true;
      }
  
      // ARPACK main loop.
  
!     while (!BasisOK) {
  
        // Calling Aupp.
  
!       try { TakeStep(); }
        catch (ArpackError) {
          ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
          delete[] temp;
          return 0;
        }
  
!       switch (ido) {
        case -1:
  
          // Performing y <- B*x for the first time.
  
!         ipntr[3] = ipntr[2]+n; // not a clever idea, but...
!         (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[3]]);
  
        case  1:
  
          // Performing y <- OP*(A+sigma*B)*x, B*x is already available.
  
!         (objB->*MultAx)(&workd[ipntr[1]], temp);
!         axpy(n, sigmaR, &workd[ipntr[3]], 1, temp, 1);
!         (objOP->*MultOPx)(temp, &workd[ipntr[2]]);
          break;
  
        case  2:
  
          // Performing y <- B*x.
  
!         (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[2]]);
  
        }
      }
  
      delete[] temp;
     
!     return nconv;
    }
  
  } // FindArnoldiBasis.
--- 191,254 ----
  
    ARFLOAT* temp;
  
!   if (this->mode != 5) {  // Using base function if not in Cayley mode.
      return ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::FindArnoldiBasis();
    }
    else {
  
!     temp = new ARFLOAT[this->n+1];
  
!     if (!this->BasisOK) this->Restart();
  
      // Changing to auto shift mode.
  
!     if (!this->AutoShift) {
        ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
!       this->AutoShift=true;
      }
  
      // ARPACK main loop.
  
!     while (!this->BasisOK) {
  
        // Calling Aupp.
  
!       try { this->TakeStep(); }
        catch (ArpackError) {
          ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
          delete[] temp;
          return 0;
        }
  
!       switch (this->ido) {
        case -1:
  
          // Performing y <- B*x for the first time.
  
!         this->ipntr[3] = this->ipntr[2]+this->n; // not a clever idea, but...
!         (this->objB->*(this->MultBx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[3]]);
  
        case  1:
  
          // Performing y <- OP*(A+sigma*B)*x, B*x is already available.
  
!         (this->objB->*MultAx)(&this->workd[this->ipntr[1]], temp);
!         axpy(this->n, this->sigmaR, &this->workd[this->ipntr[3]], 1, temp, 1);
!         (this->objOP->*(this->MultOPx))(temp, &this->workd[this->ipntr[2]]);
          break;
  
        case  2:
  
          // Performing y <- B*x.
  
!         (this->objB->*(this->MultBx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
  
        }
      }
  
      delete[] temp;
     
!     return this->nconv;
    }
  
  } // FindArnoldiBasis.
***************
*** 258,270 ****
  ARSymGenEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!             char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
              ARFLOAT* residp, bool ishiftp)
  
  {
  
!   InvertMode = 'S';   
!   NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 259,271 ----
  ARSymGenEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!             const std::string& whichp, int ncvp, ARFLOAT tolp, int maxitp,
              ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->InvertMode = 'S';   
!   this->NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 276,287 ****
  ARSymGenEig(char InvertModep, int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!             ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   InvertMode = CheckInvertMode(InvertModep); // InvertMode = 'S' or 'B'.
    ChangeShift(sigmap);
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
--- 277,288 ----
  ARSymGenEig(char InvertModep, int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!             ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->InvertMode = this->CheckInvertMode(InvertModep); // InvertMode = 'S' or 'B'.
    ChangeShift(sigmap);
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 295,306 ****
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!             ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   SetCayleyMode(sigmap, objOPp, MultOPx, objAp, MultAxp);
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 296,307 ----
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]),
              ARFB* objBp, void (ARFB::* MultBxp)(ARFLOAT[], ARFLOAT[]),
!             ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   SetCayleyMode(sigmap, objOPp, this->MultOPx, objAp, MultAxp);
    DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 313,319 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 314,320 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arhbmat.h arpack++new/include/arhbmat.h
*** arpack++/include/arhbmat.h	2000-02-21 13:37:14.000000000 -0500
--- arpack++new/include/arhbmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,29 ****
  #ifndef ARHBMAT_H
  #define ARHBMAT_H
  
! #include <stddef.h>
! #include <fstream.h>
! #include <stdlib.h>
! #include <string.h>
  #include "arch.h"
  #include "arerror.h"
  
--- 20,30 ----
  #ifndef ARHBMAT_H
  #define ARHBMAT_H
  
! #include <cstddef>
! #include <fstream>
! #include <cstdlib>
! #include <cstring>
! #include <string>
  #include "arch.h"
  #include "arerror.h"
  
***************
*** 33,86 ****
  
   private:
  
!   char*   datafile;        // Filename.
!   char    title[73];       // Title.
!   char    name[9];         // Name.
!   char    type[4];         // Matrix type.
!   int     m;               // Number of rows.
!   int     n;               // Number of columns.
!   int     nnz;             // Number of nonzero variables.
!   ARINT*  irow;            // Row indices.
!   ARINT*  pcol;            // Column pointers.
!   ARTYPE* val;             // Numerical values of matrix entries.
  
    void ConvertDouble(char* num);
  
!   bool ReadEntry(ifstream& file, int nval, int fval, int& j, double& val);
  
!   bool ReadEntry(ifstream& file, int nval, int fval, int& j, float& val);
  
!   bool ReadEntry(ifstream& file, int nval, int fval,
                   int& j, arcomplex<double>& val);
  
!   bool ReadEntry(ifstream& file, int nval, int fval,
                   int& j, arcomplex<float>& val);
  
!   void ReadFormat(ifstream& file, int& n, int& fmt);
  
   public:
  
    bool IsDefined() { return (m!=0); }
    
!   bool IsReal() { return (type[0]=='R'); }
  
!   bool IsComplex() { return (type[0]=='C'); }
  
!   bool IsSymmetric() { return (type[1]=='S'); }
  
!   bool IsUnsymmetric() { return (type[1]=='U'); }
  
!   bool IsHermitian() { return (type[1]=='H'); }
  
!   bool IsSkewSymmetric() { return (type[1]=='Z'); }
  
!   char* Filename() { return datafile; }
  
!   char* Title() { return title; }
  
!   char* Name() { return name; }
  
!   char* Type() { return type; }
  
    int NRows() { return m; }
  
--- 34,87 ----
  
   private:
  
!   std::string datafile;    // Filename.
!   std::string title;       // Title.
!   std::string name;        // Name.
!   std::string type;        // Matrix type.
!   int         m;           // Number of rows.
!   int         n;           // Number of columns.
!   int         nnz;         // Number of nonzero variables.
!   ARINT*      irow;        // Row indices.
!   ARINT*      pcol;        // Column pointers.
!   ARTYPE*     val;         // Numerical values of matrix entries.
  
    void ConvertDouble(char* num);
  
!   bool ReadEntry(std::ifstream& file, int nval, int fval, int& j, double& val);
  
!   bool ReadEntry(std::ifstream& file, int nval, int fval, int& j, float& val);
  
!   bool ReadEntry(std::ifstream& file, int nval, int fval,
                   int& j, arcomplex<double>& val);
  
!   bool ReadEntry(std::ifstream& file, int nval, int fval,
                   int& j, arcomplex<float>& val);
  
!   void ReadFormat(std::ifstream& file, int& n, int& fmt);
  
   public:
  
    bool IsDefined() { return (m!=0); }
    
!   bool IsReal() { return (type.size() > 0 && type[0]=='R'); }
  
!   bool IsComplex() { return (type.size() > 0 && type[0]=='C'); }
  
!   bool IsSymmetric() { return (type.size() > 1 && type[1]=='S'); }
  
!   bool IsUnsymmetric() { return (type.size() > 1 && type[1]=='U'); }
  
!   bool IsHermitian() { return (type.size() > 1 && type[1]=='H'); }
  
!   bool IsSkewSymmetric() { return (type.size() > 1 && type[1]=='Z'); }
  
!   const std::string& Filename() { return datafile; }
  
!   const std::string& Title() { return title; }
  
!   const std::string& Name() { return name; }
  
!   const std::string& Type() { return type; }
  
    int NRows() { return m; }
  
***************
*** 94,106 ****
  
    ARTYPE* Entries() { return val; }
  
!   void Define(char* filename);
    // Function that reads the matrix file. 
  
    ARhbMatrix();
    // Short constructor.
  
!   ARhbMatrix(char* filename) { Define(filename); }
    // Long constructor.
  
    ~ARhbMatrix();
--- 95,107 ----
  
    ARTYPE* Entries() { return val; }
  
!   void Define(const std::string& filename);
    // Function that reads the matrix file. 
  
    ARhbMatrix();
    // Short constructor.
  
!   ARhbMatrix(const std::string& filename) { Define(filename); }
    // Long constructor.
  
    ~ARhbMatrix();
***************
*** 131,137 ****
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(ifstream& file, int nval, int fval, int& j, double& val)
  {
  
    char num[81];
--- 132,138 ----
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(std::ifstream& file, int nval, int fval, int& j, double& val)
  {
  
    char num[81];
***************
*** 152,158 ****
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(ifstream& file, int nval, int fval, int& j, float& val)
  {
  
    double dval;
--- 153,159 ----
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(std::ifstream& file, int nval, int fval, int& j, float& val)
  {
  
    double dval;
***************
*** 167,173 ****
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(ifstream& file, int nval, int fval,
            int& j, arcomplex<double>& val)
  {
  
--- 168,174 ----
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(std::ifstream& file, int nval, int fval,
            int& j, arcomplex<double>& val)
  {
  
***************
*** 196,202 ****
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(ifstream& file, int nval, int fval,
            int& j, arcomplex<float>& val)
  {
  
--- 197,203 ----
  
  template<class ARINT, class ARTYPE>
  inline bool ARhbMatrix<ARINT, ARTYPE>::
! ReadEntry(std::ifstream& file, int nval, int fval,
            int& j, arcomplex<float>& val)
  {
  
***************
*** 227,233 ****
  
  
  template<class ARINT, class ARTYPE>
! void ARhbMatrix<ARINT, ARTYPE>::ReadFormat(ifstream& file, int& n, int& fmt)
  {
  
    char c;
--- 228,234 ----
  
  
  template<class ARINT, class ARTYPE>
! void ARhbMatrix<ARINT, ARTYPE>::ReadFormat(std::ifstream& file, int& n, int& fmt)
  {
  
    char c;
***************
*** 252,258 ****
  
  
  template<class ARINT, class ARTYPE>
! void ARhbMatrix<ARINT, ARTYPE>::Define(char* filename)
  {
  
    // Declaring variables.
--- 253,259 ----
  
  
  template<class ARINT, class ARTYPE>
! void ARhbMatrix<ARINT, ARTYPE>::Define(const std::string& filename)
  {
  
    // Declaring variables.
***************
*** 262,273 ****
    int    npcol, fpcol, nirow, firow, nval, fval;
    char   c;
    char   num[81];
    ARTYPE value;
  
    // Opening file.
  
    datafile = filename;
!   ifstream file(datafile);
    
    if (!file) {
      throw ArpackError(ArpackError::CANNOT_OPEN_FILE, "ARhbMatrix");
--- 263,277 ----
    int    npcol, fpcol, nirow, firow, nval, fval;
    char   c;
    char   num[81];
+   char   titlechar[73];
+   char   namechar[9];
+   char   typechar[4];
    ARTYPE value;
  
    // Opening file.
  
    datafile = filename;
!   std::ifstream file(datafile.c_str());
    
    if (!file) {
      throw ArpackError(ArpackError::CANNOT_OPEN_FILE, "ARhbMatrix");
***************
*** 275,282 ****
  
    // Reading the first line.
  
!   file.get((char*)title,73,'\n');
!   file.get((char*)name,9,'\n');
    do file.get(c); while (c!='\n'); 
  
    // Reading the second line.
--- 279,288 ----
  
    // Reading the first line.
  
!   file.get((char*)titlechar,73,'\n');
!   title = std::string(titlechar);
!   file.get((char*)namechar,9,'\n');
!   name = std::string(namechar);
    do file.get(c); while (c!='\n'); 
  
    // Reading the second line.
***************
*** 290,300 ****
  
    // Reading the third line.
  
!   file.get((char*)type,4,'\n');
    file >> m >> n >> nnz;
    do file.get(c); while (c!='\n'); 
  
!   if (((type[0] != 'R') && (type[0] != 'C')) || (type[2] != 'A')) {
      throw ArpackError(ArpackError::WRONG_MATRIX_TYPE, "ARhbMatrix");
    }
    else if ((m < 1) || (n < 1) || (nnz < 1)) {
--- 296,307 ----
  
    // Reading the third line.
  
!   file.get((char*)typechar,4,'\n');
!   type = std::string(typechar);
    file >> m >> n >> nnz;
    do file.get(c); while (c!='\n'); 
  
!   if ( (type.size()<3) || ((type[0] != 'R') && (type[0] != 'C')) || (type[2] != 'A')) {
      throw ArpackError(ArpackError::WRONG_MATRIX_TYPE, "ARhbMatrix");
    }
    else if ((m < 1) || (n < 1) || (nnz < 1)) {
diff -crB arpack++/include/arlcomp.h arpack++new/include/arlcomp.h
*** arpack++/include/arlcomp.h	2000-02-21 12:52:11.000000000 -0500
--- arpack++new/include/arlcomp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 14,19 ****
--- 14,20 ----
   * and Lawrence Berkeley National Lab.
   * November 15, 1997
   *
+  * </pre>
   */
  #ifndef __SUPERLU_DCOMPLEX /* allow multiple inclusions */
  #define __SUPERLU_DCOMPLEX
***************
*** 29,47 ****
  
  /* Macro definitions */
  
! /* Complex Addition c = a + b */
  #define z_add(c, a, b) { (c)->r = (a)->r + (b)->r; \
  			 (c)->i = (a)->i + (b)->i; }
  
! /* Complex Subtraction c = a - b */
  #define z_sub(c, a, b) { (c)->r = (a)->r - (b)->r; \
  			 (c)->i = (a)->i - (b)->i; }
  
! /* Complex-Double Multiplication */
  #define zd_mult(c, a, b) { (c)->r = (a)->r * (b); \
                             (c)->i = (a)->i * (b); }
  
! /* Complex-Complex Multiplication */
  #define zz_mult(c, a, b) { \
  	double cr, ci; \
      	cr = (a)->r * (b)->r - (a)->i * (b)->i; \
--- 30,48 ----
  
  /* Macro definitions */
  
! /*! \brief Complex Addition c = a + b */
  #define z_add(c, a, b) { (c)->r = (a)->r + (b)->r; \
  			 (c)->i = (a)->i + (b)->i; }
  
! /*! \brief Complex Subtraction c = a - b */
  #define z_sub(c, a, b) { (c)->r = (a)->r - (b)->r; \
  			 (c)->i = (a)->i - (b)->i; }
  
! /*! \brief Complex-Double Multiplication */
  #define zd_mult(c, a, b) { (c)->r = (a)->r * (b); \
                             (c)->i = (a)->i * (b); }
  
! /*! \brief Complex-Complex Multiplication */
  #define zz_mult(c, a, b) { \
  	double cr, ci; \
      	cr = (a)->r * (b)->r - (a)->i * (b)->i; \
***************
*** 50,56 ****
      	(c)->i = ci; \
      }
  
! /* Complex equality testing */
  #define z_eq(a, b)  ( (a)->r == (b)->r && (a)->i == (b)->i )
  
  
--- 51,62 ----
      	(c)->i = ci; \
      }
  
! #define zz_conj(a, b) { \
!         (a)->r = (b)->r; \
!         (a)->i = -((b)->i); \
!     }
! 
! /*! \brief Complex equality testing */
  #define z_eq(a, b)  ( (a)->r == (b)->r && (a)->i == (b)->i )
  
  
***************
*** 65,70 ****
--- 71,78 ----
  void z_exp(ldcomplex *, ldcomplex *);
  void d_cnjg(ldcomplex *r, ldcomplex *z);
  double d_imag(ldcomplex *);
+ ldcomplex z_sgn(ldcomplex *);
+ ldcomplex z_sqrt(ldcomplex *);
  
  
  #ifdef __cplusplus
***************
*** 90,108 ****
  
  /* Macro definitions */
  
! /* Complex Addition c = a + b */
  #define c_add(c, a, b) { (c)->r = (a)->r + (b)->r; \
  			 (c)->i = (a)->i + (b)->i; }
  
! /* Complex Subtraction c = a - b */
  #define c_sub(c, a, b) { (c)->r = (a)->r - (b)->r; \
  			 (c)->i = (a)->i - (b)->i; }
  
! /* Complex-Double Multiplication */
  #define cs_mult(c, a, b) { (c)->r = (a)->r * (b); \
                             (c)->i = (a)->i * (b); }
  
! /* Complex-Complex Multiplication */
  #define cc_mult(c, a, b) { \
  	float cr, ci; \
      	cr = (a)->r * (b)->r - (a)->i * (b)->i; \
--- 98,116 ----
  
  /* Macro definitions */
  
! /*! \brief Complex Addition c = a + b */
  #define c_add(c, a, b) { (c)->r = (a)->r + (b)->r; \
  			 (c)->i = (a)->i + (b)->i; }
  
! /*! \brief Complex Subtraction c = a - b */
  #define c_sub(c, a, b) { (c)->r = (a)->r - (b)->r; \
  			 (c)->i = (a)->i - (b)->i; }
  
! /*! \brief Complex-Double Multiplication */
  #define cs_mult(c, a, b) { (c)->r = (a)->r * (b); \
                             (c)->i = (a)->i * (b); }
  
! /*! \brief Complex-Complex Multiplication */
  #define cc_mult(c, a, b) { \
  	float cr, ci; \
      	cr = (a)->r * (b)->r - (a)->i * (b)->i; \
***************
*** 111,117 ****
      	(c)->i = ci; \
      }
  
! /* Complex equality testing */
  #define c_eq(a, b)  ( (a)->r == (b)->r && (a)->i == (b)->i )
  
  
--- 119,130 ----
      	(c)->i = ci; \
      }
  
! #define cc_conj(a, b) { \
!         (a)->r = (b)->r; \
!         (a)->i = -((b)->i); \
!     }
! 
! /*! \brief Complex equality testing */
  #define c_eq(a, b)  ( (a)->r == (b)->r && (a)->i == (b)->i )
  
  
***************
*** 126,131 ****
--- 139,146 ----
  void c_exp(lscomplex *, lscomplex *);
  void r_cnjg(lscomplex *, lscomplex *);
  double r_imag(lscomplex *);
+ lscomplex c_sgn(lscomplex *);
+ lscomplex c_sqrt(lscomplex *);
  
  
  #ifdef __cplusplus
diff -crB arpack++/include/arlgcomp.h arpack++new/include/arlgcomp.h
*** arpack++/include/arlgcomp.h	2000-02-20 19:31:04.000000000 -0500
--- arpack++new/include/arlgcomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARLGCOMP_H
  #define ARLGCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arlnsmat.h"
  #include "arlnspen.h"
--- 18,25 ----
  #ifndef ARLGCOMP_H
  #define ARLGCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arlnsmat.h"
  #include "arlnspen.h"
***************
*** 65,78 ****
  
    ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 66,79 ----
  
    ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 103,111 ****
    ARCompGenEig<ARFLOAT, ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   if (mode > 2) objOP->FactorAsB(sigmaR);
  
  } // Copy.
  
--- 104,112 ----
    ARCompGenEig<ARFLOAT, ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   if (this->mode > 2) this->objOP->FactorAsB(this->sigmaR);
  
  } // Copy.
  
***************
*** 114,120 ****
  inline void ARluCompGenEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
  {
  
!   objOP->FactorAsB(sigmap);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
  
  } // ChangeShift.
--- 115,121 ----
  inline void ARluCompGenEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
  {
  
!   this->objOP->FactorAsB(sigmap);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
  
  } // ChangeShift.
***************
*** 148,162 ****
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
--- 149,163 ----
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const std::string& whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
***************
*** 169,182 ****
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
                     &Pencil, 
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
--- 170,183 ----
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvAsBv,
                     &Pencil, 
                     &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultBv,
***************
*** 192,198 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 193,199 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arlgnsym.h arpack++new/include/arlgnsym.h
*** arpack++/include/arlgnsym.h	2000-02-20 19:25:52.000000000 -0500
--- arpack++new/include/arlgnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARLGNSYM_H
  #define ARLGNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arlnsmat.h"
  #include "arlnspen.h"
--- 18,25 ----
  #ifndef ARLGNSYM_H
  #define ARLGNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arlnsmat.h"
  #include "arlnspen.h"
***************
*** 64,84 ****
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
--- 65,85 ----
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
***************
*** 110,124 ****
    ARNonSymGenEig<ARFLOAT, ARluNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARluNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
!   if (mode > 2) {
!     if (sigmaI == 0.0) {
!       objOP->FactorAsB(sigmaR);
      }
      else {
!       objOP->FactorAsB(sigmaR, sigmaI, part);
      }
    }
  
--- 111,125 ----
    ARNonSymGenEig<ARFLOAT, ARluNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARluNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
!   if (this->mode > 2) {
!     if (this->sigmaI == 0.0) {
!       this->objOP->FactorAsB(this->sigmaR);
      }
      else {
!       this->objOP->FactorAsB(this->sigmaR, this->sigmaI, this->part);
      }
    }
  
***************
*** 131,140 ****
  {
  
    if (sigmaIp == 0.0) {
!     objOP->FactorAsB(sigmaRp);
    }
    else {
!     objOP->FactorAsB(sigmaRp, sigmaIp, part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
--- 132,141 ----
  {
  
    if (sigmaIp == 0.0) {
!     this->objOP->FactorAsB(sigmaRp);
    }
    else {
!     this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
***************
*** 180,193 ****
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 181,194 ----
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 199,211 ****
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 200,212 ----
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 219,231 ****
  ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
                   char partp, ARFLOAT sigmaRp,
!                  ARFLOAT sigmaIp, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 220,232 ----
  ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARluNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
                   char partp, ARFLOAT sigmaRp,
!                  ARFLOAT sigmaIp, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 240,246 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 241,247 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arlgsym.h arpack++new/include/arlgsym.h
*** arpack++/include/arlgsym.h	2000-02-20 19:20:30.000000000 -0500
--- arpack++new/include/arlgsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 19,25 ****
  #ifndef ARLGSYM_H
  #define ARLGSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arlsmat.h"
  #include "arlspen.h"
--- 19,26 ----
  #ifndef ARLGSYM_H
  #define ARLGSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arlsmat.h"
  #include "arlspen.h"
***************
*** 67,79 ****
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 ARluSymMatrix<ARFLOAT>& B, char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 ARluSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
--- 68,80 ----
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 ARluSymMatrix<ARFLOAT>& B, const std::string& whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 ARluSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const std::string& whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
***************
*** 105,114 ****
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>,
                ARluSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
!   if (mode > 2) objOP->FactorAsB(sigmaR);
  
  } // Copy.
  
--- 106,115 ----
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>,
                ARluSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
!   if (this->mode > 2) this->objOP->FactorAsB(this->sigmaR);
  
  } // Copy.
  
***************
*** 117,123 ****
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
--- 118,124 ----
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   this->objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
***************
*** 140,146 ****
  
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>, ARluSymPencil<ARFLOAT> >::
      SetShiftInvertMode(sigmap, &Pencil, &ARluSymPencil<ARFLOAT>::MultInvAsBv);
!   ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultBv);
  
  } // SetShiftInvertMode.
  
--- 141,147 ----
  
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>, ARluSymPencil<ARFLOAT> >::
      SetShiftInvertMode(sigmap, &Pencil, &ARluSymPencil<ARFLOAT>::MultInvAsBv);
!   this->ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultBv);
  
  } // SetShiftInvertMode.
  
***************
*** 152,158 ****
  
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>, ARluSymPencil<ARFLOAT> >::
      SetBucklingMode(sigmap, &Pencil, &ARluSymPencil<ARFLOAT>::MultInvAsBv);
!   ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
  
  } // SetBucklingMode.
  
--- 153,159 ----
  
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>, ARluSymPencil<ARFLOAT> >::
      SetBucklingMode(sigmap, &Pencil, &ARluSymPencil<ARFLOAT>::MultInvAsBv);
!   this->ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
  
  } // SetBucklingMode.
  
***************
*** 165,171 ****
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>, ARluSymPencil<ARFLOAT> >::
      SetCayleyMode(sigmap, &Pencil, &ARluSymPencil<ARFLOAT>::MultInvAsBv,
                    &Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
!   ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultBv);
  
  } // SetCayleyMode.
  
--- 166,172 ----
    ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>, ARluSymPencil<ARFLOAT> >::
      SetCayleyMode(sigmap, &Pencil, &ARluSymPencil<ARFLOAT>::MultInvAsBv,
                    &Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
!   this->ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultBv);
  
  } // SetCayleyMode.
  
***************
*** 173,187 ****
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!               ARluSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   InvertMode = 'S';
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
--- 174,188 ----
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!               ARluSymMatrix<ARFLOAT>& B, const std::string& whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->InvertMode = 'S';
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 193,212 ****
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARluSymMatrix<ARFLOAT>& A,
                ARluSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   InvertMode = CheckInvertMode(InvertModep);
!   switch (InvertMode) {
    case 'B':  // Buckling mode.
!     ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
    case 'S':  // Shift and invert mode.
      ChangeShift(sigmap);
      break;
--- 194,213 ----
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARluSymMatrix<ARFLOAT>& A,
                ARluSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARluSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   this->InvertMode = this->CheckInvertMode(InvertModep);
!   switch (this->InvertMode) {
    case 'B':  // Buckling mode.
!     this->ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
    case 'S':  // Shift and invert mode.
      ChangeShift(sigmap);
      break;
***************
*** 223,229 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 224,230 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arlnames.h arpack++new/include/arlnames.h
*** arpack++/include/arlnames.h	2000-02-20 19:34:26.000000000 -0500
--- arpack++new/include/arlnames.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 27,52 ****
   */
  
  #define ADD_       0
! #define NOCHANGE   1
! #define UPCASE     2
! #define C_CALL     3
  
  #ifdef UpCase
! #define F77_CALL_C UPCASE
  #endif
  
  #ifdef NoChange
! #define F77_CALL_C NOCHANGE
  #endif
  
  #ifdef Add_
! #define F77_CALL_C ADD_
  #endif
  
  #ifndef F77_CALL_C
! #define F77_CALL_C ADD_
  #endif
  
  #if (F77_CALL_C == ADD_)
  /*
   * These defines set up the naming scheme required to have a fortran 77
--- 27,64 ----
   */
  
  #define ADD_       0
! #define ADD__      1
! #define NOCHANGE   2
! #define UPCASE     3
! #define OLD_CRAY   4
! #define C_CALL     5
  
  #ifdef UpCase
! #define F77_CALL_C  UPCASE
  #endif
  
  #ifdef NoChange
! #define F77_CALL_C  NOCHANGE
  #endif
  
  #ifdef Add_
! #define F77_CALL_C  ADD_
  #endif
  
+ #ifdef Add__
+ #define F77_CALL_C  ADD__
+ #endif
+ 
+ #ifdef _CRAY
+ #define F77_CALL_C  OLD_CRAY
+ #endif
+ 
+ /* Default */
  #ifndef F77_CALL_C
! #define F77_CALL_C  ADD_
  #endif
  
+ 
  #if (F77_CALL_C == ADD_)
  /*
   * These defines set up the naming scheme required to have a fortran 77
***************
*** 60,65 ****
--- 72,175 ----
  
  #endif
  
+ #if (F77_CALL_C == ADD__)
+ /*
+  * These defines set up the naming scheme required to have a fortran 77
+  * routine call a C routine 
+  * for following Fortran to C interface:
+  *           FORTRAN CALL               C DECLARATION
+  *           call dgemm(...)           void dgemm__(...)
+  */
+ /* BLAS */
+ #define sswap_    sswap__
+ #define saxpy_    saxpy__
+ #define sasum_    sasum__
+ #define isamax_   isamax__
+ #define scopy_    scopy__
+ #define sscal_    sscal__
+ #define sger_     sger__
+ #define snrm2_    snrm2__
+ #define ssymv_    ssymv__
+ #define sdot_     sdot__
+ #define saxpy_    saxpy__
+ #define ssyr2_    ssyr2__
+ #define srot_     srot__
+ #define sgemv_    sgemv__
+ #define strsv_    strsv__
+ #define sgemm_    sgemm__
+ #define strsm_    strsm__
+ 
+ #define dswap_    dswap__
+ #define daxpy_    daxpy__
+ #define dasum_    dasum__
+ #define idamax_   idamax__
+ #define dcopy_    dcopy__
+ #define dscal_    dscal__
+ #define dger_     dger__
+ #define dnrm2_    dnrm2__
+ #define dsymv_    dsymv__
+ #define ddot_     ddot__
+ #define dsyr2_    dsyr2__
+ #define drot_     drot__
+ #define dgemv_    dgemv__
+ #define dtrsv_    dtrsv__
+ #define dgemm_    dgemm__
+ #define dtrsm_    dtrsm__
+ 
+ #define cswap_    cswap__
+ #define caxpy_    caxpy__
+ #define scasum_   scasum__
+ #define icamax_   icamax__
+ #define ccopy_    ccopy__
+ #define cscal_    cscal__
+ #define scnrm2_   scnrm2__
+ #define caxpy_    caxpy__
+ #define cgemv_    cgemv__
+ #define ctrsv_    ctrsv__
+ #define cgemm_    cgemm__
+ #define ctrsm_    ctrsm__
+ #define cgerc_    cgerc__
+ #define chemv_    chemv__
+ #define cher2_    cher2__
+ 
+ #define zswap_    zswap__
+ #define zaxpy_    zaxpy__
+ #define dzasum_   dzasum__
+ #define izamax_   izamax__
+ #define zcopy_    zcopy__
+ #define zscal_    zscal__
+ #define dznrm2_   dznrm2__
+ #define zaxpy_    zaxpy__
+ #define zgemv_    zgemv__
+ #define ztrsv_    ztrsv__
+ #define zgemm_    zgemm__
+ #define ztrsm_    ztrsm__
+ #define zgerc_    zgerc__
+ #define zhemv_    zhemv__
+ #define zher2_    zher2__
+ 
+ /* LAPACK */
+ #define dlamch_   dlamch__
+ #define slamch_   slamch__
+ #define xerbla_   xerbla__
+ #define lsame_    lsame__
+ #define dlacon_   dlacon__
+ #define slacon_   slacon__
+ #define icmax1_   icmax1__
+ #define scsum1_   scsum1__
+ #define clacon_   clacon__
+ #define dzsum1_   dzsum1__
+ #define izmax1_   izmax1__
+ #define zlacon_   zlacon__
+ 
+ /* Fortran interface */
+ #define c_bridge_dgssv_ c_bridge_dgssv__
+ #define c_fortran_sgssv_ c_fortran_sgssv__
+ #define c_fortran_dgssv_ c_fortran_dgssv__
+ #define c_fortran_cgssv_ c_fortran_cgssv__
+ #define c_fortran_zgssv_ c_fortran_zgssv__
+ #endif
+ 
  #if (F77_CALL_C == UPCASE)
  /*
   * These defines set up the naming scheme required to have a fortran 77
***************
*** 68,73 ****
--- 178,186 ----
   *           FORTRAN CALL               C DECLARATION
   *           call dgemm(...)           void DGEMM(...)
   */
+ /* BLAS */
+ #define sswap_    SSWAP
+ #define saxpy_    SAXPY
  #define sasum_    SASUM
  #define isamax_   ISAMAX
  #define scopy_    SCOPY
***************
*** 84,89 ****
--- 197,300 ----
  #define sgemm_    SGEMM
  #define strsm_    STRSM
  
+ #define dswap_    DSWAP
+ #define daxpy_    DAXPY
+ #define dasum_    DASUM
+ #define idamax_   IDAMAX
+ #define dcopy_    DCOPY
+ #define dscal_    DSCAL
+ #define dger_     DGER
+ #define dnrm2_    DNRM2
+ #define dsymv_    DSYMV
+ #define ddot_     DDOT
+ #define dsyr2_    DSYR2
+ #define drot_     DROT
+ #define dgemv_    DGEMV
+ #define dtrsv_    DTRSV
+ #define dgemm_    DGEMM
+ #define dtrsm_    DTRSM
+ 
+ #define cswap_    CSWAP
+ #define caxpy_    CAXPY
+ #define scasum_   SCASUM
+ #define icamax_   ICAMAX
+ #define ccopy_    CCOPY
+ #define cscal_    CSCAL
+ #define scnrm2_   SCNRM2
+ #define cgemv_    CGEMV
+ #define ctrsv_    CTRSV
+ #define cgemm_    CGEMM
+ #define ctrsm_    CTRSM
+ #define cgerc_    CGERC
+ #define chemv_    CHEMV
+ #define cher2_    CHER2
+ 
+ #define zswap_    ZSWAP
+ #define zaxpy_    ZAXPY
+ #define dzasum_   DZASUM
+ #define izamax_   IZAMAX
+ #define zcopy_    ZCOPY
+ #define zscal_    ZSCAL
+ #define dznrm2_   DZNRM2
+ #define zgemv_    ZGEMV
+ #define ztrsv_    ZTRSV
+ #define zgemm_    ZGEMM
+ #define ztrsm_    ZTRSM
+ #define zgerc_    ZGERC
+ #define zhemv_    ZHEMV
+ #define zher2_    ZHER2
+ 
+ /* LAPACK */
+ #define dlamch_   DLAMCH
+ #define slamch_   SLAMCH
+ #define xerbla_   XERBLA
+ #define lsame_    LSAME
+ #define dlacon_   DLACON
+ #define slacon_   SLACON
+ #define icmax1_   ICMAX1
+ #define scsum1_   SCSUM1
+ #define clacon_   CLACON
+ #define dzsum1_   DZSUM1
+ #define izmax1_   IZMAX1
+ #define zlacon_   ZLACON
+ 
+ /* Fortran interface */
+ #define c_bridge_dgssv_ C_BRIDGE_DGSSV
+ #define c_fortran_sgssv_ C_FORTRAN_SGSSV
+ #define c_fortran_dgssv_ C_FORTRAN_DGSSV
+ #define c_fortran_cgssv_ C_FORTRAN_CGSSV
+ #define c_fortran_zgssv_ C_FORTRAN_ZGSSV
+ #endif
+ 
+ 
+ #if (F77_CALL_C == OLD_CRAY)
+ /*
+  * These defines set up the naming scheme required to have a fortran 77
+  * routine call a C routine 
+  * following Fortran to C interface:
+  *           FORTRAN CALL               C DECLARATION
+  *           call dgemm(...)           void SGEMM(...)
+  */
+ /* BLAS */
+ #define sswap_    SSWAP
+ #define saxpy_    SAXPY
+ #define sasum_    SASUM
+ #define isamax_   ISAMAX
+ #define scopy_    SCOPY
+ #define sscal_    SSCAL
+ #define sger_     SGER
+ #define snrm2_    SNRM2
+ #define ssymv_    SSYMV
+ #define sdot_     SDOT
+ #define ssyr2_    SSYR2
+ #define srot_     SROT
+ #define sgemv_    SGEMV
+ #define strsv_    STRSV
+ #define sgemm_    SGEMM
+ #define strsm_    STRSM
+ 
+ #define dswap_    SSWAP
+ #define daxpy_    SAXPY
  #define dasum_    SASUM
  #define idamax_   ISAMAX
  #define dcopy_    SCOPY
***************
*** 92,98 ****
  #define dnrm2_    SNRM2
  #define dsymv_    SSYMV
  #define ddot_     SDOT
- #define daxpy_    SAXPY
  #define dsyr2_    SSYR2
  #define drot_     SROT
  #define dgemv_    SGEMV
--- 303,308 ----
***************
*** 100,105 ****
--- 310,317 ----
  #define dgemm_    SGEMM
  #define dtrsm_    STRSM
  
+ #define cswap_    CSWAP
+ #define caxpy_    CAXPY
  #define scasum_   SCASUM
  #define icamax_   ICAMAX
  #define ccopy_    CCOPY
***************
*** 114,136 ****
  #define chemv_    CHEMV
  #define cher2_    CHER2
  
! #define dzasum_   SCASUM
! #define izamax_   ICAMAX
! #define zcopy_    CCOPY
! #define zscal_    CSCAL
! #define dznrm2_   SCNRM2
! #define zaxpy_    CAXPY
! #define zgemv_    CGEMV
! #define ztrsv_    CTRSV
! #define zgemm_    CGEMM
! #define ztrsm_    CTRSM
! #define zgerc_    CGERC
! #define zhemv_    CHEMV
! #define zher2_    CHER2
  
  #define c_bridge_dgssv_ C_BRIDGE_DGSSV
  #endif
  
  #if (F77_CALL_C == NOCHANGE)
  /*
   * These defines set up the naming scheme required to have a fortran 77
--- 326,369 ----
  #define chemv_    CHEMV
  #define cher2_    CHER2
  
! #define zswap_    ZSWAP
! #define zaxpy_    ZAXPY
! #define dzasum_   DZASUM
! #define izamax_   IZAMAX
! #define zcopy_    ZCOPY
! #define zscal_    ZSCAL
! #define dznrm2_   DZNRM2
! #define zgemv_    ZGEMV
! #define ztrsv_    ZTRSV
! #define zgemm_    ZGEMM
! #define ztrsm_    ZTRSM
! #define zgerc_    ZGERC
! #define zhemv_    ZHEMV
! #define zher2_    ZHER2
! 
! /* LAPACK */
! #define dlamch_   DLAMCH
! #define slamch_   SLAMCH
! #define xerbla_   XERBLA
! #define lsame_    LSAME
! #define dlacon_   DLACON
! #define slacon_   SLACON
! #define icmax1_   ICMAX1
! #define scsum1_   SCSUM1
! #define clacon_   CLACON
! #define dzsum1_   DZSUM1
! #define izmax1_   IZMAX1
! #define zlacon_   ZLACON
  
+ /* Fortran interface */
  #define c_bridge_dgssv_ C_BRIDGE_DGSSV
+ #define c_fortran_sgssv_ C_FORTRAN_SGSSV
+ #define c_fortran_dgssv_ C_FORTRAN_DGSSV
+ #define c_fortran_cgssv_ C_FORTRAN_CGSSV
+ #define c_fortran_zgssv_ C_FORTRAN_ZGSSV
  #endif
  
+ 
  #if (F77_CALL_C == NOCHANGE)
  /*
   * These defines set up the naming scheme required to have a fortran 77
***************
*** 139,144 ****
--- 372,380 ----
   *           FORTRAN CALL               C DECLARATION
   *           call dgemm(...)           void dgemm(...)
   */
+ /* BLAS */
+ #define sswap_    sswap
+ #define saxpy_    saxpy
  #define sasum_    sasum
  #define isamax_   isamax
  #define scopy_    scopy
***************
*** 155,160 ****
--- 391,398 ----
  #define sgemm_    sgemm
  #define strsm_    strsm
  
+ #define dswap_    dswap
+ #define daxpy_    daxpy
  #define dasum_    dasum
  #define idamax_   idamax
  #define dcopy_    dcopy
***************
*** 163,169 ****
  #define dnrm2_    dnrm2
  #define dsymv_    dsymv
  #define ddot_     ddot
- #define daxpy_    daxpy
  #define dsyr2_    dsyr2
  #define drot_     drot
  #define dgemv_    dgemv
--- 401,406 ----
***************
*** 171,182 ****
  #define dgemm_    dgemm
  #define dtrsm_    dtrsm
  
  #define scasum_   scasum
  #define icamax_   icamax
  #define ccopy_    ccopy
  #define cscal_    cscal
  #define scnrm2_   scnrm2
- #define caxpy_    caxpy
  #define cgemv_    cgemv
  #define ctrsv_    ctrsv
  #define cgemm_    cgemm
--- 408,420 ----
  #define dgemm_    dgemm
  #define dtrsm_    dtrsm
  
+ #define cswap_    cswap
+ #define caxpy_    caxpy
  #define scasum_   scasum
  #define icamax_   icamax
  #define ccopy_    ccopy
  #define cscal_    cscal
  #define scnrm2_   scnrm2
  #define cgemv_    cgemv
  #define ctrsv_    ctrsv
  #define cgemm_    cgemm
***************
*** 185,196 ****
  #define chemv_    chemv
  #define cher2_    cher2
  
  #define dzasum_   dzasum
  #define izamax_   izamax
  #define zcopy_    zcopy
  #define zscal_    zscal
  #define dznrm2_   dznrm2
- #define zaxpy_    zaxpy
  #define zgemv_    zgemv
  #define ztrsv_    ztrsv
  #define zgemm_    zgemm
--- 423,435 ----
  #define chemv_    chemv
  #define cher2_    cher2
  
+ #define zswap_    zswap
+ #define zaxpy_    zaxpy
  #define dzasum_   dzasum
  #define izamax_   izamax
  #define zcopy_    zcopy
  #define zscal_    zscal
  #define dznrm2_   dznrm2
  #define zgemv_    zgemv
  #define ztrsv_    ztrsv
  #define zgemm_    zgemm
***************
*** 199,205 ****
--- 438,464 ----
  #define zhemv_    zhemv
  #define zher2_    zher2
  
+ /* LAPACK */
+ #define dlamch_   dlamch
+ #define slamch_   slamch
+ #define xerbla_   xerbla
+ #define lsame_    lsame
+ #define dlacon_   dlacon
+ #define slacon_   slacon
+ #define icmax1_   icmax1
+ #define scsum1_   scsum1
+ #define clacon_   clacon
+ #define dzsum1_   dzsum1
+ #define izmax1_   izmax1
+ #define zlacon_   zlacon
+ 
+ /* Fortran interface */
  #define c_bridge_dgssv_ c_bridge_dgssv
+ #define c_fortran_sgssv_ c_fortran_sgssv
+ #define c_fortran_dgssv_ c_fortran_dgssv
+ #define c_fortran_cgssv_ c_fortran_cgssv
+ #define c_fortran_zgssv_ c_fortran_zgssv
  #endif
  
+ 
  #endif /* __SUPERLU_CNAMES */
diff -crB arpack++/include/arlnsmat.h arpack++new/include/arlnsmat.h
*** arpack++/include/arlnsmat.h	2000-02-22 08:27:32.000000000 -0500
--- arpack++new/include/arlnsmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARLNSMAT_H
  #define ARLNSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
--- 20,27 ----
  #ifndef ARLNSMAT_H
  #define ARLNSMAT_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
***************
*** 53,58 ****
--- 54,60 ----
    SuperMatrix L;
    SuperMatrix U;
    ARhbMatrix<int, ARTYPE> mat;
+   SuperLUStat_t stat;
  
    bool DataOK();
  
***************
*** 101,107 ****
    ARluNonSymMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp,int* pcolp);
    // Long constructor (rectangular matrix).
  
!   ARluNonSymMatrix(char* name, double thresholdp = 0.1, 
                     int orderp = 1, bool check = true);
    // Long constructor (Harwell-Boeing file).
  
--- 103,109 ----
    ARluNonSymMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp,int* pcolp);
    // Long constructor (rectangular matrix).
  
!   ARluNonSymMatrix(const std::string& name, double thresholdp = 0.1, 
                     int orderp = 1, bool check = true);
    // Long constructor (Harwell-Boeing file).
  
***************
*** 130,145 ****
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
!       if ((irow[j]<0)||(irow[k]>=n)) return false;
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
      }
--- 132,147 ----
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=this->n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=this->n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
!       if ((irow[j]<0)||(irow[k]>=this->n)) return false;
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
      }
***************
*** 157,168 ****
  
    // Copying very fundamental variables.
  
!   defined   = other.defined;
    factored  = other.factored;
  
    // Returning from here if "other" was not initialized.
  
!   if (!defined) return;
  
    // Copying user-defined parameters.
  
--- 159,170 ----
  
    // Copying very fundamental variables.
  
!   this->defined   = other.defined;
    factored  = other.factored;
  
    // Returning from here if "other" was not initialized.
  
!   if (!this->defined) return;
  
    // Copying user-defined parameters.
  
***************
*** 196,204 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
    }
!   if (defined) {
      Destroy_SuperMatrix_Store(&A); // delete A.Store;
      delete[] permc;
      delete[] permr;
--- 198,206 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
    }
!   if (this->defined) {
      Destroy_SuperMatrix_Store(&A); // delete A.Store;
      delete[] permc;
      delete[] permr;
***************
*** 231,237 ****
    k = 0;
    AsI.colptr[0] = 0;
  
!   for (i=0; i!=n; i++) {
  
      j = A.colptr[i];
      end = A.colptr[i+1];
--- 233,239 ----
    k = 0;
    AsI.colptr[0] = 0;
  
!   for (i=0; i!=this->n; i++) {
  
      j = A.colptr[i];
      end = A.colptr[i+1];
***************
*** 264,270 ****
  
    }
  
!   AsI.nnz = AsI.colptr[n];
  
  } // SubtractAsI.
  
--- 266,272 ----
  
    }
  
!   AsI.nnz = AsI.colptr[this->n];
  
  } // SubtractAsI.
  
***************
*** 281,293 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::FactorA");
    }
  
    // Quitting the function if A is not square.
  
!   if (m != n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARluNonSymMatrix::FactorA");
    }
--- 283,295 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::FactorA");
    }
  
    // Quitting the function if A is not square.
  
!   if (this->m != this->n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARluNonSymMatrix::FactorA");
    }
***************
*** 297,318 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
    }
  
    // Setting default values for gstrf parameters.
  
!   double drop_tol        = 0.0;
!   int    panel_size      = sp_ienv(1);
!   int    relax           = sp_ienv(2);
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[n];
  
    // Defining LUStat.
  
!   StatInit(panel_size, relax);
  
    // Defining the column permutation of matrix A
    // (using minimum degree ordering on A'*A).
--- 299,337 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
    }
  
    // Setting default values for gstrf parameters.
  
!   double drop_tol   = 0.0;
!   int    panel_size = sp_ienv(1);
!   int    relax      = sp_ienv(2);
!   superlu_options_t options;
! 
!   /* Set the default input options:
!   options.Fact = DOFACT;
!   options.Equil = YES;
!   options.ColPerm = COLAMD;
!   options.DiagPivotThresh = 1.0;
!   options.Trans = NOTRANS;
!   options.IterRefine = NOREFINE;
!   options.SymmetricMode = NO;
!   options.PivotGrowth = NO;
!   options.ConditionNumber = NO;
!   options.PrintStat = YES;
!   */
!   set_default_options(&options);
!   options.DiagPivotThresh = threshold;
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[this->n];
  
    // Defining LUStat.
  
!   //StatInit(panel_size, relax);
!   StatInit(&stat);
  
    // Defining the column permutation of matrix A
    // (using minimum degree ordering on A'*A).
***************
*** 322,333 ****
    // Permuting columns of A and
    // creating the elimination tree of A'*A.
  
!   sp_preorder("N", &A, permc, etree, &AC);
  
    // Decomposing A.
  
!   gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
!         NULL, 0, permr, permc, &L, &U, &info);
  
    // Deleting AC and etree.
  
--- 341,355 ----
    // Permuting columns of A and
    // creating the elimination tree of A'*A.
  
! //  sp_preorder("N", &A, permc, etree, &AC);
!   sp_preorder(&options, &A, permc, etree, &AC);
  
    // Decomposing A.
  
! //  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
! //        NULL, 0, permr, permc, &L, &U, &info);
!   gstrf(&options,&AC, drop_tol, relax, panel_size, etree,
!         NULL, 0, permc, permr, &L, &U, &stat, &info);
  
    // Deleting AC and etree.
  
***************
*** 342,348 ****
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluNonSymMatrix::FactorA");
    }
!   else if (info > n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluNonSymMatrix::FactorA");
    }
--- 364,370 ----
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluNonSymMatrix::FactorA");
    }
!   else if (info > this->n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluNonSymMatrix::FactorA");
    }
***************
*** 360,373 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARluNonSymMatrix::FactorAsI");
    }
  
    // Quitting the function if A is not square.
  
!   if (m != n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARluNonSymMatrix::FactorAsI");
    }
--- 382,395 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARluNonSymMatrix::FactorAsI");
    }
  
    // Quitting the function if A is not square.
  
!   if (this->m != this->n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARluNonSymMatrix::FactorAsI");
    }
***************
*** 389,409 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
    }
  
    // Setting default values for gstrf parameters.
  
!   double drop_tol        = 0.0;
!   int    panel_size      = sp_ienv(1);
!   int    relax           = sp_ienv(2);
  
    // Creating a temporary matrix AsI.
  
!   irowi = new int[nnz+n];
!   pcoli = new int[n+1];
!   asi   = new ARTYPE[nnz+n];
!   Create_CompCol_Matrix(&AsI, n,  n, nnz, asi, irowi, pcoli, NC, GE);
  
    // Subtracting sigma*I from A and storing the result on AsI.
  
--- 411,447 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
    }
  
    // Setting default values for gstrf parameters.
  
!   double drop_tol   = 0.0;
!   int    panel_size = sp_ienv(1);
!   int    relax      = sp_ienv(2);
!   superlu_options_t options;
! 
!   /* Set the default input options:
!   options.Fact = DOFACT;
!   options.Equil = YES;
!   options.ColPerm = COLAMD;
!   options.DiagPivotThresh = 1.0;
!   options.Trans = NOTRANS;
!   options.IterRefine = NOREFINE;
!   options.SymmetricMode = NO;
!   options.PivotGrowth = NO;
!   options.ConditionNumber = NO;
!   options.PrintStat = YES;
!   */
!   set_default_options(&options);
!   options.DiagPivotThresh = threshold;
  
    // Creating a temporary matrix AsI.
  
!   irowi = new int[nnz+this->n];
!   pcoli = new int[this->n+1];
!   asi   = new ARTYPE[nnz+this->n];
!   Create_CompCol_Matrix(&AsI, this->n,  this->n, nnz, asi, irowi, pcoli, SLU_NC, SLU_GE);
  
    // Subtracting sigma*I from A and storing the result on AsI.
  
***************
*** 413,423 ****
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[n];
  
    // Defining LUStat.
  
!   StatInit(panel_size, relax);
  
    // Defining the column permutation of matrix AsI
    // (using minimum degree ordering on AsI'*AsI).
--- 451,462 ----
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[this->n];
  
    // Defining LUStat.
  
!   //StatInit(panel_size, relax);
!   StatInit(&stat);
  
    // Defining the column permutation of matrix AsI
    // (using minimum degree ordering on AsI'*AsI).
***************
*** 427,438 ****
    // Permuting columns of AsI and
    // creating the elimination tree of AsI'*AsI.
  
!   sp_preorder("N", &AsI, permc, etree, &AC);
  
    // Decomposing AsI.
  
!   gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
!         NULL, 0, permr, permc, &L, &U, &info);
  
    // Deleting AC, AsI and etree.
  
--- 466,480 ----
    // Permuting columns of AsI and
    // creating the elimination tree of AsI'*AsI.
  
!   //sp_preorder("N", &AsI, permc, etree, &AC);
!   sp_preorder(&options, &AsI, permc, etree, &AC);
  
    // Decomposing AsI.
  
! //  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
! //        NULL, 0, permr, permc, &L, &U, &info);
!   gstrf(&options,&AC, drop_tol, relax, panel_size, etree,
!         NULL, 0, permc, permr, &L, &U, &stat, &info);
  
    // Deleting AC, AsI and etree.
  
***************
*** 448,454 ****
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluNonSymMatrix::FactorAsI");
    }
!   else if (info > n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluNonSymMatrix::FactorAsI");
    }
--- 490,496 ----
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluNonSymMatrix::FactorAsI");
    }
!   else if (info > this->n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluNonSymMatrix::FactorAsI");
    }
***************
*** 469,483 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
  
!   for (i=0; i!=n; i++) {
      t = v[i];
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        w[irow[j]] += t*a[j];
--- 511,525 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
  
!   for (i=0; i!=this->n; i++) {
      t = v[i];
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        w[irow[j]] += t*a[j];
***************
*** 496,508 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMtv");
    }
  
    // Determining w = M'.v.
  
!   for (i=0; i!=n; i++) {
      t = (ARTYPE)0;
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        t += v[irow[j]]*a[j];
--- 538,550 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMtv");
    }
  
    // Determining w = M'.v.
  
!   for (i=0; i!=this->n; i++) {
      t = (ARTYPE)0;
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        t += v[irow[j]]*a[j];
***************
*** 517,523 ****
  void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[m];
  
    MultMv(v,t);
    MultMtv(t,w);
--- 559,565 ----
  void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[this->m];
  
    MultMv(v,t);
    MultMtv(t,w);
***************
*** 531,537 ****
  void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[n];
  
    MultMtv(v,t);
    MultMv(t,w);
--- 573,579 ----
  void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[this->n];
  
    MultMtv(v,t);
    MultMv(t,w);
***************
*** 545,552 ****
  void ARluNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[m],w);
!   MultMtv(v,&w[m]);
  
  } // Mult0MMt0v.
  
--- 587,594 ----
  void ARluNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[this->m],w);
!   MultMtv(v,&w[this->m]);
  
  } // Mult0MMt0v.
  
***************
*** 567,575 ****
    int         info;
    SuperMatrix B;
  
!   if (&v != &w) copy(n, v, 1, w, 1);
!   Create_Dense_Matrix(&B, n, 1, w, n, DN, GE);
!   gstrs("N", &L, &U, permr, permc, &B, &info);
    Destroy_SuperMatrix_Store(&B); // delete B.Store;
  
  } // MultInvv.
--- 609,620 ----
    int         info;
    SuperMatrix B;
  
!   if (&v != &w) copy(this->n, v, 1, w, 1);
!   Create_Dense_Matrix(&B, this->n, 1, w, this->n, SLU_DN, SLU_GE);
! //  gstrs("N", &L, &U, permr, permc, &B, &info);
!   StatInit(&stat);
!   trans_t trans = NOTRANS;
!   gstrs(trans, &L, &U, permc, permr, &B, &stat, &info);
    Destroy_SuperMatrix_Store(&B); // delete B.Store;
  
  } // MultInvv.
***************
*** 581,593 ****
               double thresholdp, int orderp, bool check)
  {
  
!   m         = np;
!   n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[n]   = nnz;
    threshold = thresholdp;
    order     = orderp;
  
--- 626,638 ----
               double thresholdp, int orderp, bool check)
  {
  
!   this->m         = np;
!   this->n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[this->n]   = nnz;
    threshold = thresholdp;
    order     = orderp;
  
***************
*** 600,613 ****
  
    // Creating SuperMatrix A.
  
!   Create_CompCol_Matrix(&A, n, n, nnz, a, irow, pcol, NC, GE);
  
    // Reserving memory for vectors used in matrix decomposition.
  
!   permc = new int[n];
!   permr = new int[n];
  
!   defined = true;
  
  } // DefineMatrix (square).
  
--- 645,658 ----
  
    // Creating SuperMatrix A.
  
!   Create_CompCol_Matrix(&A, this->n, this->n, nnz, a, irow, pcol, SLU_NC, SLU_GE);
  
    // Reserving memory for vectors used in matrix decomposition.
  
!   permc = new int[this->n];
!   permr = new int[this->n];
  
!   this->defined = true;
  
  } // DefineMatrix (square).
  
***************
*** 617,630 ****
  DefineMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp)
  {
  
!   m       = mp;
!   n       = np;
    nnz     = nnzp;
    a       = ap;
    irow    = irowp;
    pcol    = pcolp;
!   pcol[n] = nnz;
!   defined = true;
    permc   = NULL;
    permr   = NULL;
  
--- 662,675 ----
  DefineMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp)
  {
  
!   this->m       = mp;
!   this->n       = np;
    nnz     = nnzp;
    a       = ap;
    irow    = irowp;
    pcol    = pcolp;
!   pcol[this->n] = nnz;
!   this->defined = true;
    permc   = NULL;
    permr   = NULL;
  
***************
*** 669,675 ****
  
  template<class ARTYPE, class ARFLOAT>
  ARluNonSymMatrix<ARTYPE, ARFLOAT>::
! ARluNonSymMatrix(char* file, double thresholdp, int orderp, bool check)
  {
  
    factored = false;
--- 714,720 ----
  
  template<class ARTYPE, class ARFLOAT>
  ARluNonSymMatrix<ARTYPE, ARFLOAT>::
! ARluNonSymMatrix(const std::string& file, double thresholdp, int orderp, bool check)
  {
  
    factored = false;
diff -crB arpack++/include/arlnspen.h arpack++new/include/arlnspen.h
*** arpack++/include/arlnspen.h	2000-02-22 08:18:59.000000000 -0500
--- arpack++new/include/arlnspen.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARLNSPEN_H
  #define ARLNSPEN_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "blas1c.h"
--- 17,24 ----
  #ifndef ARLNSPEN_H
  #define ARLNSPEN_H
  
! #include <cstddef>
! 
  #include "arch.h"
  #include "arerror.h"
  #include "blas1c.h"
***************
*** 41,46 ****
--- 42,48 ----
    ARluNonSymMatrix<ARTYPE, ARFLOAT>* B;
    SuperMatrix                        L;
    SuperMatrix                        U;
+   SuperLUStat_t stat;
  
    virtual void Copy(const ARluNonSymPencil& other);
  
***************
*** 142,148 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
      delete[] permc;
      delete[] permr;
      permc = NULL;
--- 144,150 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
      delete[] permc;
      delete[] permr;
      permc = NULL;
***************
*** 382,387 ****
--- 384,404 ----
    ARFLOAT drop_tol        = 0.0;
    int   panel_size      = sp_ienv(1);
    int   relax           = sp_ienv(2);
+   superlu_options_t options;
+   /* Set the default input options:
+   options.Fact = DOFACT;
+   options.Equil = YES;
+   options.ColPerm = COLAMD;
+   options.DiagPivotThresh = 1.0;
+   options.Trans = NOTRANS;
+   options.IterRefine = NOREFINE;
+   options.SymmetricMode = NO;
+   options.PivotGrowth = NO;
+   options.ConditionNumber = NO;
+   options.PrintStat = YES;
+   */
+   set_default_options(&options);
+   options.DiagPivotThresh = A->threshold;
  
    // Defining A and B format.
  
***************
*** 395,401 ****
    pcoli = new int[A->ncols()+1];
    asb   = new ARTYPE[nnzi];
    Create_CompCol_Matrix(&AsB, A->nrows(), A->ncols(), nnzi, asb,
!                         irowi, pcoli, NC, GE);
  
    // Subtracting sigma*B from A and storing the result on AsB.
  
--- 412,418 ----
    pcoli = new int[A->ncols()+1];
    asb   = new ARTYPE[nnzi];
    Create_CompCol_Matrix(&AsB, A->nrows(), A->ncols(), nnzi, asb,
!                         irowi, pcoli, SLU_NC, SLU_GE);
  
    // Subtracting sigma*B from A and storing the result on AsB.
  
***************
*** 410,416 ****
  
    // Defining LUStat.
  
!   StatInit(panel_size, relax);
  
    // Defining the column permutation of matrix AsB
    // (using minimum degree ordering on AsB'*AsB).
--- 427,435 ----
  
    // Defining LUStat.
  
! //  StatInit(panel_size, relax);
!     SuperLUStat_t stat;
!     StatInit(&stat);
  
    // Defining the column permutation of matrix AsB
    // (using minimum degree ordering on AsB'*AsB).
***************
*** 420,431 ****
    // Permuting columns of AsB and
    // creating the elimination tree of AsB'*AsB.
  
!   sp_preorder("N", &AsB, permc, etree, &AC);
  
    // Decomposing AsB.
  
!   gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree,
!         NULL, 0, permr, permc, &L, &U, &info);
  
    // Deleting AC, AsB and etree.
  
--- 439,453 ----
    // Permuting columns of AsB and
    // creating the elimination tree of AsB'*AsB.
  
! //  sp_preorder("N", &AsB, permc, etree, &AC);
!   sp_preorder(&options, &AsB, permc, etree, &AC);
  
    // Decomposing AsB.
  
! //  gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree,
! //        NULL, 0, permr, permc, &L, &U, &info);
!   gstrf(&options, &AC, drop_tol, relax, panel_size, etree,
!         NULL, 0, permc, permr, &L, &U, &stat, &info);
  
    // Deleting AC, AsB and etree.
  
***************
*** 495,500 ****
--- 517,538 ----
    ARFLOAT drop_tol      = 0.0;
    int   panel_size      = sp_ienv(1);
    int   relax           = sp_ienv(2);
+   superlu_options_t options;
+   /* Set the default input options:
+   options.Fact = DOFACT;
+   options.Equil = YES;
+   options.ColPerm = COLAMD;
+   options.DiagPivotThresh = 1.0;
+   options.Trans = NOTRANS;
+   options.IterRefine = NOREFINE;
+   options.SymmetricMode = NO;
+   options.PivotGrowth = NO;
+   options.ConditionNumber = NO;
+   options.PrintStat = YES;
+   */
+   set_default_options(&options);
+   options.DiagPivotThresh = A->threshold;
+ 
  
    // Defining A and B format.
  
***************
*** 509,515 ****
    pcoli = new int[A->ncols()+1];
    asb   = new arcomplex<ARFLOAT>[nnzi];
    Create_CompCol_Matrix(&AsB, A->nrows(), A->ncols(), nnzi, asb,
!                         irowi, pcoli, NC, GE);
  
    // Subtracting sigma*B from A and storing the result on AsB.
  
--- 547,553 ----
    pcoli = new int[A->ncols()+1];
    asb   = new arcomplex<ARFLOAT>[nnzi];
    Create_CompCol_Matrix(&AsB, A->nrows(), A->ncols(), nnzi, asb,
!                         irowi, pcoli, SLU_NC, SLU_GE);
  
    // Subtracting sigma*B from A and storing the result on AsB.
  
***************
*** 524,530 ****
  
    // Defining LUStat.
  
!   StatInit(panel_size, relax);
  
    // Defining the column permutation of matrix AsB
    // (using minimum degree ordering on AsB'*AsB).
--- 562,570 ----
  
    // Defining LUStat.
  
! //  StatInit(panel_size, relax);
!   SuperLUStat_t stat;
!   StatInit(&stat);
  
    // Defining the column permutation of matrix AsB
    // (using minimum degree ordering on AsB'*AsB).
***************
*** 534,545 ****
    // Permuting columns of AsB and
    // creating the elimination tree of AsB'*AsB.
  
!   sp_preorder("N", &AsB, permc, etree, &AC);
  
    // Decomposing AsB.
  
!   gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree, NULL,
!         0, permr, permc, &L, &U, &info);
  
    // Deleting AC, AsB and etree.
  
--- 574,588 ----
    // Permuting columns of AsB and
    // creating the elimination tree of AsB'*AsB.
  
!   //sp_preorder("N", &AsB, permc, etree, &AC);
!   sp_preorder(&options, &AsB, permc, etree, &AC);
  
    // Decomposing AsB.
  
! //  gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree, NULL,
! //        0, permr, permc, &L, &U, &info);
!   gstrf(&options, &AC, drop_tol, relax, panel_size, etree,
!         NULL, 0, permc, permr, &L, &U, &stat, &info);
  
    // Deleting AC, AsB and etree.
  
***************
*** 600,607 ****
    SuperMatrix RHS;
  
    copy(A->nrows(), v, 1, w, 1);
!   Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), DN, GE);
!   gstrs("N", &L, &U, permr, permc, &RHS, &info);
  
    Destroy_SuperMatrix_Store(&RHS); // delete RHS.Store;
  
--- 643,654 ----
    SuperMatrix RHS;
  
    copy(A->nrows(), v, 1, w, 1);
!   Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), SLU_DN, SLU_GE);
! //  gstrs("N", &L, &U, permr, permc, &RHS, &info);
!   trans_t trans = NOTRANS;
!   StatInit(&stat);
! 
!   gstrs(trans, &L, &U, permc, permr, &RHS, &stat, &info);
  
    Destroy_SuperMatrix_Store(&RHS); // delete RHS.Store;
  
***************
*** 629,636 ****
    if (part == 'N') {    // shift is real.
  
      copy(A->nrows(), v, 1, w, 1);
!     Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), DN, GE);
!     gstrs("N", &L, &U, permr, permc, &RHS, &info);
  
    }
    else {                // shift is complex.
--- 676,686 ----
    if (part == 'N') {    // shift is real.
  
      copy(A->nrows(), v, 1, w, 1);
!     Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), SLU_DN, SLU_GE);
!     //gstrs("N", &L, &U, permr, permc, &RHS, &info);
!     trans_t trans = NOTRANS;
!     StatInit(&stat);
!     gstrs(trans, &L, &U, permc, permr, &RHS, &stat, &info);
  
    }
    else {                // shift is complex.
***************
*** 641,648 ****
      arcomplex<ARFLOAT> *tv = new arcomplex<ARFLOAT>[A->ncols()];
  
      for (i=0; i!=A->ncols(); i++) tv[i] = arcomplex<ARFLOAT>(v[i],0.0);
!     Create_Dense_Matrix(&RHS, A->ncols(), 1, tv, A->ncols(), DN, GE);
!     gstrs("N", &L, &U, permr, permc, &RHS, &info);
  
      if (part=='I') {
        for (i=0; i!=A->ncols(); i++) w[i] = imag(tv[i]);
--- 691,702 ----
      arcomplex<ARFLOAT> *tv = new arcomplex<ARFLOAT>[A->ncols()];
  
      for (i=0; i!=A->ncols(); i++) tv[i] = arcomplex<ARFLOAT>(v[i],0.0);
!     Create_Dense_Matrix(&RHS, A->ncols(), 1, tv, A->ncols(), SLU_DN, SLU_GE);
!     //gstrs("N", &L, &U, permr, permc, &RHS, &info);
!     trans_t trans = NOTRANS;
!     StatInit(&stat);
!     gstrs(trans, &L, &U, permc, permr, &RHS, &stat, &info);
! 
  
      if (part=='I') {
        for (i=0; i!=A->ncols(); i++) w[i] = imag(tv[i]);
diff -crB arpack++/include/arlscomp.h arpack++new/include/arlscomp.h
*** arpack++/include/arlscomp.h	2000-02-20 19:28:44.000000000 -0500
--- arpack++new/include/arlscomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARLSCOMP_H
  #define ARLSCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arscomp.h"
  #include "arlnsmat.h"
--- 18,25 ----
  #ifndef ARLSCOMP_H
  #define ARLSCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arscomp.h"
  #include "arlnsmat.h"
***************
*** 58,70 ****
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 59,71 ----
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 97,103 ****
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
      Copy(other);
!   if (mode > 2) objOP->FactorAsI(sigmaR);
  
  } // Copy.
  
--- 98,104 ----
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
      Copy(other);
!   if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
  
  } // Copy.
  
***************
*** 106,112 ****
  inline void ARluCompStdEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
  {
  
!   objOP->FactorAsI(sigmap);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
  
  } // ChangeShift.
--- 107,113 ----
  inline void ARluCompStdEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
  {
  
!   this->objOP->FactorAsI(sigmap);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
  
  } // ChangeShift.
***************
*** 118,124 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetRegularMode(objOP, 
                     &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
--- 119,125 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetRegularMode(this->objOP, 
                     &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
***************
*** 131,137 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP,
                         &ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 132,138 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP,
                         &ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 140,152 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                char* whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A,
                     &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 141,153 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                const std::string& whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A,
                     &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 156,168 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A,
                     &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
--- 157,169 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A,
                     &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
***************
*** 176,182 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 177,183 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arlsmat.h arpack++new/include/arlsmat.h
*** arpack++/include/arlsmat.h	2000-02-22 08:19:46.000000000 -0500
--- arpack++new/include/arlsmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARLSMAT_H
  #define ARLSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
--- 20,27 ----
  #ifndef ARLSMAT_H
  #define ARLSMAT_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
***************
*** 53,58 ****
--- 54,60 ----
    SuperMatrix L;
    SuperMatrix U;
    ARhbMatrix<int, ARTYPE> mat;
+   SuperLUStat_t stat;
  
    bool DataOK();
  
***************
*** 88,94 ****
                  int orderp = 2, bool check = true);
    // Long constructor.
  
!   ARluSymMatrix(char* name, double thresholdp = 0.1,
                  int orderp = 2, bool check = true);
    // Long constructor (Harwell-Boeing file).
  
--- 90,96 ----
                  int orderp = 2, bool check = true);
    // Long constructor.
  
!   ARluSymMatrix(const std::string& name, double thresholdp = 0.1,
                  int orderp = 2, bool check = true);
    // Long constructor (Harwell-Boeing file).
  
***************
*** 117,128 ****
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
--- 119,130 ----
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=this->n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=this->n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
***************
*** 130,136 ****
          if ((irow[j]<0)||(irow[k]>i)) return false;
        }
        else { // uplo == 'L'.
!         if ((irow[j]<i)||(irow[k]>=n)) return false;
        }
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
--- 132,138 ----
          if ((irow[j]<0)||(irow[k]>i)) return false;
        }
        else { // uplo == 'L'.
!         if ((irow[j]<i)||(irow[k]>=this->n)) return false;
        }
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
***************
*** 148,159 ****
  
    // Copying very fundamental variables.
  
!   defined   = other.defined;
    factored  = other.factored;
  
    // Returning from here if "other" was not initialized.
  
!   if (!defined) return;
  
    // Copying user-defined parameters.
  
--- 150,161 ----
  
    // Copying very fundamental variables.
  
!   this->defined   = other.defined;
    factored  = other.factored;
  
    // Returning from here if "other" was not initialized.
  
!   if (!this->defined) return;
  
    // Copying user-defined parameters.
  
***************
*** 181,189 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
    }
!   if (defined) {
      Destroy_SuperMatrix_Store(&A); // delete A.Store;
      delete[] permc;
      delete[] permr;
--- 183,191 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
    }
!   if (this->defined) {
      Destroy_SuperMatrix_Store(&A); // delete A.Store;
      delete[] permc;
      delete[] permr;
***************
*** 223,235 ****
  
    // Filling colE with zeros.
  
!   for (i=0; i<=n; i++) colE[i] = 0;
  
    // Counting the elements in each column of A.
  
    if (uplo == 'U') {
  
!     for (i=0; i!=n; i++) {
        k = colA[i+1];
        if ((k!=colA[i])&&(indA[k-1]==i)) {
          k--;
--- 225,237 ----
  
    // Filling colE with zeros.
  
!   for (i=0; i<=this->n; i++) colE[i] = 0;
  
    // Counting the elements in each column of A.
  
    if (uplo == 'U') {
  
!     for (i=0; i!=this->n; i++) {
        k = colA[i+1];
        if ((k!=colA[i])&&(indA[k-1]==i)) {
          k--;
***************
*** 243,249 ****
    }
    else { // uplo == 'L'
  
!     for (i=0; i!=n; i++) {
        k = colA[i];
        if ((k!=colA[i+1])&&(indA[k]==i)) {
          k++;
--- 245,251 ----
    }
    else { // uplo == 'L'
  
!     for (i=0; i!=this->n; i++) {
        k = colA[i];
        if ((k!=colA[i+1])&&(indA[k]==i)) {
          k++;
***************
*** 258,275 ****
  
    // Summing up colE elements.
  
!   for (i=0; i<n; i++) colE[i+1]+=colE[i];
  
    // Adding colA to colE.
  
!   for (i=n; i>0; i--) colE[i] = colE[i-1]+colA[i];
    colE[0] = colA[0];    
  
    // Expanding A.
  
    if (uplo == 'U') {
  
!     for (i=0; i<n; i++) {
        for (j=colA[i]; j<(colA[i+1]-1); j++) {
          indE[colE[i]] = indA[j];
          indE[colE[indA[j]]] = i; 
--- 260,277 ----
  
    // Summing up colE elements.
  
!   for (i=0; i<this->n; i++) colE[i+1]+=colE[i];
  
    // Adding colA to colE.
  
!   for (i=this->n; i>0; i--) colE[i] = colE[i-1]+colA[i];
    colE[0] = colA[0];    
  
    // Expanding A.
  
    if (uplo == 'U') {
  
!     for (i=0; i<this->n; i++) {
        for (j=colA[i]; j<(colA[i+1]-1); j++) {
          indE[colE[i]] = indA[j];
          indE[colE[indA[j]]] = i; 
***************
*** 296,302 ****
    }
    else { // uplo  == 'L'
  
!     for (i=0; i<n; i++) {
        k=colA[i];
        if ((k!=colA[i+1])&&(indA[k]==i)) {
          indE[colE[i]] = i;
--- 298,304 ----
    }
    else { // uplo  == 'L'
  
!     for (i=0; i<this->n; i++) {
        k=colA[i];
        if ((k!=colA[i+1])&&(indA[k]==i)) {
          indE[colE[i]] = i;
***************
*** 326,337 ****
  
    // Adjusting index.
  
!   for (i=n; i>0; i--) {
      colE[i] = colE[i-1];
    } 
    colE[0] = 0;
  
!   Aexp.nnz = colE[n];
  
  } // ExpandA.
  
--- 328,339 ----
  
    // Adjusting index.
  
!   for (i=this->n; i>0; i--) {
      colE[i] = colE[i-1];
    } 
    colE[0] = 0;
  
!   Aexp.nnz = colE[this->n];
  
  } // ExpandA.
  
***************
*** 342,348 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorA");
    }
  
--- 344,350 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorA");
    }
  
***************
*** 363,369 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
    }
  
    // Setting default values for gstrf parameters.
--- 365,371 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
    }
  
    // Setting default values for gstrf parameters.
***************
*** 371,383 ****
    double drop_tol   = 0.0;
    int    panel_size = sp_ienv(1);
    int    relax      = sp_ienv(2);
  
    // Creating a temporary matrix Aexp.
  
    irowi = new int[nnz*2];
!   pcoli = new int[n+1];
    aexp  = new ARTYPE[nnz*2];
!   Create_CompCol_Matrix(&Aexp, n,  n, nnz, aexp, irowi, pcoli, NC, GE);
  
    // Expanding A.
  
--- 373,406 ----
    double drop_tol   = 0.0;
    int    panel_size = sp_ienv(1);
    int    relax      = sp_ienv(2);
+   superlu_options_t options;
+ 
+   /* Set the default input options:
+   options.Fact = DOFACT;
+   options.Equil = YES;
+   options.ColPerm = COLAMD;
+   options.DiagPivotThresh = 1.0;
+   options.Trans = NOTRANS;
+   options.IterRefine = NOREFINE;
+   options.SymmetricMode = NO;
+   options.PivotGrowth = NO;
+   options.ConditionNumber = NO;
+   options.PrintStat = YES;
+   */
+   set_default_options(&options);
+ 
+   /* Now we modify the default options to use the symmetric mode. */
+   options.SymmetricMode = YES;
+   options.ColPerm = MMD_AT_PLUS_A;
+   // options.DiagPivotThresh = 0.001;
+   options.DiagPivotThresh = threshold;
  
    // Creating a temporary matrix Aexp.
  
    irowi = new int[nnz*2];
!   pcoli = new int[this->n+1];
    aexp  = new ARTYPE[nnz*2];
!   Create_CompCol_Matrix(&Aexp, this->n,  this->n, nnz, aexp, irowi, pcoli, SLU_NC, SLU_GE);
  
    // Expanding A.
  
***************
*** 387,397 ****
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[n];
  
    // Defining LUStat.
  
!   StatInit(panel_size, relax);
  
    // Defining the column permutation of matrix A
    // (using minimum degree ordering).
--- 410,421 ----
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[this->n];
  
    // Defining LUStat.
  
!   //StatInit(panel_size, relax);
!   StatInit(&stat);
  
    // Defining the column permutation of matrix A
    // (using minimum degree ordering).
***************
*** 400,411 ****
  
    // Permuting columns of A and creating the elimination tree.
  
!   sp_preorder("N", &Aexp, permc, etree, &AC);
  
    // Decomposing A.
  
!   gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
!         NULL, 0, permr, permc, &L, &U, &info);
  
    // Deleting AC, Aexp and etree.
  
--- 424,438 ----
  
    // Permuting columns of A and creating the elimination tree.
  
!   //sp_preorder("N", &Aexp, permc, etree, &AC);
!   sp_preorder(&options, &Aexp, permc, etree, &AC);
  
    // Decomposing A.
  
! //  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
! //        NULL, 0, permr, permc, &L, &U, &info);
!   gstrf(&options,&AC, drop_tol, relax, panel_size, etree,
!         NULL, 0, permc, permr, &L, &U, &stat, &info);
  
    // Deleting AC, Aexp and etree.
  
***************
*** 421,427 ****
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluSymMatrix::FactorA");
    }
!   else if (info > n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluSymMatrix::FactorA");
    }
--- 448,454 ----
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluSymMatrix::FactorA");
    }
!   else if (info > this->n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluSymMatrix::FactorA");
    }
***************
*** 439,445 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorAsI");
    }
  
--- 466,472 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorAsI");
    }
  
***************
*** 460,466 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
    }
  
    // Setting default values for gstrf parameters.
--- 487,493 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
    }
  
    // Setting default values for gstrf parameters.
***************
*** 468,480 ****
    double drop_tol   = 0.0;
    int    panel_size = sp_ienv(1);
    int    relax      = sp_ienv(2);
  
    // Creating a temporary matrix AsI.
  
!   irowi = new int[nnz*2+n];
!   pcoli = new int[n+1];
!   asi   = new ARTYPE[nnz*2+n];
!   Create_CompCol_Matrix(&AsI, n,  n, nnz, asi, irowi, pcoli, NC, GE);
  
    // Subtracting sigma*I from A and storing the result on AsI.
  
--- 495,528 ----
    double drop_tol   = 0.0;
    int    panel_size = sp_ienv(1);
    int    relax      = sp_ienv(2);
+   superlu_options_t options;
+ 
+   /* Set the default input options:
+   options.Fact = DOFACT;
+   options.Equil = YES;
+   options.ColPerm = COLAMD;
+   options.DiagPivotThresh = 1.0;
+   options.Trans = NOTRANS;
+   options.IterRefine = NOREFINE;
+   options.SymmetricMode = NO;
+   options.PivotGrowth = NO;
+   options.ConditionNumber = NO;
+   options.PrintStat = YES;
+   */
+   set_default_options(&options);
+ 
+   /* Now we modify the default options to use the symmetric mode. */
+   options.SymmetricMode = YES;
+   options.ColPerm = MMD_AT_PLUS_A;
+   // options.DiagPivotThresh = 0.001;
+   options.DiagPivotThresh = threshold;
  
    // Creating a temporary matrix AsI.
  
!   irowi = new int[nnz*2+this->n];
!   pcoli = new int[this->n+1];
!   asi   = new ARTYPE[nnz*2+this->n];
!   Create_CompCol_Matrix(&AsI, this->n,  this->n, nnz, asi, irowi, pcoli, SLU_NC, SLU_GE);
  
    // Subtracting sigma*I from A and storing the result on AsI.
  
***************
*** 484,494 ****
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[n];
  
    // Defining LUStat.
  
!   StatInit(panel_size, relax);
  
    // Defining the column permutation of matrix AsI
    // (using minimum degree ordering).
--- 532,543 ----
  
    // Reserving memory for etree (used in matrix decomposition).
  
!   etree = new int[this->n];
  
    // Defining LUStat.
  
!   //StatInit(panel_size, relax);
!   StatInit(&stat);
  
    // Defining the column permutation of matrix AsI
    // (using minimum degree ordering).
***************
*** 497,508 ****
  
    // Permuting columns of AsI and creating the elimination tree.
  
!   sp_preorder("N", &AsI, permc, etree, &AC);
  
    // Decomposing AsI.
  
!   gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
!         NULL, 0, permr, permc, &L, &U, &info);
  
    // Deleting AC, AsI and etree.
  
--- 546,559 ----
  
    // Permuting columns of AsI and creating the elimination tree.
  
!   sp_preorder(&options, &AsI, permc, etree, &AC);
  
    // Decomposing AsI.
  
! //  gstrf("N",&AC, threshold, drop_tol, relax, panel_size, etree,
! //        NULL, 0, permr, permc, &L, &U, &info);
!   gstrf(&options,&AC, drop_tol, relax, panel_size, etree,
!         NULL, 0, permc, permr, &L, &U, &stat, &info);
  
    // Deleting AC, AsI and etree.
  
***************
*** 518,524 ****
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluSymMatrix::FactorAsI");
    }
!   else if (info > n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluSymMatrix::FactorAsI");
    }
--- 569,575 ----
      throw ArpackError(ArpackError::PARAMETER_ERROR,
                        "ARluSymMatrix::FactorAsI");
    }
!   else if (info > this->n) {    // Memory is not sufficient.
      throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                        "ARluSymMatrix::FactorAsI");
    }
***************
*** 539,555 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
  
    if (uplo == 'U') {
  
!     for (i=0; i!=n; i++) {
        t = v[i];
        k = pcol[i+1];
        if ((k!=pcol[i])&&(irow[k-1]==i)) {
--- 590,606 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
  
    if (uplo == 'U') {
  
!     for (i=0; i!=this->n; i++) {
        t = v[i];
        k = pcol[i+1];
        if ((k!=pcol[i])&&(irow[k-1]==i)) {
***************
*** 565,571 ****
    }
    else {
  
!     for (i=0; i!=n; i++) {
        t = v[i];
        k = pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
--- 616,622 ----
    }
    else {
  
!     for (i=0; i!=this->n; i++) {
        t = v[i];
        k = pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
***************
*** 599,607 ****
    int         info;
    SuperMatrix B;
  
!   if (&v != &w) copy(n, v, 1, w, 1);
!   Create_Dense_Matrix(&B, n, 1, w, n, DN, GE);
!   gstrs("N", &L, &U, permr, permc, &B, &info);
    Destroy_SuperMatrix_Store(&B); // delete B.Store;
  
  } // MultInvv.
--- 650,661 ----
    int         info;
    SuperMatrix B;
  
!   if (&v != &w) copy(this->n, v, 1, w, 1);
!   Create_Dense_Matrix(&B, this->n, 1, w, this->n, SLU_DN, SLU_GE);
! //  gstrs("N", &L, &U, permr, permc, &B, &info);
!   StatInit(&stat);
!   trans_t trans = NOTRANS;
!   gstrs(trans, &L, &U, permc, permr, &B, &stat, &info);
    Destroy_SuperMatrix_Store(&B); // delete B.Store;
  
  } // MultInvv.
***************
*** 613,625 ****
               char uplop, double thresholdp, int orderp, bool check)
  {
  
!   m         = np;
!   n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[n]   = nnz;
    uplo      = uplop;
    threshold = thresholdp;
    order     = orderp;
--- 667,679 ----
               char uplop, double thresholdp, int orderp, bool check)
  {
  
!   this->m         = np;
!   this->n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[this->n]   = nnz;
    uplo      = uplop;
    threshold = thresholdp;
    order     = orderp;
***************
*** 633,646 ****
  
    // Creating SuperMatrix A.
  
!   Create_CompCol_Matrix(&A, n, n, nnz, a, irow, pcol, NC, GE);
  
    // Reserving memory for vectors used in matrix decomposition.
  
!   permc = new int[n];
!   permr = new int[n];
  
!   defined = true;
  
  } // DefineMatrix.
  
--- 687,700 ----
  
    // Creating SuperMatrix A.
  
!   Create_CompCol_Matrix(&A, this->n, this->n, nnz, a, irow, pcol, SLU_NC, SLU_GE);
  
    // Reserving memory for vectors used in matrix decomposition.
  
!   permc = new int[this->n];
!   permr = new int[this->n];
  
!   this->defined = true;
  
  } // DefineMatrix.
  
***************
*** 671,677 ****
  
  template<class ARTYPE>
  ARluSymMatrix<ARTYPE>::
! ARluSymMatrix(char* file, double thresholdp, int orderp, bool check)
  {
  
    factored = false;
--- 725,731 ----
  
  template<class ARTYPE>
  ARluSymMatrix<ARTYPE>::
! ARluSymMatrix(const std::string& file, double thresholdp, int orderp, bool check)
  {
  
    factored = false;
diff -crB arpack++/include/arlsnsym.h arpack++new/include/arlsnsym.h
*** arpack++/include/arlsnsym.h	2000-02-20 19:22:42.000000000 -0500
--- arpack++new/include/arlsnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARLSNSYM_H
  #define ARLSNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arsnsym.h"
  #include "arlnsmat.h"
--- 18,25 ----
  #ifndef ARLSNSYM_H
  #define ARLSNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arsnsym.h"
  #include "arlnsmat.h"
***************
*** 55,67 ****
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 56,68 ----
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 91,97 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >:: Copy(other);
!   if (mode > 2) objOP->FactorAsI(sigmaR);
  
  } // Copy.
  
--- 92,98 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >:: Copy(other);
!   if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
  
  } // Copy.
  
***************
*** 100,112 ****
  inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 101,113 ----
  inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = 0.0;
!   this->mode      = 3;
!   this->iparam[7] = this->mode;
  
!   this->objOP->FactorAsI(this->sigmaR);
!   this->Restart();
  
  } // ChangeShift.
  
***************
*** 116,122 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode(objOP, &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 117,123 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode(this->objOP, &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 126,132 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, 
                         &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 127,133 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP, 
                         &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 135,147 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A, 
                     &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
--- 136,148 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A, 
                     &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 151,162 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, 
                     &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
--- 152,163 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, 
                     &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
***************
*** 170,176 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 171,177 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arlspdef.h arpack++new/include/arlspdef.h
*** arpack++/include/arlspdef.h	2000-02-20 19:35:28.000000000 -0500
--- arpack++new/include/arlspdef.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 3,10 ****
     c++ interface to ARPACK code.
  
     MODULE ARLSpDef.h.
!    ALTERED version of ssp_defs.h, dsp_defs.h, csp_defs.h 
!    and zsp_defs.h (from SuperLU package).
  */
  
  
--- 3,10 ----
     c++ interface to ARPACK code.
  
     MODULE ARLSpDef.h.
!    ALTERED version of slu_sdefs.h slu_ddefs.h slu_cdefs.h slu_zdefs.h 
!    (from SuperLU 3.0 package).
  */
  
  
***************
*** 19,37 ****
  #include "arlnames.h"
  #include "arlsupm.h"
  #include "arlcomp.h"
  #ifdef _CRAY
  #include <fortran.h>
  #include <string.h>
  #endif
  
! /* No of marker arrays used in the symbolic factorization,
!    each of size n */
! #define NO_MARKER     3
! #define NUM_TEMPV(m,w,t,b)  ( MAX(m, (t + b)*w) )
! 
! typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;
! typedef enum {HEAD, TAIL}              stack_end_t;
! typedef enum {SYSTEM, USER}            LU_space_t;
  
  /*
   * Global data structures used in LU factorization -
--- 19,41 ----
  #include "arlnames.h"
  #include "arlsupm.h"
  #include "arlcomp.h"
+ #include "arlutil.h"
  #ifdef _CRAY
  #include <fortran.h>
  #include <string.h>
  #endif
  
! /* Define my integer type int_t */
! typedef int int_t; /* default */
! 
! // /* No of marker arrays used in the symbolic factorization,
! //    each of size n */
! // #define NO_MARKER     3
! // #define NUM_TEMPV(m,w,t,b)  ( MAX(m, (t + b)*w) )
! // 
! // typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;
! // typedef enum {HEAD, TAIL}              stack_end_t;
! // typedef enum {SYSTEM, USER}            LU_space_t;
  
  /*
   * Global data structures used in LU factorization -
***************
*** 85,91 ****
   *	xusub[i] points to the starting location of column i in ucol.
   *	Storage: new row subscripts; that is subscripts of PA.
   */
! 
  typedef struct {
      int     *xsup;    /* supernode and column mapping */
      int     *supno;   
--- 89,95 ----
   *	xusub[i] points to the starting location of column i in ucol.
   *	Storage: new row subscripts; that is subscripts of PA.
   */
!  
  typedef struct {
      int     *xsup;    /* supernode and column mapping */
      int     *supno;   
***************
*** 154,178 ****
      LU_space_t MemModel; /* 0 - system malloc'd; 1 - user provided */
  } zGlobalLU_t;
  
! typedef struct {
!     int panel_size;
!     int relax;
!     float diag_pivot_thresh;
!     float drop_tol;
! } sfactor_param_t;
! 
! typedef struct {
!     int panel_size;
!     int relax;
!     double diag_pivot_thresh;
!     double drop_tol;
! } dfactor_param_t;
! 
! typedef struct {
!     float for_lu;
!     float total_needed;
!     int   expansions;
! } mem_usage_t;
  
  #ifdef __cplusplus
  extern "C" {
--- 158,182 ----
      LU_space_t MemModel; /* 0 - system malloc'd; 1 - user provided */
  } zGlobalLU_t;
  
! // typedef struct {
! //     int panel_size;
! //     int relax;
! //     float diag_pivot_thresh;
! //     float drop_tol;
! // } sfactor_param_t;
! // 
! // typedef struct {
! //     int panel_size;
! //     int relax;
! //     double diag_pivot_thresh;
! //     double drop_tol;
! // } dfactor_param_t;
! //
! //typedef struct {
! //    float for_lu;
! //    float total_needed;
! //    int   expansions;
! //} mem_usage_t;
  
  #ifdef __cplusplus
  extern "C" {
***************
*** 180,220 ****
  
  /* Driver routines */
  extern void
! sgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
! 	SuperMatrix *, int *);
  extern void
! dgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
! 	SuperMatrix *, int *);
  extern void
! cgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
! 	SuperMatrix *, int *);
  extern void
! zgssv(SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
! 	SuperMatrix *, int *);
! extern void
! sgssvx(char *, char *, char *, SuperMatrix *, sfactor_param_t *,
!        int *, int *, int *, char *, float *, float *,
!        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
!        SuperMatrix *, float *, float *, float *,
!        float *, mem_usage_t *, int *);
! extern void
! dgssvx(char *, char *, char *, SuperMatrix *, dfactor_param_t *,
!        int *, int *, int *, char *, double *, double *,
!        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
!        SuperMatrix *, double *, double *, double *,
!        double *, mem_usage_t *, int *);
! extern void
! cgssvx(char *, char *, char *, SuperMatrix *, sfactor_param_t *,
!        int *, int *, int *, char *, float *, float *,
!        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
!        SuperMatrix *, float *, float *, float *,
!        float *, mem_usage_t *, int *);
! extern void
! zgssvx(char *, char *, char *, SuperMatrix *, dfactor_param_t *,
!        int *, int *, int *, char *, double *, double *,
!        SuperMatrix *, SuperMatrix *, void *, int, SuperMatrix *, 
!        SuperMatrix *, double *, double *, double *,
!        double *, mem_usage_t *, int *);
  
  /* Supernodal LU factor related */
  extern void
--- 184,224 ----
  
  /* Driver routines */
  extern void
! sgssv(superlu_options_t *, SuperMatrix *, int *, int *, SuperMatrix *,
!       SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *);
  extern void
! dgssv(superlu_options_t *, SuperMatrix *, int *, int *, SuperMatrix *,
!       SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *);
  extern void
! cgssv(superlu_options_t *, SuperMatrix *, int *, int *, SuperMatrix *,
!       SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *);
  extern void
! zgssv(superlu_options_t *, SuperMatrix *, int *, int *, SuperMatrix *,
!       SuperMatrix *, SuperMatrix *, SuperLUStat_t *, int *);
! extern void
! sgssvx(superlu_options_t *, SuperMatrix *, int *, int *, int *,
!        char *, float *, float *, SuperMatrix *, SuperMatrix *,
!        void *, int, SuperMatrix *, SuperMatrix *,
!        float *, float *, float *, float *,
!        mem_usage_t *, SuperLUStat_t *, int *);
! extern void
! dgssvx(superlu_options_t *, SuperMatrix *, int *, int *, int *,
!        char *, double *, double *, SuperMatrix *, SuperMatrix *,
!        void *, int, SuperMatrix *, SuperMatrix *,
!        double *, double *, double *, double *,
!        mem_usage_t *, SuperLUStat_t *, int *);
! extern void
! cgssvx(superlu_options_t *, SuperMatrix *, int *, int *, int *,
!        char *, float *, float *, SuperMatrix *, SuperMatrix *,
!        void *, int, SuperMatrix *, SuperMatrix *,
!        float *, float *, float *, float *,
!        mem_usage_t *, SuperLUStat_t *, int *);
! extern void
! zgssvx(superlu_options_t *, SuperMatrix *, int *, int *, int *,
!        char *, double *, double *, SuperMatrix *, SuperMatrix *,
!        void *, int, SuperMatrix *, SuperMatrix *,
!        double *, double *, double *, double *,
!        mem_usage_t *, SuperLUStat_t *, int *);
  
  /* Supernodal LU factor related */
  extern void
***************
*** 230,235 ****
--- 234,251 ----
  zCreate_CompCol_Matrix(SuperMatrix *, int, int, int, ldcomplex *,
  		       int *, int *, Stype_t, Dtype_t, Mtype_t);
  extern void
+ sCreate_CompRow_Matrix(SuperMatrix *, int, int, int, float *,
+ 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
+ extern void
+ dCreate_CompRow_Matrix(SuperMatrix *, int, int, int, double *,
+ 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
+ extern void
+ cCreate_CompRow_Matrix(SuperMatrix *, int, int, int, lscomplex *,
+ 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
+ extern void
+ zCreate_CompRow_Matrix(SuperMatrix *, int, int, int, ldcomplex *,
+ 		       int *, int *, Stype_t, Dtype_t, Mtype_t);
+ extern void
  sCopy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
  extern void
  dCopy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
***************
*** 274,305 ****
  extern void
  zCopy_Dense_Matrix(int, int, ldcomplex *, int, ldcomplex *, int);
  
! extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
! extern void    Destroy_CompCol_Matrix(SuperMatrix *);
! extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
! extern void    Destroy_CompCol_Permuted(SuperMatrix *);
! extern void    Destroy_Dense_Matrix(SuperMatrix *);
! extern void    get_perm_c(int, SuperMatrix *, int *);  
! extern void    sp_preorder (char*, SuperMatrix*, int*, int*, SuperMatrix*);
! //  extern void    countnz (const int, int *, int *, int *, sGlobalLU_t *);
! //  extern void    fixupL (const int, const int *, sGlobalLU_t *);
  
  extern void    sallocateA (int, int, float **, int **, int **);
  extern void    dallocateA (int, int, double **, int **, int **);
  extern void    callocateA (int, int, lscomplex **, int **, int **);
  extern void    zallocateA (int, int, ldcomplex **, int **, int **);
! extern void    sgstrf (char*, SuperMatrix*, float, float, int, int, int*,
! 			void *, int, int *, int *, 
!                         SuperMatrix *, SuperMatrix *, int *);
! extern void    dgstrf (char*, SuperMatrix*, double, double, int, int, int*,
! 			void *, int, int *, int *, 
!                         SuperMatrix *, SuperMatrix *, int *);
! extern void    cgstrf (char*, SuperMatrix*, float, float, int, int, int*,
! 			void *, int, int *, int *, 
!                         SuperMatrix *, SuperMatrix *, int *);
! extern void    zgstrf (char*, SuperMatrix*, double, double, int, int, int*,
! 			void *, int, int *, int *, 
!                         SuperMatrix *, SuperMatrix *, int *);
  extern int     ssnode_dfs (const int, const int, const int *, const int *,
  			     const int *, int *, int *, sGlobalLU_t *);
  extern int     dsnode_dfs (const int, const int, const int *, const int *,
--- 290,321 ----
  extern void
  zCopy_Dense_Matrix(int, int, ldcomplex *, int, ldcomplex *, int);
  
! // extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
! // extern void    Destroy_CompCol_Matrix(SuperMatrix *);
! // extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
! // extern void    Destroy_CompCol_Permuted(SuperMatrix *);
! // extern void    Destroy_Dense_Matrix(SuperMatrix *);
! // extern void    get_perm_c(int, SuperMatrix *, int *);  
! // extern void    sp_preorder (char*, SuperMatrix*, int*, int*, SuperMatrix*);
! // //  extern void    countnz (const int, int *, int *, int *, sGlobalLU_t *);
! // //  extern void    fixupL (const int, const int *, sGlobalLU_t *);
  
  extern void    sallocateA (int, int, float **, int **, int **);
  extern void    dallocateA (int, int, double **, int **, int **);
  extern void    callocateA (int, int, lscomplex **, int **, int **);
  extern void    zallocateA (int, int, ldcomplex **, int **, int **);
! extern void    sgstrf (superlu_options_t*, SuperMatrix*, float, 
!                        int, int, int*, void *, int, int *, int *, 
!                        SuperMatrix *, SuperMatrix *, SuperLUStat_t*, int *);
! extern void    dgstrf (superlu_options_t*, SuperMatrix*, double, 
!                        int, int, int*, void *, int, int *, int *, 
!                        SuperMatrix *, SuperMatrix *, SuperLUStat_t*, int *);
! extern void    cgstrf (superlu_options_t*, SuperMatrix*, float, 
!                        int, int, int*, void *, int, int *, int *, 
!                        SuperMatrix *, SuperMatrix *, SuperLUStat_t*, int *);
! extern void    zgstrf (superlu_options_t*, SuperMatrix*, double, 
!                        int, int, int*, void *, int, int *, int *, 
!                        SuperMatrix *, SuperMatrix *, SuperLUStat_t*, int *);
  extern int     ssnode_dfs (const int, const int, const int *, const int *,
  			     const int *, int *, int *, sGlobalLU_t *);
  extern int     dsnode_dfs (const int, const int, const int *, const int *,
***************
*** 330,345 ****
  			   int *, int *, int *, int *, zGlobalLU_t *);
  extern void    spanel_bmod (const int, const int, const int, const int,
                             float *, float *, int *, int *,
! 			   sGlobalLU_t *);
  extern void    dpanel_bmod (const int, const int, const int, const int,
                             double *, double *, int *, int *,
! 			   dGlobalLU_t *);
  extern void    cpanel_bmod (const int, const int, const int, const int,
                             lscomplex *, lscomplex *, int *, int *,
! 			   cGlobalLU_t *);
  extern void    zpanel_bmod (const int, const int, const int, const int,
                             ldcomplex *, ldcomplex *, int *, int *,
! 			   zGlobalLU_t *);
  extern int     scolumn_dfs (const int, const int, int *, int *, int *, int *,
  			   int *, int *, int *, int *, int *, sGlobalLU_t *);
  extern int     dcolumn_dfs (const int, const int, int *, int *, int *, int *,
--- 346,361 ----
  			   int *, int *, int *, int *, zGlobalLU_t *);
  extern void    spanel_bmod (const int, const int, const int, const int,
                             float *, float *, int *, int *,
! 			   sGlobalLU_t *, SuperLUStat_t*);
  extern void    dpanel_bmod (const int, const int, const int, const int,
                             double *, double *, int *, int *,
! 			   dGlobalLU_t *, SuperLUStat_t*);
  extern void    cpanel_bmod (const int, const int, const int, const int,
                             lscomplex *, lscomplex *, int *, int *,
! 			   cGlobalLU_t *, SuperLUStat_t*);
  extern void    zpanel_bmod (const int, const int, const int, const int,
                             ldcomplex *, ldcomplex *, int *, int *,
! 			   zGlobalLU_t *, SuperLUStat_t*);
  extern int     scolumn_dfs (const int, const int, int *, int *, int *, int *,
  			   int *, int *, int *, int *, int *, sGlobalLU_t *);
  extern int     dcolumn_dfs (const int, const int, int *, int *, int *, int *,
***************
*** 349,361 ****
  extern int     zcolumn_dfs (const int, const int, int *, int *, int *, int *,
  			   int *, int *, int *, int *, int *, zGlobalLU_t *);
  extern int     scolumn_bmod (const int, const int, float *,
! 			   float *, int *, int *, int, sGlobalLU_t *);
  extern int     dcolumn_bmod (const int, const int, double *,
! 			   double *, int *, int *, int, dGlobalLU_t *);
  extern int     ccolumn_bmod (const int, const int, lscomplex *,
! 			   lscomplex *, int *, int *, int, cGlobalLU_t *);
  extern int     zcolumn_bmod (const int, const int, ldcomplex *,
! 			   ldcomplex *, int *, int *, int, zGlobalLU_t *);
  extern int     scopy_to_ucol (int, int, int *, int *, int *,
                                float *, sGlobalLU_t *);         
  extern int     dcopy_to_ucol (int, int, int *, int *, int *,
--- 365,377 ----
  extern int     zcolumn_dfs (const int, const int, int *, int *, int *, int *,
  			   int *, int *, int *, int *, int *, zGlobalLU_t *);
  extern int     scolumn_bmod (const int, const int, float *,
! 			   float *, int *, int *, int, sGlobalLU_t *, SuperLUStat_t*);
  extern int     dcolumn_bmod (const int, const int, double *,
! 			   double *, int *, int *, int, dGlobalLU_t *, SuperLUStat_t*);
  extern int     ccolumn_bmod (const int, const int, lscomplex *,
! 			   lscomplex *, int *, int *, int, cGlobalLU_t *, SuperLUStat_t*);
  extern int     zcolumn_bmod (const int, const int, ldcomplex *,
! 			   ldcomplex *, int *, int *, int, zGlobalLU_t *, SuperLUStat_t*);
  extern int     scopy_to_ucol (int, int, int *, int *, int *,
                                float *, sGlobalLU_t *);         
  extern int     dcopy_to_ucol (int, int, int *, int *, int *,
***************
*** 365,377 ****
  extern int     zcopy_to_ucol (int, int, int *, int *, int *,
                                ldcomplex *, zGlobalLU_t *);         
  extern int     spivotL (const int, const float, int *, int *, 
!                               int *, int *, int *, sGlobalLU_t *);
  extern int     dpivotL (const int, const double, int *, int *, 
!                               int *, int *, int *, dGlobalLU_t *);
  extern int     cpivotL (const int, const float, int *, int *, 
!                               int *, int *, int *, cGlobalLU_t *);
  extern int     zpivotL (const int, const double, int *, int *, 
!                               int *, int *, int *, zGlobalLU_t *);
  extern void    spruneL (const int, const int *, const int, const int,
  			     const int *, const int *, int *, sGlobalLU_t *);
  extern void    dpruneL (const int, const int *, const int, const int,
--- 381,393 ----
  extern int     zcopy_to_ucol (int, int, int *, int *, int *,
                                ldcomplex *, zGlobalLU_t *);         
  extern int     spivotL (const int, const float, int *, int *, 
!                               int *, int *, int *, sGlobalLU_t *, SuperLUStat_t*);
  extern int     dpivotL (const int, const double, int *, int *, 
!                               int *, int *, int *, dGlobalLU_t *, SuperLUStat_t*);
  extern int     cpivotL (const int, const float, int *, int *, 
!                               int *, int *, int *, cGlobalLU_t *, SuperLUStat_t*);
  extern int     zpivotL (const int, const double, int *, int *, 
!                               int *, int *, int *, zGlobalLU_t *, SuperLUStat_t*);
  extern void    spruneL (const int, const int *, const int, const int,
  			     const int *, const int *, int *, sGlobalLU_t *);
  extern void    dpruneL (const int, const int *, const int, const int,
***************
*** 388,409 ****
  extern void    dGenXtrue (int, int, double *, int);
  extern void    cGenXtrue (int, int, lscomplex *, int);
  extern void    zGenXtrue (int, int, ldcomplex *, int);
! extern void    sFillRHS (char *, int, float *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    dFillRHS (char *, int, double *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    cFillRHS (char *, int, lscomplex *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    zFillRHS (char *, int, ldcomplex *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    sgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
! 			SuperMatrix *, int *);
! extern void    dgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
! 			SuperMatrix *, int *);
! extern void    cgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
! 			SuperMatrix *, int *);
! extern void    zgstrs (char *, SuperMatrix *, SuperMatrix *, int *, int *,
! 			SuperMatrix *, int *);
  
  
  /* Driver related */
--- 404,425 ----
  extern void    dGenXtrue (int, int, double *, int);
  extern void    cGenXtrue (int, int, lscomplex *, int);
  extern void    zGenXtrue (int, int, ldcomplex *, int);
! extern void    sFillRHS (trans_t, int, float *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    dFillRHS (trans_t, int, double *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    cFillRHS (trans_t, int, lscomplex *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    zFillRHS (trans_t, int, ldcomplex *, int, SuperMatrix *,
  			SuperMatrix *);
! extern void    sgstrs (trans_t, SuperMatrix *, SuperMatrix *, int *, int *,
!                         SuperMatrix *, SuperLUStat_t*, int *);
! extern void    dgstrs (trans_t, SuperMatrix *, SuperMatrix *, int *, int *,
!                         SuperMatrix *, SuperLUStat_t*, int *);
! extern void    cgstrs (trans_t, SuperMatrix *, SuperMatrix *, int *, int *,
!                         SuperMatrix *, SuperLUStat_t*, int *);
! extern void    zgstrs (trans_t, SuperMatrix *, SuperMatrix *, int *, int *,
!                         SuperMatrix *, SuperLUStat_t*, int *);
  
  
  /* Driver related */
***************
*** 425,437 ****
  extern void    zlaqgs (SuperMatrix *, double *, double *, double,
                               double, double, char *);
  extern void    sgscon (char *, SuperMatrix *, SuperMatrix *, 
! 			float, float *, int *);
! extern void    dgscon (char *, SuperMatrix *, SuperMatrix *,
! 			double, double *, int *);
  extern void    cgscon (char *, SuperMatrix *, SuperMatrix *, 
! 			float, float *, int *);
! extern void    zgscon (char *, SuperMatrix *, SuperMatrix *,
! 			double, double *, int *);
  extern float   sPivotGrowth(int, SuperMatrix *, int *, 
                              SuperMatrix *, SuperMatrix *);
  extern double  dPivotGrowth(int, SuperMatrix *, int *, 
--- 441,454 ----
  extern void    zlaqgs (SuperMatrix *, double *, double *, double,
                               double, double, char *);
  extern void    sgscon (char *, SuperMatrix *, SuperMatrix *, 
! 		         float, float *, SuperLUStat_t*, int *);
! extern void    dgscon (char *, SuperMatrix *, SuperMatrix *, 
! 		         double, double *, SuperLUStat_t*, int *);
  extern void    cgscon (char *, SuperMatrix *, SuperMatrix *, 
! 		         float, float *, SuperLUStat_t*, int *);
! extern void    zgscon (char *, SuperMatrix *, SuperMatrix *, 
! 		         double, double *, SuperLUStat_t*, int *);
! 
  extern float   sPivotGrowth(int, SuperMatrix *, int *, 
                              SuperMatrix *, SuperMatrix *);
  extern double  dPivotGrowth(int, SuperMatrix *, int *, 
***************
*** 440,470 ****
                              SuperMatrix *, SuperMatrix *);
  extern double  zPivotGrowth(int, SuperMatrix *, int *, 
                              SuperMatrix *, SuperMatrix *);
! extern void    sgsrfs (char *, SuperMatrix *, SuperMatrix *,
! 			SuperMatrix *, int *, int *, char *, float *, 
! 			float *, SuperMatrix *, SuperMatrix *, float *,
! 			float *, int *);
! extern void    dgsrfs (char *, SuperMatrix *, SuperMatrix *, 
! 			SuperMatrix *, int *, int *, char *, double *,
! 			double *, SuperMatrix *, SuperMatrix *, 
! 			double *, double *, int *);
! extern void    cgsrfs (char *, SuperMatrix *, SuperMatrix *,
! 			SuperMatrix *, int *, int *, char *, float *, 
! 			float *, SuperMatrix *, SuperMatrix *, float *,
! 			float *, int *);
! extern void    zgsrfs (char *, SuperMatrix *, SuperMatrix *, 
! 			SuperMatrix *, int *, int *, char *, double *,
! 			double *, SuperMatrix *, SuperMatrix *, 
! 			double *, double *, int *);
  
  extern int     sp_strsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, float *, int *);
  extern int     sp_dtrsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, double *, int *);
  extern int     sp_ctrsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, lscomplex *, int *);
  extern int     sp_ztrsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, ldcomplex *, int *);
  extern int     sp_sgemv (char *, float, SuperMatrix *, float *,
  			int, float, float *, int);
  extern int     sp_dgemv (char *, double, SuperMatrix *, double *,
--- 457,487 ----
                              SuperMatrix *, SuperMatrix *);
  extern double  zPivotGrowth(int, SuperMatrix *, int *, 
                              SuperMatrix *, SuperMatrix *);
! extern void    sgsrfs (trans_t, SuperMatrix *, SuperMatrix *,
!                        SuperMatrix *, int *, int *, char *, float *, 
!                        float *, SuperMatrix *, SuperMatrix *,
!                        float *, float *, SuperLUStat_t*, int *);
! extern void    dgsrfs (trans_t, SuperMatrix *, SuperMatrix *,
!                        SuperMatrix *, int *, int *, char *, double *, 
!                        double *, SuperMatrix *, SuperMatrix *,
!                        double *, double *, SuperLUStat_t*, int *);
! extern void    cgsrfs (trans_t, SuperMatrix *, SuperMatrix *,
!                        SuperMatrix *, int *, int *, char *, float *, 
!                        float *, SuperMatrix *, SuperMatrix *,
!                        float *, float *, SuperLUStat_t*, int *);
! extern void    zgsrfs (trans_t, SuperMatrix *, SuperMatrix *,
!                        SuperMatrix *, int *, int *, char *, double *, 
!                        double *, SuperMatrix *, SuperMatrix *,
!                        double *, double *, SuperLUStat_t*, int *);
  
  extern int     sp_strsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, float *, SuperLUStat_t*, int *);
  extern int     sp_dtrsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, double *, SuperLUStat_t*, int *);
  extern int     sp_ctrsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, lscomplex *, SuperLUStat_t*, int *);
  extern int     sp_ztrsv (char *, char *, char *, SuperMatrix *,
! 			SuperMatrix *, ldcomplex *, SuperLUStat_t*, int *);
  extern int     sp_sgemv (char *, float, SuperMatrix *, float *,
  			int, float, float *, int);
  extern int     sp_dgemv (char *, double, SuperMatrix *, double *,
***************
*** 488,503 ****
  			ldcomplex *, int);
  
  /* Memory-related */
! extern int     sLUMemInit (char *, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     sGlobalLU_t *, int **, float **);
! extern int     dLUMemInit (char *, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     dGlobalLU_t *, int **, double **);
! extern int     cLUMemInit (char *, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     cGlobalLU_t *, int **, lscomplex **);
! extern int     zLUMemInit (char *, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     zGlobalLU_t *, int **, ldcomplex **);
  extern void    sSetRWork (int, int, float *, float **, float **);
--- 505,520 ----
  			ldcomplex *, int);
  
  /* Memory-related */
! extern int     sLUMemInit (fact_t, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     sGlobalLU_t *, int **, float **);
! extern int     dLUMemInit (fact_t, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     dGlobalLU_t *, int **, double **);
! extern int     cLUMemInit (fact_t, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     cGlobalLU_t *, int **, lscomplex **);
! extern int     zLUMemInit (fact_t, void *, int, int, int, int, int,
  			     SuperMatrix *, SuperMatrix *,
  			     zGlobalLU_t *, int **, ldcomplex **);
  extern void    sSetRWork (int, int, float *, float **, float **);
***************
*** 525,538 ****
  extern int     dmemory_usage(const int, const int, const int, const int);
  extern int     cmemory_usage(const int, const int, const int, const int);
  extern int     zmemory_usage(const int, const int, const int, const int);
! extern int     sQuerySpace (SuperMatrix *, SuperMatrix *, int,
! 				mem_usage_t *);
! extern int     dQuerySpace (SuperMatrix *, SuperMatrix *, int,
! 				mem_usage_t *);
! extern int     cQuerySpace (SuperMatrix *, SuperMatrix *, int,
! 				mem_usage_t *);
! extern int     zQuerySpace (SuperMatrix *, SuperMatrix *, int,
! 				mem_usage_t *);
  
  /* Auxiliary routines */
  extern void    sreadhb(int *, int *, int *, float **, int **, int **);
--- 542,551 ----
  extern int     dmemory_usage(const int, const int, const int, const int);
  extern int     cmemory_usage(const int, const int, const int, const int);
  extern int     zmemory_usage(const int, const int, const int, const int);
! extern int     sQuerySpace (SuperMatrix *, SuperMatrix *, mem_usage_t *);
! extern int     dQuerySpace (SuperMatrix *, SuperMatrix *, mem_usage_t *);
! extern int     cQuerySpace (SuperMatrix *, SuperMatrix *, mem_usage_t *);
! extern int     zQuerySpace (SuperMatrix *, SuperMatrix *, mem_usage_t *);
  
  /* Auxiliary routines */
  extern void    sreadhb(int *, int *, int *, float **, int **, int **);
diff -crB arpack++/include/arlspen.h arpack++new/include/arlspen.h
*** arpack++/include/arlspen.h	2000-02-22 08:20:33.000000000 -0500
--- arpack++new/include/arlspen.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARLSPEN_H
  #define ARLSPEN_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "blas1c.h"
--- 17,24 ----
  #ifndef ARLSPEN_H
  #define ARLSPEN_H
  
! #include <cstddef>
! 
  #include "arch.h"
  #include "arerror.h"
  #include "blas1c.h"
***************
*** 42,47 ****
--- 43,49 ----
    ARluSymMatrix<ARTYPE>* B;
    SuperMatrix            L;
    SuperMatrix            U;
+   SuperLUStat_t stat;
  
    virtual void Copy(const ARluSymPencil& other);
  
***************
*** 125,131 ****
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree();
      delete[] permc;
      delete[] permr;
      permc = NULL;
--- 127,133 ----
    if (factored) {
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
!     StatFree(&stat);
      delete[] permc;
      delete[] permr;
      permc = NULL;
***************
*** 336,341 ****
--- 338,453 ----
  } // SubtractAsB.
  
  
+ // template<class ARTYPE>
+ // void ARluSymPencil<ARTYPE>::FactorAsB(ARTYPE sigma)
+ // {
+ // 
+ //   // Quitting the function if A and B were not defined.
+ // 
+ //   if (!(A->IsDefined()&&B->IsDefined())) {
+ //     throw ArpackError(ArpackError::DATA_UNDEFINED,
+ //                       "ARluSymPencil::FactorAsB");
+ //   }
+ // 
+ //   // Quitting the function if A and B are not square.
+ // 
+ //   if ((A->nrows() != A->ncols()) || (B->nrows() != B->ncols())) {
+ //     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
+ //                       "ARluSymPencil::FactorAsB");
+ //   }
+ // 
+ //   // Defining local variables.
+ // 
+ //   int         nnzi, info;
+ //   int*        etree;
+ //   int*        irowi;
+ //   int*        pcoli;
+ //   ARTYPE*     asb;
+ //   SuperMatrix AsB;
+ //   SuperMatrix AC;
+ //   NCformat*   Astore;
+ //   NCformat*   Bstore;
+ //   NCformat*   AsBstore;
+ // 
+ //   // Deleting old versions of L, U, perm_r and perm_c.
+ // 
+ //   ClearMem();
+ // 
+ //   // Setting default values for gstrf parameters.
+ // 
+ //   ARTYPE drop_tol = (ARTYPE)0;
+ //   int  panel_size = sp_ienv(1);
+ //   int  relax      = sp_ienv(2);
+ // 
+ //   // Defining A and B format.
+ // 
+ //   Astore = (NCformat*)A->A.Store;
+ //   Bstore = (NCformat*)B->A.Store;
+ // 
+ //   // Creating a temporary matrix AsB.
+ // 
+ //   nnzi  = (Astore->nnz+Bstore->nnz)*2;
+ //   irowi = new int[nnzi];
+ //   pcoli = new int[A->ncols()+1];
+ //   asb   = new ARTYPE[nnzi];
+ //   Create_CompCol_Matrix(&AsB, A->nrows(), A->ncols(), nnzi, asb,
+ //                         irowi, pcoli, NC, GE);
+ // 
+ //   // Subtracting sigma*B from A and storing the result on AsB.
+ // 
+ //   AsBstore = (NCformat*)AsB.Store;
+ //   SubtractAsB(A->ncols(), sigma, *Astore, *Bstore, *AsBstore);
+ // 
+ //   // Reserving memory for some vectors used in matrix decomposition.
+ // 
+ //   etree = new int[A->ncols()];
+ //   if (permc == NULL) permc = new int[A->ncols()];
+ //   if (permr == NULL) permr = new int[A->ncols()];
+ // 
+ //   // Defining LUStat.
+ // 
+ //   StatInit(panel_size, relax);
+ // 
+ //   // Defining the column permutation of matrix AsB
+ //   // (using minimum degree ordering on AsB'*AsB).
+ // 
+ //   get_perm_c(A->order, &AsB, permc);
+ // 
+ //   // Permuting columns of AsB and
+ //   // creating the elimination tree of AsB'*AsB.
+ // 
+ //   sp_preorder("N", &AsB, permc, etree, &AC);
+ // 
+ //   // Decomposing AsB.
+ // 
+ //   gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree,
+ //         NULL, 0, permr, permc, &L, &U, &info);
+ // 
+ //   // Deleting AC, AsB and etree.
+ // 
+ //   Destroy_CompCol_Permuted(&AC);
+ //   Destroy_CompCol_Matrix(&AsB);
+ //   delete[] etree;
+ // 
+ //   factored = (info == 0);
+ // 
+ //   // Handling errors.
+ // 
+ //   if (info < 0)  {              // Illegal argument.
+ //     throw ArpackError(ArpackError::PARAMETER_ERROR,
+ //                       "ARluSymPencil::FactorAsB");
+ //   }
+ //   else if (info > A->ncols()) {  // Memory is not sufficient.
+ //     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
+ //                       "ARluSymPencil::FactorAsB");
+ //   }
+ //   else if (info > 0) {          // Matrix is singular.
+ //     throw ArpackError(ArpackError::MATRIX_IS_SINGULAR,
+ //                       "ARluSymPencil::FactorAsB");
+ //   }
+ // 
+ // } // FactorAsB.
+ 
  template<class ARTYPE>
  void ARluSymPencil<ARTYPE>::FactorAsB(ARTYPE sigma)
  {
***************
*** 376,381 ****
--- 488,512 ----
    ARTYPE drop_tol = (ARTYPE)0;
    int  panel_size = sp_ienv(1);
    int  relax      = sp_ienv(2);
+   superlu_options_t options;
+   /* Set the default input options:
+   options.Fact = DOFACT;
+   options.Equil = YES;
+   options.ColPerm = COLAMD;
+   options.DiagPivotThresh = 1.0;
+   options.Trans = NOTRANS;
+   options.IterRefine = NOREFINE;
+   options.SymmetricMode = NO;
+   options.PivotGrowth = NO;
+   options.ConditionNumber = NO;
+   options.PrintStat = YES;
+   */
+   set_default_options(&options);
+ 
+   /* Now we modify the default options to use the symmetric mode. */
+   options.SymmetricMode = YES;
+   options.ColPerm = MMD_AT_PLUS_A;
+   options.DiagPivotThresh = A->threshold;
  
    // Defining A and B format.
  
***************
*** 389,395 ****
    pcoli = new int[A->ncols()+1];
    asb   = new ARTYPE[nnzi];
    Create_CompCol_Matrix(&AsB, A->nrows(), A->ncols(), nnzi, asb,
!                         irowi, pcoli, NC, GE);
  
    // Subtracting sigma*B from A and storing the result on AsB.
  
--- 520,526 ----
    pcoli = new int[A->ncols()+1];
    asb   = new ARTYPE[nnzi];
    Create_CompCol_Matrix(&AsB, A->nrows(), A->ncols(), nnzi, asb,
!                         irowi, pcoli, SLU_NC, SLU_GE);
  
    // Subtracting sigma*B from A and storing the result on AsB.
  
***************
*** 404,410 ****
  
    // Defining LUStat.
  
!   StatInit(panel_size, relax);
  
    // Defining the column permutation of matrix AsB
    // (using minimum degree ordering on AsB'*AsB).
--- 535,543 ----
  
    // Defining LUStat.
  
! //  StatInit(panel_size, relax);
!     SuperLUStat_t stat;
!     StatInit(&stat);
  
    // Defining the column permutation of matrix AsB
    // (using minimum degree ordering on AsB'*AsB).
***************
*** 414,425 ****
    // Permuting columns of AsB and
    // creating the elimination tree of AsB'*AsB.
  
!   sp_preorder("N", &AsB, permc, etree, &AC);
  
    // Decomposing AsB.
  
!   gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree,
!         NULL, 0, permr, permc, &L, &U, &info);
  
    // Deleting AC, AsB and etree.
  
--- 547,560 ----
    // Permuting columns of AsB and
    // creating the elimination tree of AsB'*AsB.
  
!   sp_preorder(&options, &AsB, permc, etree, &AC);
  
    // Decomposing AsB.
  
! //  gstrf("N",&AC, A->threshold, drop_tol, relax, panel_size, etree,
! //        NULL, 0, permr, permc, &L, &U, &info);
!   gstrf(&options, &AC, drop_tol, relax, panel_size, etree,
!         NULL, 0, permc, permr, &L, &U, &stat, &info);
  
    // Deleting AC, AsB and etree.
  
***************
*** 477,484 ****
    SuperMatrix RHS;
  
    copy(A->nrows(), v, 1, w, 1);
!   Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), DN, GE);
!   gstrs("N", &L, &U, permr, permc, &RHS, &info);
  
    Destroy_SuperMatrix_Store(&RHS); // delete RHS.Store;
  
--- 612,623 ----
    SuperMatrix RHS;
  
    copy(A->nrows(), v, 1, w, 1);
!   Create_Dense_Matrix(&RHS, A->nrows(), 1, w, A->nrows(), SLU_DN, SLU_GE);
! //  gstrs("N", &L, &U, permr, permc, &RHS, &info);
!   trans_t trans = NOTRANS;
!   StatInit(&stat);
! 
!   gstrs(trans, &L, &U, permc, permr, &RHS, &stat, &info);
  
    Destroy_SuperMatrix_Store(&RHS); // delete RHS.Store;
  
diff -crB arpack++/include/arlssym.h arpack++new/include/arlssym.h
*** arpack++/include/arlssym.h	2000-03-03 16:13:06.000000000 -0500
--- arpack++new/include/arlssym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 19,25 ****
  #ifndef ARLSSYM_H
  #define ARLSSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arssym.h"
  #include "arlsmat.h"
--- 19,26 ----
  #ifndef ARLSSYM_H
  #define ARLSSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arssym.h"
  #include "arlsmat.h"
***************
*** 57,69 ****
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 58,70 ----
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 92,98 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >:: Copy(other);
!   if (mode > 2) objOP->FactorAsI(sigmaR);
  
  } // Copy.
  
--- 93,99 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >:: Copy(other);
!   if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
  
  } // Copy.
  
***************
*** 101,113 ****
  inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 102,114 ----
  inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = 0.0;
!   this->mode      = 3;
!   this->iparam[7] = this->mode;
  
!   this->objOP->FactorAsI(this->sigmaR);
!   this->Restart();
  
  } // ChangeShift.
  
***************
*** 117,123 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
!     SetRegularMode(objOP, &ARluSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 118,124 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
!     SetRegularMode(this->objOP, &ARluSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 127,133 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, &ARluSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
--- 128,134 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP, &ARluSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
***************
*** 135,146 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
--- 136,147 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
***************
*** 149,160 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
--- 150,161 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
***************
*** 167,173 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 168,174 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arlsupm.h arpack++new/include/arlsupm.h
*** arpack++/include/arlsupm.h	2000-02-20 19:36:26.000000000 -0500
--- arpack++new/include/arlsupm.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 13,45 ****
   * The matrix types are defined as follows. *
   ********************************************/
  typedef enum {
!     NC,        /* column-wise, no supernode */
!     NR,        /* row-wize, no supernode */
!     SC,        /* column-wise, supernode */
!     SR,        /* row-wise, supernode */
!     NCP,       /* column-wise, column-permuted, no supernode 
                    (The consecutive columns of nonzeros, after permutation,
  		   may not be stored  contiguously.) */
!     DN         /* Fortran style column-wise storage for dense matrix */
  } Stype_t;
  
  typedef enum {
!     _S,         /* single */
!     _D,         /* double */
!     _C,         /* single complex */
!     _Z          /* double complex */
  } Dtype_t;
  
  typedef enum {
!     GE,        /* general */
!     TRLU,      /* lower triangular, unit diagonal */
!     TRUU,      /* upper triangular, unit diagonal */
!     TRL,       /* lower triangular */
!     TRU,       /* upper triangular */
!     SYL,       /* symmetric, store lower half */
!     SYU,       /* symmetric, store upper half */
!     HEL,       /* Hermitian, store lower half */
!     HEU        /* Hermitian, store upper half */
  } Mtype_t;
  
  typedef struct {
--- 13,47 ----
   * The matrix types are defined as follows. *
   ********************************************/
  typedef enum {
!     SLU_NC,    /* column-wise, no supernode */
!     SLU_NCP,   /* column-wise, column-permuted, no supernode 
                    (The consecutive columns of nonzeros, after permutation,
  		   may not be stored  contiguously.) */
!     SLU_NR,    /* row-wize, no supernode */
!     SLU_SC,    /* column-wise, supernode */
!     SLU_SCP,   /* supernode, column-wise, permuted */    
!     SLU_SR,    /* row-wise, supernode */
!     SLU_DN,     /* Fortran style column-wise storage for dense matrix */
!     SLU_NR_loc  /* distributed compressed row format  */ 
  } Stype_t;
  
  typedef enum {
!     SLU_S,     /* single */
!     SLU_D,     /* double */
!     SLU_C,     /* single complex */
!     SLU_Z      /* double complex */
  } Dtype_t;
  
  typedef enum {
!     SLU_GE,    /* general */
!     SLU_TRLU,  /* lower triangular, unit diagonal */
!     SLU_TRUU,  /* upper triangular, unit diagonal */
!     SLU_TRL,   /* lower triangular */
!     SLU_TRU,   /* upper triangular */
!     SLU_SYL,   /* symmetric, store lower half */
!     SLU_SYU,   /* symmetric, store upper half */
!     SLU_HEL,   /* Hermitian, store lower half */
!     SLU_HEU    /* Hermitian, store upper half */
  } Mtype_t;
  
  typedef struct {
***************
*** 48,55 ****
  	Dtype_t Dtype; /* Data type. */
  	Mtype_t Mtype; /* Matrix type: describes the mathematical property of 
  			  the matrix. */
! 	int  nrow;     /* number of rows */
! 	int  ncol;     /* number of columns */
  	void *Store;   /* pointer to the actual storage of the matrix */
  } SuperMatrix;
  
--- 50,57 ----
  	Dtype_t Dtype; /* Data type. */
  	Mtype_t Mtype; /* Matrix type: describes the mathematical property of 
  			  the matrix. */
! 	int  nrow;   /* number of rows */
! 	int  ncol;   /* number of columns */
  	void *Store;   /* pointer to the actual storage of the matrix */
  } SuperMatrix;
  
***************
*** 57,119 ****
   * The storage schemes are defined as follows. *
   ***********************************************/
  
! /* Stype == NC (Also known as Harwell-Boeing sparse matrix format (CCS)) */
  typedef struct {
!     int  nnz;	  /* number of nonzeros in the matrix */
!     void *nzval;  /* pointer to array of nonzero values, packed by column */
      int  *rowind; /* pointer to array of row indices of the nonzeros */
      int  *colptr; /* pointer to array of beginning of columns in nzval[] 
!                      and rowind[]  */
!                   /* Note:
! 		     Zero-based indexing is used;
! 		     colptr[] has ncol+1 entries, the last one pointing
! 		         beyond the last column, so that colptr[ncol] = nnz. */
  } NCformat;
  
! /* Stype == NR (Also known as row compressed storage (RCS). */
  typedef struct {
!     int  nnz;	  /* number of nonzeros in the matrix */
!     void *nzval;  /* pointer to array of nonzero values, packed by row */
!     int  *colind; /* pointer to array of column indices of the nonzeros */
      int  *rowptr; /* pointer to array of beginning of rows in nzval[] 
!                      and colind[]  */
!                   /* Note:
! 		     Zero-based indexing is used;
! 		     rowptr[] has nrow+1 entries, the last one pointing
! 		         beyond the last column, so that rowptr[nrow] = nnz. */
  } NRformat;
  
! /* Stype == SC */
  typedef struct {
    int  nnz;	     /* number of nonzeros in the matrix */
!   int  nsuper;       /* number of supernodes, minus 1 */
    void *nzval;       /* pointer to array of nonzero values, packed by column */
!   int  *nzval_colptr;/* pointer to array of beginning of columns in nzval[] */
!   int  *rowind;      /* pointer to array of compressed row indices of 
  			rectangular supernodes */
    int *rowind_colptr;/* pointer to array of beginning of columns in rowind[] */
    int *col_to_sup;   /* col_to_sup[j] is the supernode number to which column 
  			j belongs; mapping from column to supernode number. */
    int *sup_to_col;   /* sup_to_col[s] points to the start of the s-th 
  			supernode; mapping from supernode number to column.
! 		        e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 (ncol=12)
! 		              sup_to_col: 0 1 2 4 7 12            (nsuper=4) */
                       /* Note:
  		        Zero-based indexing is used;
  		        nzval_colptr[], rowind_colptr[], col_to_sup and
  		        sup_to_col[] have ncol+1 entries, the last one
! 		        pointing beyond the last column.         */
  } SCformat;
  
! /* Stype == NCP */
  typedef struct {
      int nnz;	  /* number of nonzeros in the matrix */
      void *nzval;  /* pointer to array of nonzero values, packed by column */
!     int *rowind;  /* pointer to array of row indices of the nonzeros */
  		  /* Note: nzval[]/rowind[] always have the same length */
!     int *colbeg;  /* colbeg[j] points to the beginning of column j in nzval[] 
                       and rowind[]  */
!     int *colend;  /* colend[j] points to one past the last element of column
  		     j in nzval[] and rowind[]  */
  		  /* Note:
  		     Zero-based indexing is used;
--- 59,156 ----
   * The storage schemes are defined as follows. *
   ***********************************************/
  
! /* Stype == SLU_NC (Also known as Harwell-Boeing sparse matrix format) */
  typedef struct {
!     int  nnz;	    /* number of nonzeros in the matrix */
!     void *nzval;    /* pointer to array of nonzero values, packed by column */
      int  *rowind; /* pointer to array of row indices of the nonzeros */
      int  *colptr; /* pointer to array of beginning of columns in nzval[] 
! 		       and rowind[]  */
!                     /* Note:
! 		       Zero-based indexing is used;
! 		       colptr[] has ncol+1 entries, the last one pointing
! 		       beyond the last column, so that colptr[ncol] = nnz. */
  } NCformat;
  
! /* Stype == SLU_NR */
  typedef struct {
!     int  nnz;	    /* number of nonzeros in the matrix */
!     void *nzval;    /* pointer to array of nonzero values, packed by raw */
!     int  *colind; /* pointer to array of columns indices of the nonzeros */
      int  *rowptr; /* pointer to array of beginning of rows in nzval[] 
! 		       and colind[]  */
!                     /* Note:
! 		       Zero-based indexing is used;
! 		       rowptr[] has nrow+1 entries, the last one pointing
! 		       beyond the last row, so that rowptr[nrow] = nnz. */
  } NRformat;
  
! /* Stype == SLU_SC */
  typedef struct {
    int  nnz;	     /* number of nonzeros in the matrix */
!   int  nsuper;     /* number of supernodes, minus 1 */
    void *nzval;       /* pointer to array of nonzero values, packed by column */
!   int *nzval_colptr;/* pointer to array of beginning of columns in nzval[] */
!   int *rowind;     /* pointer to array of compressed row indices of 
  			rectangular supernodes */
    int *rowind_colptr;/* pointer to array of beginning of columns in rowind[] */
    int *col_to_sup;   /* col_to_sup[j] is the supernode number to which column 
  			j belongs; mapping from column to supernode number. */
    int *sup_to_col;   /* sup_to_col[s] points to the start of the s-th 
  			supernode; mapping from supernode number to column.
! 		        e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 4 (ncol=12)
! 		              sup_to_col: 0 1 2 4 7 12           (nsuper=4) */
                       /* Note:
  		        Zero-based indexing is used;
  		        nzval_colptr[], rowind_colptr[], col_to_sup and
  		        sup_to_col[] have ncol+1 entries, the last one
! 		        pointing beyond the last column.
! 		        For col_to_sup[], only the first ncol entries are
! 		        defined. For sup_to_col[], only the first nsuper+2
! 		        entries are defined. */
  } SCformat;
  
! /* Stype == SLU_SCP */
! typedef struct {
!   int  nnz;	     /* number of nonzeros in the matrix */
!   int  nsuper;     /* number of supernodes */
!   void *nzval;       /* pointer to array of nonzero values, packed by column */
!   int  *nzval_colbeg;/* nzval_colbeg[j] points to beginning of column j
! 			  in nzval[] */
!   int  *nzval_colend;/* nzval_colend[j] points to one past the last element
! 			  of column j in nzval[] */
!   int  *rowind;      /* pointer to array of compressed row indices of 
! 			  rectangular supernodes */
!   int *rowind_colbeg;/* rowind_colbeg[j] points to beginning of column j
! 			  in rowind[] */
!   int *rowind_colend;/* rowind_colend[j] points to one past the last element
! 			  of column j in rowind[] */
!   int *col_to_sup;   /* col_to_sup[j] is the supernode number to which column
! 			  j belongs; mapping from column to supernode. */
!   int *sup_to_colbeg; /* sup_to_colbeg[s] points to the start of the s-th 
! 			   supernode; mapping from supernode to column.*/
!   int *sup_to_colend; /* sup_to_colend[s] points to one past the end of the
! 			   s-th supernode; mapping from supernode number to
! 			   column.
! 		        e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 4 (ncol=12)
! 		              sup_to_colbeg: 0 1 2 4 7              (nsuper=4)
! 			      sup_to_colend: 1 2 4 7 12                    */
!                      /* Note:
! 		        Zero-based indexing is used;
! 		        nzval_colptr[], rowind_colptr[], col_to_sup and
! 		        sup_to_col[] have ncol+1 entries, the last one
! 		        pointing beyond the last column.         */
! } SCPformat;
! 
! /* Stype == SLU_NCP */
  typedef struct {
      int nnz;	  /* number of nonzeros in the matrix */
      void *nzval;  /* pointer to array of nonzero values, packed by column */
!     int *rowind;/* pointer to array of row indices of the nonzeros */
  		  /* Note: nzval[]/rowind[] always have the same length */
!     int *colbeg;/* colbeg[j] points to the beginning of column j in nzval[] 
                       and rowind[]  */
!     int *colend;/* colend[j] points to one past the last element of column
  		     j in nzval[] and rowind[]  */
  		  /* Note:
  		     Zero-based indexing is used;
***************
*** 122,144 ****
  		     postmultiplied by a column permutation matrix. */
  } NCPformat;
  
! /* Stype == DN */
  typedef struct {
!     int lda;      /* leading dimension */
      void *nzval;  /* array of size lda*ncol to represent a dense matrix */
  } DNformat;
  
! 
! 
! /*********************************************************
!  * Macros used for easy access of sparse matrix entries. *
!  *********************************************************/
! #define L_SUB_START(col)     ( Lstore->rowind_colptr[col] )
! #define L_SUB(ptr)           ( Lstore->rowind[ptr] )
! #define L_NZ_START(col)      ( Lstore->nzval_colptr[col] )
! #define L_FST_SUPC(superno)  ( Lstore->sup_to_col[superno] )
! #define U_NZ_START(col)      ( Ustore->colptr[col] )
! #define U_SUB(ptr)           ( Ustore->rowind[ptr] )
  
  
  #endif  /* __SUPERLU_SUPERMATRIX */
--- 159,184 ----
  		     postmultiplied by a column permutation matrix. */
  } NCPformat;
  
! /* Stype == SLU_DN */
  typedef struct {
!     int lda;    /* leading dimension */
      void *nzval;  /* array of size lda*ncol to represent a dense matrix */
  } DNformat;
  
! /* Stype == SLU_NR_loc (Distributed Compressed Row Format) */
! typedef struct {
!     int nnz_loc;   /* number of nonzeros in the local submatrix */
!     int m_loc;     /* number of rows local to this processor */
!     int fst_row;   /* global index of the first row */
!     void  *nzval;    /* pointer to array of nonzero values, packed by row */
!     int *rowptr;   /* pointer to array of beginning of rows in nzval[] 
! 			and colind[]  */
!     int *colind;   /* pointer to array of column indices of the nonzeros */
!                      /* Note:
! 			Zero-based indexing is used;
! 			rowptr[] has n_loc + 1 entries, the last one pointing
! 			beyond the last row, so that rowptr[n_loc] = nnz_loc.*/
! } NRformat_loc;
  
  
  #endif  /* __SUPERLU_SUPERMATRIX */
diff -crB arpack++/include/arlutil.h arpack++new/include/arlutil.h
*** arpack++/include/arlutil.h	2000-02-20 19:36:46.000000000 -0500
--- arpack++new/include/arlutil.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 3,21 ****
     c++ interface to ARPACK code.
  
     MODULE ARLUtil.h.
!    Unaltered copy of util.h (from SuperLU package).
  */
  
  #ifndef __SUPERLU_UTIL /* allow multiple inclusions */
  #define __SUPERLU_UTIL
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <malloc.h>
  #include <assert.h>
  
! /* Macros */
  #ifndef USER_ABORT
  #define USER_ABORT(msg) superlu_abort_and_exit(msg)
  #endif
--- 3,101 ----
     c++ interface to ARPACK code.
  
     MODULE ARLUtil.h.
!    Unaltered copy of util.h (from SuperLU package)
!    and superlu_enum_consts.h
  */
  
+ 
+ 
+ #ifndef __SUPERLU_ENUM_CONSTS /* allow multiple inclusions */
+ #define __SUPERLU_ENUM_CONSTS
+ 
+ /***********************************************************************
+  * Enumerate types
+  ***********************************************************************/
+ typedef enum {NO, YES}                                          yes_no_t;
+ typedef enum {DOFACT, SamePattern, SamePattern_SameRowPerm, FACTORED} fact_t;
+ typedef enum {NOROWPERM, LargeDiag, MY_PERMR}                   rowperm_t;
+ typedef enum {NATURAL, MMD_ATA, MMD_AT_PLUS_A, COLAMD,
+ 	      METIS_AT_PLUS_A, PARMETIS, ZOLTAN, MY_PERMC}      colperm_t;
+ typedef enum {NOTRANS, TRANS, CONJ}                             trans_t;
+ typedef enum {NOEQUIL, ROW, COL, BOTH}                          DiagScale_t;
+ typedef enum {NOREFINE, SLU_SINGLE=1, SLU_DOUBLE, SLU_EXTRA}    IterRefine_t;
+ typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL}              MemType;
+ typedef enum {HEAD, TAIL}                                       stack_end_t;
+ typedef enum {SYSTEM, USER}                                     LU_space_t;
+ typedef enum {ONE_NORM, TWO_NORM, INF_NORM}			norm_t;
+ typedef enum {SILU, SMILU_1, SMILU_2, SMILU_3}			milu_t;
+ #if 0
+ typedef enum {NODROP		= 0x0000,
+ 	      DROP_BASIC	= 0x0001, /* ILU(tau) */
+ 	      DROP_PROWS	= 0x0002, /* ILUTP: keep p maximum rows */
+ 	      DROP_COLUMN	= 0x0004, /* ILUTP: for j-th column, 
+ 					     p = gamma * nnz(A(:,j)) */
+ 	      DROP_AREA 	= 0x0008, /* ILUTP: for j-th column, use
+ 					     nnz(F(:,1:j)) / nnz(A(:,1:j))
+ 					     to limit memory growth  */
+ 	      DROP_SECONDARY	= 0x000E, /* PROWS | COLUMN | AREA */
+ 	      DROP_DYNAMIC	= 0x0010,
+ 	      DROP_INTERP	= 0x0100}			rule_t;
+ #endif
+ 
+ 
+ /* 
+  * The following enumerate type is used by the statistics variable 
+  * to keep track of flop count and time spent at various stages.
+  *
+  * Note that not all of the fields are disjoint.
+  */
+ typedef enum {
+     COLPERM, /* find a column ordering that minimizes fills */
+     ROWPERM, /* find a row ordering maximizes diagonal. */
+     RELAX,   /* find artificial supernodes */
+     ETREE,   /* compute column etree */
+     EQUIL,   /* equilibrate the original matrix */
+     SYMBFAC, /* symbolic factorization. */
+     DIST,    /* distribute matrix. */
+     FACT,    /* perform LU factorization */
+     COMM,    /* communication for factorization */
+     SOL_COMM,/* communication for solve */
+     RCOND,   /* estimate reciprocal condition number */
+     SOLVE,   /* forward and back solves */
+     REFINE,  /* perform iterative refinement */
+     TRSV,    /* fraction of FACT spent in xTRSV */
+     GEMV,    /* fraction of FACT spent in xGEMV */
+     FERR,    /* estimate error bounds after iterative refinement */
+     NPHASES  /* total number of phases */
+ } PhaseType;
+ 
+ 
+ #endif /* __SUPERLU_ENUM_CONSTS */
+ 
+ 
+ 
  #ifndef __SUPERLU_UTIL /* allow multiple inclusions */
  #define __SUPERLU_UTIL
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
+ /*
+ #ifndef __STDC__
  #include <malloc.h>
+ #endif
+ */
  #include <assert.h>
  
! /***********************************************************************
!  * Macros
!  ***********************************************************************/
! #define FIRSTCOL_OF_SNODE(i)	(xsup[i])
! /* No of marker arrays used in the symbolic factorization,
!    each of size n */
! #define NO_MARKER     3
! #define NUM_TEMPV(m,w,t,b)  ( SUPERLU_MAX(m, (t + b)*w) )
! 
  #ifndef USER_ABORT
  #define USER_ABORT(msg) superlu_abort_and_exit(msg)
  #endif
***************
*** 27,33 ****
--- 107,118 ----
  
  
  #ifndef USER_MALLOC
+ #if 1
  #define USER_MALLOC(size) superlu_malloc(size)
+ #else
+ /* The following may check out some uninitialized data */
+ #define USER_MALLOC(size) memset (superlu_malloc(size), '\x0F', size)
+ #endif
  #endif
  
  #define SUPERLU_MALLOC(size) USER_MALLOC(size)
***************
*** 38,108 ****
  
  #define SUPERLU_FREE(addr) USER_FREE(addr)
  
  
- #define MAX(x, y) 	( (x) > (y) ? (x) : (y) )
- #define MIN(x, y) 	( (x) < (y) ? (x) : (y) )
  
! /* 
   * Constants 
!  */
  #define EMPTY	(-1)
! #define NO	(-1)
  #define FALSE	0
  #define TRUE	1
  
! /*
   * Type definitions
!  */
  typedef float    flops_t;
  typedef unsigned char Logical;
  
  /* 
!  * The following enumerate type is used by the statistics variable 
!  * SuperLUStat, to keep track of flop count and time spent at various stages.
   *
!  * Note that not all of the fields are disjoint.
   */
! typedef enum {
!     COLPERM, /* find a column ordering that minimizes fills */
!     RELAX,   /* find artificial supernodes */
!     ETREE,   /* compute column etree */
!     EQUIL,   /* equilibrate the original matrix */
!     FACT,    /* perform LU factorization */
!     RCOND,   /* estimate reciprocal condition number */
!     SOLVE,   /* forward and back solves */
!     REFINE,  /* perform iterative refinement */
!     FLOAT,   /* time spent in floating-point operations */
!     TRSV,    /* fraction of FACT spent in xTRSV */
!     GEMV,    /* fraction of FACT spent in xGEMV */
!     FERR,    /* estimate error bounds after iterative refinement */
!     NPHASES  /* total number of phases */
! } PhaseType;
  
  typedef struct {
      int     *panel_histo; /* histogram of panel size distribution */
      double  *utime;       /* running time at various phases */
      flops_t *ops;         /* operation count at various phases */
  } SuperLUStat_t;
  
! /* Macros */
! #define FIRSTCOL_OF_SNODE(i)	(xsup[i])
  
  
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  extern void    superlu_abort_and_exit(char*);
! extern void    *superlu_malloc (int);
  extern int     *intMalloc (int);
  extern int     *intCalloc (int);
  extern void    superlu_free (void*);
  extern void    SetIWork (int, int, int, int *, int **, int **, int **,
                           int **, int **, int **, int **);
- extern void    StatInit(int, int);
- extern void    StatFree();
  extern int     sp_coletree (int *, int *, int *, int, int, int *);
! extern void    relax_snode  (int, int *, int, int *, int *);
  extern void    resetrep_col (const int, const int *, int *);
  extern int     spcoletree (int *, int *, int *, int, int, int *);
  extern int     *TreePostorder (int, int *);
--- 123,411 ----
  
  #define SUPERLU_FREE(addr) USER_FREE(addr)
  
+ #define CHECK_MALLOC(where) {                 \
+     extern int superlu_malloc_total;        \
+     printf("%s: malloc_total %d Bytes\n",     \
+ 	   where, superlu_malloc_total); \
+ }
+ 
+ #define SUPERLU_MAX(x, y) 	( (x) > (y) ? (x) : (y) )
+ #define SUPERLU_MIN(x, y) 	( (x) < (y) ? (x) : (y) )
+ 
+ /*********************************************************
+  * Macros used for easy access of sparse matrix entries. *
+  *********************************************************/
+ #define L_SUB_START(col)     ( Lstore->rowind_colptr[col] )
+ #define L_SUB(ptr)           ( Lstore->rowind[ptr] )
+ #define L_NZ_START(col)      ( Lstore->nzval_colptr[col] )
+ #define L_FST_SUPC(superno)  ( Lstore->sup_to_col[superno] )
+ #define U_NZ_START(col)      ( Ustore->colptr[col] )
+ #define U_SUB(ptr)           ( Ustore->rowind[ptr] )
  
  
! /***********************************************************************
   * Constants 
!  ***********************************************************************/
  #define EMPTY	(-1)
! /*#define NO	(-1)*/
  #define FALSE	0
  #define TRUE	1
  
! #define NO_MEMTYPE  4      /* 0: lusup;
! 			      1: ucol;
! 			      2: lsub;
! 			      3: usub */
! 
! #define GluIntArray(n)   (5 * (n) + 5)
! 
! /* Dropping rules */
! #define  NODROP	        ( 0x0000 )
! #define	 DROP_BASIC	( 0x0001 )  /* ILU(tau) */
! #define  DROP_PROWS	( 0x0002 )  /* ILUTP: keep p maximum rows */
! #define  DROP_COLUMN	( 0x0004 )  /* ILUTP: for j-th column, 
! 				              p = gamma * nnz(A(:,j)) */
! #define  DROP_AREA 	( 0x0008 )  /* ILUTP: for j-th column, use
!  		 			      nnz(F(:,1:j)) / nnz(A(:,1:j))
! 					      to limit memory growth  */
! #define  DROP_SECONDARY	( 0x000E )  /* PROWS | COLUMN | AREA */
! #define  DROP_DYNAMIC	( 0x0010 )  /* adaptive tau */
! #define  DROP_INTERP	( 0x0100 )  /* use interpolation */
! 
! 
! #if 1
! #define MILU_ALPHA (1.0e-2) /* multiple of drop_sum to be added to diagonal */
! #else
! #define MILU_ALPHA  1.0 /* multiple of drop_sum to be added to diagonal */
! #endif
! 
! 
! /***********************************************************************
   * Type definitions
!  ***********************************************************************/
  typedef float    flops_t;
  typedef unsigned char Logical;
  
  /* 
!  *-- This contains the options used to control the solution process.
   *
!  * Fact   (fact_t)
!  *        Specifies whether or not the factored form of the matrix
!  *        A is supplied on entry, and if not, how the matrix A should
!  *        be factorizaed.
!  *        = DOFACT: The matrix A will be factorized from scratch, and the
!  *             factors will be stored in L and U.
!  *        = SamePattern: The matrix A will be factorized assuming
!  *             that a factorization of a matrix with the same sparsity
!  *             pattern was performed prior to this one. Therefore, this
!  *             factorization will reuse column permutation vector 
!  *             ScalePermstruct->perm_c and the column elimination tree
!  *             LUstruct->etree.
!  *        = SamePattern_SameRowPerm: The matrix A will be factorized
!  *             assuming that a factorization of a matrix with the same
!  *             sparsity	pattern and similar numerical values was performed
!  *             prior to this one. Therefore, this factorization will reuse
!  *             both row and column scaling factors R and C, both row and
!  *             column permutation vectors perm_r and perm_c, and the
!  *             data structure set up from the previous symbolic factorization.
!  *        = FACTORED: On entry, L, U, perm_r and perm_c contain the 
!  *              factored form of A. If DiagScale is not NOEQUIL, the matrix
!  *              A has been equilibrated with scaling factors R and C.
!  *
!  * Equil  (yes_no_t)
!  *        Specifies whether to equilibrate the system (scale A's row and
!  *        columns to have unit norm).
!  *
!  * ColPerm (colperm_t)
!  *        Specifies what type of column permutation to use to reduce fill.
!  *        = NATURAL: use the natural ordering 
!  *        = MMD_ATA: use minimum degree ordering on structure of A'*A
!  *        = MMD_AT_PLUS_A: use minimum degree ordering on structure of A'+A
!  *        = COLAMD: use approximate minimum degree column ordering
!  *        = MY_PERMC: use the ordering specified by the user
!  *         
!  * Trans  (trans_t)
!  *        Specifies the form of the system of equations:
!  *        = NOTRANS: A * X = B        (No transpose)
!  *        = TRANS:   A**T * X = B     (Transpose)
!  *        = CONJ:    A**H * X = B     (Transpose)
!  *
!  * IterRefine (IterRefine_t)
!  *        Specifies whether to perform iterative refinement.
!  *        = NO: no iterative refinement
!  *        = SLU_SINGLE: perform iterative refinement in single precision
!  *        = SLU_DOUBLE: perform iterative refinement in double precision
!  *        = SLU_EXTRA: perform iterative refinement in extra precision
!  *
!  * DiagPivotThresh (double, in [0.0, 1.0]) (only for sequential SuperLU)
!  *        Specifies the threshold used for a diagonal entry to be an
!  *        acceptable pivot.
!  *
!  * SymmetricMode (yest_no_t)
!  *        Specifies whether to use symmetric mode. Symmetric mode gives 
!  *        preference to diagonal pivots, and uses an (A'+A)-based column
!  *        permutation algorithm.
!  *
!  * PivotGrowth (yes_no_t)
!  *        Specifies whether to compute the reciprocal pivot growth.
!  *
!  * ConditionNumber (ues_no_t)
!  *        Specifies whether to compute the reciprocal condition number.
!  *
!  * RowPerm (rowperm_t) (only for SuperLU_DIST or ILU)
!  *        Specifies whether to permute rows of the original matrix.
!  *        = NO: not to permute the rows
!  *        = LargeDiag: make the diagonal large relative to the off-diagonal
!  *        = MY_PERMR: use the permutation given by the user
!  *
!  * ILU_DropRule (int)
!  *        Specifies the dropping rule:
!  *	  = DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau).
!  *	  = DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma * nnz(A)/n.
!  *	  = DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column,
!  *			      p = gamma * nnz(A(:,j)).
!  *	  = DROP_AREA:    Variation of ILUTP, for j-th column, use
!  *			      nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory.
!  *	  = DROP_DYNAMIC: Modify the threshold tau during factorizaion:
!  *			  If nnz(L(:,1:j)) / nnz(A(:,1:j)) > gamma
!  *				  tau_L(j) := MIN(tau_0, tau_L(j-1) * 2);
!  *			  Otherwise
!  *				  tau_L(j) := MAX(tau_0, tau_L(j-1) / 2);
!  *			  tau_U(j) uses the similar rule.
!  *			  NOTE: the thresholds used by L and U are separate.
!  *	  = DROP_INTERP:  Compute the second dropping threshold by
!  *	                  interpolation instead of sorting (default).
!  *  		          In this case, the actual fill ratio is not
!  *			  guaranteed to be smaller than gamma.
!  *   	  Note: DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive.
!  *	  ( Default: DROP_BASIC | DROP_AREA )
!  *
!  * ILU_DropTol (double)
!  *        numerical threshold for dropping.
!  *
!  * ILU_FillFactor (double) 
!  *        Gamma in the secondary dropping.
!  *
!  * ILU_Norm (norm_t)
!  *        Specify which norm to use to measure the row size in a
!  *        supernode: infinity-norm, 1-norm, or 2-norm.
!  *
!  * ILU_FillTol (double)
!  *        numerical threshold for zero pivot perturbation.
!  *
!  * ILU_MILU (milu_t)
!  *        Specifies which version of MILU to use.
!  *
!  * ILU_MILU_Dim (double) 
!  *        Dimension of the PDE if available.
!  *
!  * ReplaceTinyPivot (yes_no_t) (only for SuperLU_DIST)
!  *        Specifies whether to replace the tiny diagonals by
!  *        sqrt(epsilon)*||A|| during LU factorization.
!  *
!  * SolveInitialized (yes_no_t) (only for SuperLU_DIST)
!  *        Specifies whether the initialization has been performed to the
!  *        triangular solve.
!  *
!  * RefineInitialized (yes_no_t) (only for SuperLU_DIST)
!  *        Specifies whether the initialization has been performed to the
!  *        sparse matrix-vector multiplication routine needed in iterative
!  *        refinement.
!  *
!  * PrintStat (yes_no_t)
!  *        Specifies whether to print the solver's statistics.
   */
! typedef struct {
!     fact_t        Fact;
!     yes_no_t      Equil;
!     colperm_t     ColPerm;
!     trans_t       Trans;
!     IterRefine_t  IterRefine;
!     double        DiagPivotThresh;
!     yes_no_t      SymmetricMode;
!     yes_no_t      PivotGrowth;
!     yes_no_t      ConditionNumber;
!     rowperm_t     RowPerm;
!     int 	  ILU_DropRule;
!     double	  ILU_DropTol;    /* threshold for dropping */
!     double	  ILU_FillFactor; /* gamma in the secondary dropping */
!     norm_t	  ILU_Norm;       /* infinity-norm, 1-norm, or 2-norm */
!     double	  ILU_FillTol;    /* threshold for zero pivot perturbation */
!     milu_t	  ILU_MILU;
!     double	  ILU_MILU_Dim;   /* Dimension of PDE (if available) */
!     yes_no_t      ParSymbFact;
!     yes_no_t      ReplaceTinyPivot; /* used in SuperLU_DIST */
!     yes_no_t      SolveInitialized;
!     yes_no_t      RefineInitialized;
!     yes_no_t      PrintStat;
!     int           nnzL, nnzU;      /* used to store nnzs for now       */
!     int           num_lookaheads;  /* num of levels in look-ahead      */
!     yes_no_t      lookahead_etree; /* use etree computed from the
! 				      serial symbolic factorization */
!     yes_no_t      SymPattern;      /* symmetric factorization          */
! } superlu_options_t;
! 
! /*! \brief Headers for 4 types of dynamatically managed memory */
! typedef struct e_node {
!     int size;      /* length of the memory that has been used */
!     void *mem;     /* pointer to the new malloc'd store */
! } ExpHeader;
! 
! typedef struct {
!     int  size;
!     int  used;
!     int  top1;  /* grow upward, relative to &array[0] */
!     int  top2;  /* grow downward */
!     void *array;
! } LU_stack_t;
  
  typedef struct {
      int     *panel_histo; /* histogram of panel size distribution */
      double  *utime;       /* running time at various phases */
      flops_t *ops;         /* operation count at various phases */
+     int     TinyPivots;   /* number of tiny pivots */
+     int     RefineSteps;  /* number of iterative refinement steps */
+     int     expansions;   /* number of memory expansions */
  } SuperLUStat_t;
  
! typedef struct {
!     float for_lu;
!     float total_needed;
! } mem_usage_t;
  
  
+ /***********************************************************************
+  * Prototypes
+  ***********************************************************************/
  #ifdef __cplusplus
  extern "C" {
  #endif
  
+ extern void    Destroy_SuperMatrix_Store(SuperMatrix *);
+ extern void    Destroy_CompCol_Matrix(SuperMatrix *);
+ extern void    Destroy_CompRow_Matrix(SuperMatrix *);
+ extern void    Destroy_SuperNode_Matrix(SuperMatrix *);
+ extern void    Destroy_CompCol_Permuted(SuperMatrix *);
+ extern void    Destroy_Dense_Matrix(SuperMatrix *);
+ extern void    get_perm_c(int, SuperMatrix *, int *);
+ extern void    set_default_options(superlu_options_t *options);
+ extern void    ilu_set_default_options(superlu_options_t *options);
+ extern void    sp_preorder (superlu_options_t *, SuperMatrix*, int*, int*,
+ 			    SuperMatrix*);
  extern void    superlu_abort_and_exit(char*);
! extern void    *superlu_malloc (size_t);
  extern int     *intMalloc (int);
  extern int     *intCalloc (int);
  extern void    superlu_free (void*);
  extern void    SetIWork (int, int, int, int *, int **, int **, int **,
                           int **, int **, int **, int **);
  extern int     sp_coletree (int *, int *, int *, int, int, int *);
! extern void    relax_snode (const int, int *, const int, int *, int *);
! extern void    heap_relax_snode (const int, int *, const int, int *, int *);
! extern int     mark_relax(int, int *, int *, int *, int *, int *, int *);
! extern void    ilu_relax_snode (const int, int *, const int, int *,
! 				int *, int *);
! extern void    ilu_heap_relax_snode (const int, int *, const int, int *,
! 				     int *, int*);
  extern void    resetrep_col (const int, const int *, int *);
  extern int     spcoletree (int *, int *, int *, int, int, int *);
  extern int     *TreePostorder (int, int *);
***************
*** 113,122 ****
  extern void    ifill (int *, int, int);
  extern void    snode_profile (int, int *);
  extern void    super_stats (int, int *);
  extern void    PrintSumm (char *, int, int, int);
! extern void    PrintStat (SuperLUStat_t *);
  extern void    print_panel_seg(int, int, int, int, int *, int *);
! extern void    check_repfnz(int, int, int, int *);
  
  #ifdef __cplusplus
    }
--- 416,429 ----
  extern void    ifill (int *, int, int);
  extern void    snode_profile (int, int *);
  extern void    super_stats (int, int *);
+ extern void    check_repfnz(int, int, int, int *);
  extern void    PrintSumm (char *, int, int, int);
! extern void    StatInit(SuperLUStat_t *);
! extern void    StatPrint (SuperLUStat_t *);
! extern void    StatFree(SuperLUStat_t *);
  extern void    print_panel_seg(int, int, int, int, int *, int *);
! extern int     print_int_vec(char *,int, int *);
! extern int     slu_PrintInt10(char *, int, int *);
  
  #ifdef __cplusplus
    }
diff -crB arpack++/include/arpackf.h arpack++new/include/arpackf.h
*** arpack++/include/arpackf.h	2000-02-20 18:50:00.000000000 -0500
--- arpack++new/include/arpackf.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 34,40 ****
  
  // double precision symmetric routines.
  
!   void F77NAME(dsaupd)(ARint *ido, char *bmat, ARint *n, char *which,
                         ARint *nev, double *tol, double *resid,
                         ARint *ncv, double *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, double *workd,
--- 34,40 ----
  
  // double precision symmetric routines.
  
!   void F77NAME(dsaupd)(ARint *ido, char *bmat, ARint *n, const char *which,
                         ARint *nev, double *tol, double *resid,
                         ARint *ncv, double *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, double *workd,
***************
*** 43,49 ****
    void F77NAME(dseupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         double *d, double *Z, ARint *ldz,
                         double *sigma, char *bmat, ARint *n,
!                        char *which, ARint *nev, double *tol,
                         double *resid, ARint *ncv, double *V,
                         ARint *ldv, ARint *iparam, ARint *ipntr,
                         double *workd, double *workl,
--- 43,49 ----
    void F77NAME(dseupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         double *d, double *Z, ARint *ldz,
                         double *sigma, char *bmat, ARint *n,
!                        const char *which, ARint *nev, double *tol,
                         double *resid, ARint *ncv, double *V,
                         ARint *ldv, ARint *iparam, ARint *ipntr,
                         double *workd, double *workl,
***************
*** 51,57 ****
  
  // double precision nonsymmetric routines.
  
!   void F77NAME(dnaupd)(ARint *ido, char *bmat, ARint *n, char *which,
                         ARint *nev, double *tol, double *resid,
                         ARint *ncv, double *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, double *workd,
--- 51,57 ----
  
  // double precision nonsymmetric routines.
  
!   void F77NAME(dnaupd)(ARint *ido, char *bmat, ARint *n, const char *which,
                         ARint *nev, double *tol, double *resid,
                         ARint *ncv, double *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, double *workd,
***************
*** 61,67 ****
                         double *dr, double *di, double *Z,
                         ARint *ldz, double *sigmar,
                         double *sigmai, double *workev,
!                        char *bmat, ARint *n, char *which,
                         ARint *nev, double *tol, double *resid,
                         ARint *ncv, double *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr,
--- 61,67 ----
                         double *dr, double *di, double *Z,
                         ARint *ldz, double *sigmar,
                         double *sigmai, double *workev,
!                        char *bmat, ARint *n, const char *which,
                         ARint *nev, double *tol, double *resid,
                         ARint *ncv, double *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr,
***************
*** 70,76 ****
  
  // single precision symmetric routines.
  
!   void F77NAME(ssaupd)(ARint *ido, char *bmat, ARint *n, char *which,
                         ARint *nev, float *tol, float *resid,
                         ARint *ncv, float *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, float *workd,
--- 70,76 ----
  
  // single precision symmetric routines.
  
!   void F77NAME(ssaupd)(ARint *ido, char *bmat, ARint *n, const char *which,
                         ARint *nev, float *tol, float *resid,
                         ARint *ncv, float *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, float *workd,
***************
*** 79,85 ****
    void F77NAME(sseupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         float *d, float *Z, ARint *ldz,
                         float *sigma, char *bmat, ARint *n,
!                        char *which, ARint *nev, float *tol,
                         float *resid, ARint *ncv, float *V,
                         ARint *ldv, ARint *iparam, ARint *ipntr,
                         float *workd, float *workl,
--- 79,85 ----
    void F77NAME(sseupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         float *d, float *Z, ARint *ldz,
                         float *sigma, char *bmat, ARint *n,
!                        const char *which, ARint *nev, float *tol,
                         float *resid, ARint *ncv, float *V,
                         ARint *ldv, ARint *iparam, ARint *ipntr,
                         float *workd, float *workl,
***************
*** 87,93 ****
  
  // single precision nonsymmetric routines.
  
!   void F77NAME(snaupd)(ARint *ido, char *bmat, ARint *n, char *which,
                         ARint *nev, float *tol, float *resid,
                         ARint *ncv, float *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, float *workd,
--- 87,93 ----
  
  // single precision nonsymmetric routines.
  
!   void F77NAME(snaupd)(ARint *ido, char *bmat, ARint *n, const char *which,
                         ARint *nev, float *tol, float *resid,
                         ARint *ncv, float *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, float *workd,
***************
*** 97,103 ****
                         float *dr, float *di, float *Z,
                         ARint *ldz, float *sigmar,
                         float *sigmai, float *workev, char *bmat,
!                        ARint *n, char *which, ARint *nev,
                         float *tol, float *resid, ARint *ncv,
                         float *V, ARint *ldv, ARint *iparam,
                         ARint *ipntr, float *workd, float *workl,
--- 97,103 ----
                         float *dr, float *di, float *Z,
                         ARint *ldz, float *sigmar,
                         float *sigmai, float *workev, char *bmat,
!                        ARint *n, const char *which, ARint *nev,
                         float *tol, float *resid, ARint *ncv,
                         float *V, ARint *ldv, ARint *iparam,
                         ARint *ipntr, float *workd, float *workl,
***************
*** 107,113 ****
  
  // single precision complex routines.
  
!   void F77NAME(cnaupd)(ARint *ido, char *bmat, ARint *n, char *which,
                         ARint *nev, float *tol, arcomplex<float> *resid,
                         ARint *ncv, arcomplex<float> *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, arcomplex<float> *workd,
--- 107,113 ----
  
  // single precision complex routines.
  
!   void F77NAME(cnaupd)(ARint *ido, char *bmat, ARint *n, const char *which,
                         ARint *nev, float *tol, arcomplex<float> *resid,
                         ARint *ncv, arcomplex<float> *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, arcomplex<float> *workd,
***************
*** 117,123 ****
    void F77NAME(cneupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         arcomplex<float> *d, arcomplex<float> *Z, ARint *ldz,
                         arcomplex<float> *sigma, arcomplex<float> *workev,
!                        char *bmat, ARint *n, char *which, ARint *nev,
                         float *tol, arcomplex<float> *resid, ARint *ncv,
                         arcomplex<float> *V, ARint *ldv, ARint *iparam,
                         ARint *ipntr, arcomplex<float> *workd,
--- 117,123 ----
    void F77NAME(cneupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         arcomplex<float> *d, arcomplex<float> *Z, ARint *ldz,
                         arcomplex<float> *sigma, arcomplex<float> *workev,
!                        char *bmat, ARint *n, const char *which, ARint *nev,
                         float *tol, arcomplex<float> *resid, ARint *ncv,
                         arcomplex<float> *V, ARint *ldv, ARint *iparam,
                         ARint *ipntr, arcomplex<float> *workd,
***************
*** 126,132 ****
  
  // double precision complex routines.
  
!   void F77NAME(znaupd)(ARint *ido, char *bmat, ARint *n, char *which,
                         ARint *nev, double *tol, arcomplex<double> *resid,
                         ARint *ncv, arcomplex<double> *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, arcomplex<double> *workd,
--- 126,132 ----
  
  // double precision complex routines.
  
!   void F77NAME(znaupd)(ARint *ido, char *bmat, ARint *n, const char *which,
                         ARint *nev, double *tol, arcomplex<double> *resid,
                         ARint *ncv, arcomplex<double> *V, ARint *ldv,
                         ARint *iparam, ARint *ipntr, arcomplex<double> *workd,
***************
*** 136,142 ****
    void F77NAME(zneupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         arcomplex<double> *d, arcomplex<double> *Z, ARint *ldz,
                         arcomplex<double> *sigma, arcomplex<double> *workev,
!                        char *bmat, ARint *n, char *which, ARint *nev,
                         double *tol, arcomplex<double> *resid, ARint *ncv,
                         arcomplex<double> *V, ARint *ldv, ARint *iparam,
                         ARint *ipntr, arcomplex<double> *workd,
--- 136,142 ----
    void F77NAME(zneupd)(ARlogical *rvec, char *HowMny, ARlogical *select,
                         arcomplex<double> *d, arcomplex<double> *Z, ARint *ldz,
                         arcomplex<double> *sigma, arcomplex<double> *workev,
!                        char *bmat, ARint *n, const char *which, ARint *nev,
                         double *tol, arcomplex<double> *resid, ARint *ncv,
                         arcomplex<double> *V, ARint *ldv, ARint *iparam,
                         ARint *ipntr, arcomplex<double> *workd,
diff -crB arpack++/include/arrgcomp.h arpack++new/include/arrgcomp.h
*** arpack++/include/arrgcomp.h	2000-02-21 11:29:48.000000000 -0500
--- arpack++new/include/arrgcomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARRGCOMP_H
  #define ARRGCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arrscomp.h"
  #include "arrgeig.h"
--- 17,24 ----
  #ifndef ARRGCOMP_H
  #define ARRGCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arrscomp.h"
  #include "arrgeig.h"
***************
*** 34,46 ****
    ARrcCompGenEig() { }
    // Short constructor (Does nothing but calling base classes constructors).
  
!   ARrcCompGenEig(int np, int nevp, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap,
!                  char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 35,47 ----
    ARrcCompGenEig() { }
    // Short constructor (Does nothing but calling base classes constructors).
  
!   ARrcCompGenEig(int np, int nevp, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap,
!                  const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 66,92 ****
  
  template<class ARFLOAT>
  inline ARrcCompGenEig<ARFLOAT>::
! ARrcCompGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcCompGenEig<ARFLOAT>::
! ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap, char* whichp,
                 int ncvp, ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   ChangeShift(sigmap);
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shif and invert mode).
  
--- 67,93 ----
  
  template<class ARFLOAT>
  inline ARrcCompGenEig<ARFLOAT>::
! ARrcCompGenEig(int np, int nevp, const std::string& whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcCompGenEig<ARFLOAT>::
! ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap, const std::string& whichp,
                 int ncvp, ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
  {
  
!   this->ChangeShift(sigmap);
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shif and invert mode).
  
***************
*** 97,103 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 98,104 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arrgeig.h arpack++new/include/arrgeig.h
*** arpack++/include/arrgeig.h	2000-02-21 11:28:50.000000000 -0500
--- arpack++new/include/arrgeig.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 66,76 ****
  inline void ARrcGenEig<ARFLOAT, ARTYPE>::NoShift()
  {
  
!   sigmaR    = (ARTYPE)0;
!   sigmaI    = 0.0;
!   mode      = 2;
!   iparam[7] = mode;
!   Restart();
  
  } // NoShift.
  
--- 66,76 ----
  inline void ARrcGenEig<ARFLOAT, ARTYPE>::NoShift()
  {
  
!   this->sigmaR    = (ARTYPE)0;
!   this->sigmaI    = 0.0;
!   this->mode      = 2;
!   this->iparam[7] = this->mode;
!   this->Restart();
  
  } // NoShift.
  
***************
*** 79,86 ****
  inline ARrcGenEig<ARFLOAT, ARTYPE>::ARrcGenEig()
  {
  
!   bmat = 'G';   // This is a generalized problem.
!   NoShift();
  
  } // Short constructor.
  
--- 79,86 ----
  inline ARrcGenEig<ARFLOAT, ARTYPE>::ARrcGenEig()
  {
  
!   this->bmat = 'G';   // This is a generalized problem.
!   this->NoShift();
  
  } // Short constructor.
  
***************
*** 91,97 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 91,97 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arrgnsym.h arpack++new/include/arrgnsym.h
*** arpack++/include/arrgnsym.h	2000-02-21 11:27:48.000000000 -0500
--- arpack++new/include/arrgnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARRGNSYM_H
  #define ARRGNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arrsnsym.h"
  #include "arrgeig.h"
--- 17,24 ----
  #ifndef ARRGNSYM_H
  #define ARRGNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arrsnsym.h"
  #include "arrgeig.h"
***************
*** 50,56 ****
  
   // c.1) Functions that provides access to internal variables' values.
  
!   ARFLOAT GetShiftImag() { return sigmaI; }
    // Returns the imaginary part of the shift (when in shift and invert mode).
  
  
--- 51,57 ----
  
   // c.1) Functions that provides access to internal variables' values.
  
!   ARFLOAT GetShiftImag() { return this->sigmaI; }
    // Returns the imaginary part of the shift (when in shift and invert mode).
  
  
***************
*** 77,96 ****
    ARrcNonSymGenEig() { part = 'R'; }
    // Short constructor that does almost nothing.
  
!   ARrcNonSymGenEig(int np, int nevp, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap,
!                    char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                     int maxitp = 0, ARFLOAT* residp = NULL, 
                     bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARrcNonSymGenEig(int np, int nevp,
                     char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp,
!                    char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                     int maxitp = 0, ARFLOAT* residp = NULL, 
                     bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
--- 78,97 ----
    ARrcNonSymGenEig() { part = 'R'; }
    // Short constructor that does almost nothing.
  
!   ARrcNonSymGenEig(int np, int nevp, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap,
!                    const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                     int maxitp = 0, ARFLOAT* residp = NULL, 
                     bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARrcNonSymGenEig(int np, int nevp,
                     char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp,
!                    const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                     int maxitp = 0, ARFLOAT* residp = NULL, 
                     bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
***************
*** 141,153 ****
  
    part = CheckPart(partp);
    if (part == 'R') {
!     mode    = 3;    // Real part.
    }
    else {
!     mode    = 4;    // Imaginary part.
    }
!   iparam[7] = mode;
!   Restart();
  
  } // ChangePart.
  
--- 142,154 ----
  
    part = CheckPart(partp);
    if (part == 'R') {
!     this->mode    = 3;    // Real part.
    }
    else {
!     this->mode    = 4;    // Imaginary part.
    }
!   this->iparam[7] = this->mode;
!   this->Restart();
  
  } // ChangePart.
  
***************
*** 157,164 ****
  ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = sigmaIp;
    ChangePart(part);
  
  } // ChangeShift.
--- 158,165 ----
  ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = sigmaIp;
    ChangePart(part);
  
  } // ChangeShift.
***************
*** 188,212 ****
  
  template<class ARFLOAT>
  inline ARrcNonSymGenEig<ARFLOAT>::
! ARrcNonSymGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
    part = 'R';                // Considering mode = 3 in ChangeShift.
!   NoShift();
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcNonSymGenEig<ARFLOAT>::
! ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
    SetShiftInvertMode(sigmap);
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  
  } // Long constructor (real shift and invert mode).
--- 189,213 ----
  
  template<class ARFLOAT>
  inline ARrcNonSymGenEig<ARFLOAT>::
! ARrcNonSymGenEig(int np, int nevp, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
    part = 'R';                // Considering mode = 3 in ChangeShift.
!   this->NoShift();
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcNonSymGenEig<ARFLOAT>::
! ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
    SetShiftInvertMode(sigmap);
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  
  } // Long constructor (real shift and invert mode).
***************
*** 215,226 ****
  template<class ARFLOAT>
  inline ARrcNonSymGenEig<ARFLOAT>::
  ARrcNonSymGenEig(int np, int nevp, char partp, ARFLOAT sigmaRp,
!                  ARFLOAT sigmaIp, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
    SetComplexShiftMode(partp, sigmaRp, sigmaIp);
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
--- 216,227 ----
  template<class ARFLOAT>
  inline ARrcNonSymGenEig<ARFLOAT>::
  ARrcNonSymGenEig(int np, int nevp, char partp, ARFLOAT sigmaRp,
!                  ARFLOAT sigmaIp, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
    SetComplexShiftMode(partp, sigmaRp, sigmaIp);
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
***************
*** 231,237 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 232,238 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arrgsym.h arpack++new/include/arrgsym.h
*** arpack++/include/arrgsym.h	2000-02-21 09:50:06.000000000 -0500
--- arpack++new/include/arrgsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARRGSYM_H
  #define ARRGSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arrssym.h"
  #include "arrgeig.h"
--- 17,24 ----
  #ifndef ARRGSYM_H
  #define ARRGSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arrssym.h"
  #include "arrgeig.h"
***************
*** 72,84 ****
    ARrcSymGenEig() { InvertMode = 'S'; }
    // Short constructor that does almost nothing.
  
!   ARrcSymGenEig(int np, int nevp, char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcSymGenEig(char invertmodep, int np, int nevp, ARFLOAT sigmap,
!                 char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                  int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift-and-invert, buckling and Cayley modes).
  
--- 73,85 ----
    ARrcSymGenEig() { InvertMode = 'S'; }
    // Short constructor that does almost nothing.
  
!   ARrcSymGenEig(int np, int nevp, const std::string& whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcSymGenEig(char invertmodep, int np, int nevp, ARFLOAT sigmap,
!                 const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                  int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift-and-invert, buckling and Cayley modes).
  
***************
*** 129,145 ****
    InvertMode = CheckInvertMode(InvertModep);
    switch (InvertMode) {
    case 'S':
!     mode    = 3;    // Shift and invert mode.
      break;
    case 'B':
!     mode    = 4;    // Buckling mode.
      break;
    case 'C':
!     mode    = 5;    // Cayley mode.
      break;
    }
!   iparam[7] = mode;
!   Restart();
  
  } // ChangeInvertMode.
  
--- 130,146 ----
    InvertMode = CheckInvertMode(InvertModep);
    switch (InvertMode) {
    case 'S':
!     this->mode    = 3;    // Shift and invert mode.
      break;
    case 'B':
!     this->mode    = 4;    // Buckling mode.
      break;
    case 'C':
!     this->mode    = 5;    // Cayley mode.
      break;
    }
!   this->iparam[7] = this->mode;
!   this->Restart();
  
  } // ChangeInvertMode.
  
***************
*** 148,155 ****
  inline void ARrcSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   sigmaR    = sigmap;
!   sigmaI    = 0.0;
    ChangeInvertMode(InvertMode);
  
  } // ChangeShift.
--- 149,156 ----
  inline void ARrcSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   this->sigmaR    = sigmap;
!   this->sigmaI    = 0.0;
    ChangeInvertMode(InvertMode);
  
  } // ChangeShift.
***************
*** 190,203 ****
  
  template<class ARFLOAT>
  inline ARrcSymGenEig<ARFLOAT>::
! ARrcSymGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    InvertMode = 'S';   // Considering mode = 3 in ChangeShift.
!   NoShift();
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
--- 191,204 ----
  
  template<class ARFLOAT>
  inline ARrcSymGenEig<ARFLOAT>::
! ARrcSymGenEig(int np, int nevp, const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    InvertMode = 'S';   // Considering mode = 3 in ChangeShift.
!   this->NoShift();
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
***************
*** 205,218 ****
  template<class ARFLOAT>
  inline ARrcSymGenEig<ARFLOAT>::
  ARrcSymGenEig(char InvertModep, int np, int nevp,
!               ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    InvertMode = CheckInvertMode(InvertModep); // InvertMode = 'S', 'B', 'C'.
    ChangeShift(sigmap);
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift-and-invert, buckling and Cayley modes).
  
--- 206,219 ----
  template<class ARFLOAT>
  inline ARrcSymGenEig<ARFLOAT>::
  ARrcSymGenEig(char InvertModep, int np, int nevp,
!               ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    InvertMode = CheckInvertMode(InvertModep); // InvertMode = 'S', 'B', 'C'.
    ChangeShift(sigmap);
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift-and-invert, buckling and Cayley modes).
  
***************
*** 223,229 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 224,230 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arrscomp.h arpack++new/include/arrscomp.h
*** arpack++/include/arrscomp.h	2000-03-03 15:29:58.000000000 -0500
--- arpack++new/include/arrscomp.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARRSCOMP_H
  #define ARRSCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
--- 17,24 ----
  #ifndef ARRSCOMP_H
  #define ARRSCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
***************
*** 104,116 ****
    ARrcCompStdEig() { }
    // Short constructor.
  
!   ARrcCompStdEig(int np, int nevp, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcCompStdEig(int np, int nevp, arcomplex<ARFLOAT> sigma,
!                  char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 105,117 ----
    ARrcCompStdEig() { }
    // Short constructor.
  
!   ARrcCompStdEig(int np, int nevp, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARrcCompStdEig(int np, int nevp, arcomplex<ARFLOAT> sigma,
!                  const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, arcomplex<ARFLOAT>* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 138,149 ****
  inline void ARrcCompStdEig<ARFLOAT>::WorkspaceAllocate()
  {
  
!   lworkl  = ncv*(3*ncv+6);
!   lworkv  = 2*ncv;
!   lrwork  = ncv;
!   workl   = new arcomplex<ARFLOAT>[lworkl+1];
!   workv   = new arcomplex<ARFLOAT>[lworkv+1];
!   rwork   = new ARFLOAT[lrwork+1];
  
  } // WorkspaceAllocate.
  
--- 139,150 ----
  inline void ARrcCompStdEig<ARFLOAT>::WorkspaceAllocate()
  {
  
!   this->lworkl  = this->ncv*(3*this->ncv+6);
!   this->lworkv  = 2*this->ncv;
!   this->lrwork  = this->ncv;
!   this->workl   = new arcomplex<ARFLOAT>[this->lworkl+1];
!   this->workv   = new arcomplex<ARFLOAT>[this->lworkv+1];
!   this->rwork   = new ARFLOAT[this->lrwork+1];
  
  } // WorkspaceAllocate.
  
***************
*** 152,159 ****
  inline void ARrcCompStdEig<ARFLOAT>::Aupp()
  {
  
!   caupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
!         iparam, ipntr, workd, workl, lworkl, rwork, info);
  
  } // Aupp.
  
--- 153,160 ----
  inline void ARrcCompStdEig<ARFLOAT>::Aupp()
  {
  
!   caupp(this->ido, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
!         this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->rwork, this->info);
  
  } // Aupp.
  
***************
*** 162,170 ****
  inline void ARrcCompStdEig<ARFLOAT>::Eupp()
  {
  
!   ceupp(rvec, HowMny, EigValR, EigVec, n, sigmaR, workv,
!         bmat, n, which, nev, tol, resid, ncv, V, n, iparam,
!         ipntr, workd, workl, lworkl, rwork, info);
  
  } // Eupp.
  
--- 163,171 ----
  inline void ARrcCompStdEig<ARFLOAT>::Eupp()
  {
  
!   ceupp(this->rvec, this->HowMny, this->EigValR, this->EigVec, this->n, this->sigmaR, this->workv,
!         this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n, this->iparam,
!         this->ipntr, this->workd, this->workl, this->lworkl, this->rwork, this->info);
  
  } // Eupp.
  
***************
*** 174,209 ****
  Eigenvalues(arcomplex<ARFLOAT>* &EigValp, bool ivec, bool ischur)
  {
  
!   if (ValuesOK) {                      // Eigenvalues are available .
      if (EigValp == NULL) {             // Moving eigenvalues.
!       EigValp  = EigValR;
!       EigValR  = NULL;
!       newVal   = false;
!       ValuesOK = false;
      }
      else {                             // Copying eigenvalues.
!       copy(nconv,EigValR,1,EigValp,1);
      }
    }
    else {
!     if (newVal) {
!       delete[] EigValR;
!       newVal = false;
      }
      if (EigValp == NULL) {
!       try { EigValp = new arcomplex<ARFLOAT>[ValSize()]; }
        catch (ArpackError) { return 0; }
      }
!     EigValR = EigValp;
      if (ivec) {                        // Finding eigenvalues and eigenvectors.
!       nconv = FindEigenvectors(ischur);
      }
      else {                             // Finding eigenvalues only.
!       nconv = FindEigenvalues();
      }
!     EigValR = NULL;
    }
!   return nconv;
  
  } // Eigenvalues(EigValp, ivec, ischur).
  
--- 175,210 ----
  Eigenvalues(arcomplex<ARFLOAT>* &EigValp, bool ivec, bool ischur)
  {
  
!   if (this->ValuesOK) {                      // Eigenvalues are available .
      if (EigValp == NULL) {             // Moving eigenvalues.
!       EigValp  = this->EigValR;
!       this->EigValR  = NULL;
!       this->newVal   = false;
!       this->ValuesOK = false;
      }
      else {                             // Copying eigenvalues.
!       copy(this->nconv,this->EigValR,1,EigValp,1);
      }
    }
    else {
!     if (this->newVal) {
!       delete[] this->EigValR;
!       this->newVal = false;
      }
      if (EigValp == NULL) {
!       try { EigValp = new arcomplex<ARFLOAT>[this->ValSize()]; }
        catch (ArpackError) { return 0; }
      }
!     this->EigValR = EigValp;
      if (ivec) {                        // Finding eigenvalues and eigenvectors.
!       this->nconv = this->FindEigenvectors(ischur);
      }
      else {                             // Finding eigenvalues only.
!       this->nconv = this->FindEigenvalues();
      }
!     this->EigValR = NULL;
    }
!   return this->nconv;
  
  } // Eigenvalues(EigValp, ivec, ischur).
  
***************
*** 214,244 ****
                  bool ischur)
  {
  
!   if (ValuesOK) {                  // Eigenvalues are already available.
!     nconv = Eigenvalues(EigValp, false);
!     nconv = Eigenvectors(EigVecp, ischur);
    }
    else {                           // Eigenvalues and vectors are not available.
!     if (newVec) {
!       delete[] EigVec;
!       newVec = false;
      }
!     if (newVal) {
!       delete[] EigValR;
!       newVal = false;
      }  
      try {
!       if (EigVecp == NULL) EigVecp = new arcomplex<ARFLOAT>[ValSize()*n];
!       if (EigValp == NULL) EigValp = new arcomplex<ARFLOAT>[ValSize()];
      }
      catch (ArpackError) { return 0; }
!     EigVec  = EigVecp;
!     EigValR = EigValp;
!     nconv   = FindEigenvectors(ischur);
!     EigVec  = NULL;
!     EigValR = NULL;
    }
!   return nconv;
  
  } // EigenValVectors(EigVecp, EigValp, ischur).
  
--- 215,245 ----
                  bool ischur)
  {
  
!   if (this->ValuesOK) {                  // Eigenvalues are already available.
!     this->nconv = Eigenvalues(EigValp, false);
!     this->nconv = this->Eigenvectors(EigVecp, ischur);
    }
    else {                           // Eigenvalues and vectors are not available.
!     if (this->newVec) {
!       delete[] this->EigVec;
!       this->newVec = false;
      }
!     if (this->newVal) {
!       delete[] this->EigValR;
!       this->newVal = false;
      }  
      try {
!       if (EigVecp == NULL) EigVecp = new arcomplex<ARFLOAT>[this->ValSize()*this->n];
!       if (EigValp == NULL) EigValp = new arcomplex<ARFLOAT>[this->ValSize()];
      }
      catch (ArpackError) { return 0; }
!     this->EigVec  = EigVecp;
!     this->EigValR = EigValp;
!     this->nconv   = this->FindEigenvectors(ischur);
!     this->EigVec  = NULL;
!     this->EigValR = NULL;
    }
!   return this->nconv;
  
  } // EigenValVectors(EigVecp, EigValp, ischur).
  
***************
*** 251,263 ****
  
    // Returning i-eth eigenvalue.
  
!   if (!ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
    }
!   else if ((i>=nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
    }
!   return EigValR[i];
  
  } // Eigenvalue(i).
  
--- 252,264 ----
  
    // Returning i-eth eigenvalue.
  
!   if (!this->ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
    }
!   else if ((i>=this->nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
    }
!   return this->EigValR[i];
  
  } // Eigenvalue(i).
  
***************
*** 269,281 ****
  
    // Returning element j of i-eth eigenvector.
  
!   if (!VectorsOK) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
    }
!   else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
    }
!   return EigVec[i*n+j];
  
  } // Eigenvector(i,j).
  
--- 270,282 ----
  
    // Returning element j of i-eth eigenvector.
  
!   if (!this->VectorsOK) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
    }
!   else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
    }
!   return this->EigVec[i*this->n+j];
  
  } // Eigenvector(i,j).
  
***************
*** 331,343 ****
  
  template<class ARFLOAT>
  inline ARrcCompStdEig<ARFLOAT>::
! ARrcCompStdEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
--- 332,344 ----
  
  template<class ARFLOAT>
  inline ARrcCompStdEig<ARFLOAT>::
! ARrcCompStdEig(int np, int nevp, const std::string& whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
***************
*** 345,357 ****
  template<class ARFLOAT>
  inline ARrcCompStdEig<ARFLOAT>::
  ARrcCompStdEig(int np, int nevp, arcomplex<ARFLOAT> sigmap,
!                char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   ChangeShift(sigmap);
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
--- 346,358 ----
  template<class ARFLOAT>
  inline ARrcCompStdEig<ARFLOAT>::
  ARrcCompStdEig(int np, int nevp, arcomplex<ARFLOAT> sigmap,
!                const std::string& whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->ChangeShift(sigmap);
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
***************
*** 362,368 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 363,369 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arrseig.h arpack++new/include/arrseig.h
*** arpack++/include/arrseig.h	2000-03-03 16:09:44.000000000 -0500
--- arpack++new/include/arrseig.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,26 ****
  #ifndef ARRSEIG_H
  #define ARRSEIG_H
  
! #include <new.h>
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
--- 19,27 ----
  #ifndef ARRSEIG_H
  #define ARRSEIG_H
  
! #include <new>
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
***************
*** 46,52 ****
    int     nev;        // Number of eigenvalues to be computed. 0 < nev < n-1.
    int     ncv;        // Number of Arnoldi vectors generated at each iteration.
    int     maxit;      // Maximum number of Arnoldi update iterations allowed.
!   char*   which;      // Specify which of the Ritz values of OP to compute.
    ARFLOAT tol;        // Stopping criterion (relative accuracy of Ritz values).
    ARFLOAT sigmaI;     // Imaginary part of shift (for nonsymmetric problems).
    ARTYPE  sigmaR;     // Shift (real part only if problem is nonsymmetric).
--- 47,53 ----
    int     nev;        // Number of eigenvalues to be computed. 0 < nev < n-1.
    int     ncv;        // Number of Arnoldi vectors generated at each iteration.
    int     maxit;      // Maximum number of Arnoldi update iterations allowed.
!   std::string   which;      // Specify which of the Ritz values of OP to compute.
    ARFLOAT tol;        // Stopping criterion (relative accuracy of Ritz values).
    ARFLOAT sigmaI;     // Imaginary part of shift (for nonsymmetric problems).
    ARTYPE  sigmaR;     // Shift (real part only if problem is nonsymmetric).
***************
*** 165,171 ****
    int CheckMaxit(int maxitp);
    // Forces maxit to be greater than zero.
  
!   virtual char* CheckWhich(char* whichp);
    // Determines if the value of variable "which" is valid.
    // Redefined in ARrcSymStdEig.
  
--- 166,172 ----
    int CheckMaxit(int maxitp);
    // Forces maxit to be greater than zero.
  
!   virtual std::string CheckWhich(const std::string& whichp);
    // Determines if the value of variable "which" is valid.
    // Redefined in ARrcSymStdEig.
  
***************
*** 188,194 ****
  
   // c.1) Function that stores user defined parameters.
  
!   virtual void DefineParameters(int np, int nevp, char* whichp="LM",
                                  int ncvp=0, ARFLOAT tolp=0.0, int maxitp=0,
                                  ARTYPE* residp=NULL, bool ishiftp=true);
    // Set values of problem parameters (also called by constructors).
--- 189,195 ----
  
   // c.1) Function that stores user defined parameters.
  
!   virtual void DefineParameters(int np, int nevp, const std::string& whichp="LM",
                                  int ncvp=0, ARFLOAT tolp=0.0, int maxitp=0,
                                  ARTYPE* residp=NULL, bool ishiftp=true);
    // Set values of problem parameters (also called by constructors).
***************
*** 236,242 ****
    int GetNcv() { return ncv; }
    // Returns the number of Arnoldi vectors generated at each iteration..
  
!   char* GetWhich() { return which; }
    // Returns "which".
  
    ARTYPE GetShift() { return sigmaR; }
--- 237,243 ----
    int GetNcv() { return ncv; }
    // Returns the number of Arnoldi vectors generated at each iteration..
  
!   const std::string& GetWhich() { return which; }
    // Returns "which".
  
    ARTYPE GetShift() { return sigmaR; }
***************
*** 263,269 ****
    virtual void ChangeNcv(int ncvp);
    // Changes the number of Arnoldi vectors generated at each iteration..
  
!   virtual void ChangeWhich(char* whichp);
    // Changes "which".
  
    virtual void ChangeShift(ARTYPE sigmaRp);
--- 264,270 ----
    virtual void ChangeNcv(int ncvp);
    // Changes the number of Arnoldi vectors generated at each iteration..
  
!   virtual void ChangeWhich(const std::string& whichp);
    // Changes "which".
  
    virtual void ChangeShift(ARTYPE sigmaRp);
***************
*** 661,667 ****
  } // CheckMaxit.
  
  template<class ARFLOAT, class ARTYPE>
! char* ARrcStdEig<ARFLOAT, ARTYPE>::CheckWhich(char* whichp)
  {
  
    switch (whichp[0]) {              // The first ought to be S or L.
--- 662,668 ----
  } // CheckMaxit.
  
  template<class ARFLOAT, class ARTYPE>
! std::string ARrcStdEig<ARFLOAT, ARTYPE>::CheckWhich(const std::string& whichp)
  {
  
    switch (whichp[0]) {              // The first ought to be S or L.
***************
*** 830,843 ****
  
  template<class ARFLOAT, class ARTYPE>
  void ARrcStdEig<ARFLOAT, ARTYPE>::
! DefineParameters(int np, int nevp, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARTYPE* residp, bool ishiftp)
  
  {
  
    // Providing a "new" handler.
  
!   set_new_handler(MemoryOverflow);
  
    // Setting user defined parameters.
  
--- 831,844 ----
  
  template<class ARFLOAT, class ARTYPE>
  void ARrcStdEig<ARFLOAT, ARTYPE>::
! DefineParameters(int np, int nevp, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARTYPE* residp, bool ishiftp)
  
  {
  
    // Providing a "new" handler.
  
!   std::set_new_handler ( MemoryOverflow );
  
    // Setting user defined parameters.
  
***************
*** 926,932 ****
  
  
  template<class ARFLOAT, class ARTYPE>
! void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeWhich(char* whichp)
  {
  
    try { which = CheckWhich(whichp); }
--- 927,933 ----
  
  
  template<class ARFLOAT, class ARTYPE>
! void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeWhich(const std::string& whichp)
  {
  
    try { which = CheckWhich(whichp); }
diff -crB arpack++/include/arrsnsym.h arpack++new/include/arrsnsym.h
*** arpack++/include/arrsnsym.h	2000-03-03 15:30:50.000000000 -0500
--- arpack++new/include/arrsnsym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARRSNSYM_H
  #define ARRSNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
--- 17,24 ----
  #ifndef ARRSNSYM_H
  #define ARRSNSYM_H
  
! #include <cstddef>
! 
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
***************
*** 35,41 ****
  
   // a.1) Memory control functions.
  
!   int ValSize() { return nev+1; }
    // Provides the size of array EigVal.
  
    void ValAllocate();
--- 36,42 ----
  
   // a.1) Memory control functions.
  
!   int ValSize() { return this->nev+1; }
    // Provides the size of array EigVal.
  
    void ValAllocate();
***************
*** 193,204 ****
    ARrcNonSymStdEig() { }
    // Short constructor.
  
!   ARrcNonSymStdEig(int np, int nevp, char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                     bool ishiftp = true);
    // Long constructor (regular mode).
  
!   ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigma, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 194,205 ----
    ARrcNonSymStdEig() { }
    // Short constructor.
  
!   ARrcNonSymStdEig(int np, int nevp, const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                     bool ishiftp = true);
    // Long constructor (regular mode).
  
!   ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigma, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 226,235 ****
  inline void ARrcNonSymStdEig<ARFLOAT>::ValAllocate()
  {
  
!   if (EigValR == NULL) {
!     EigValR = new ARFLOAT[ValSize()];
!     EigValI = new ARFLOAT[ValSize()];
!     newVal = true;
    }
  
  } // ValAllocate.
--- 227,236 ----
  inline void ARrcNonSymStdEig<ARFLOAT>::ValAllocate()
  {
  
!   if (this->EigValR == NULL) {
!     this->EigValR = new ARFLOAT[ValSize()];
!     this->EigValI = new ARFLOAT[ValSize()];
!     this->newVal = true;
    }
  
  } // ValAllocate.
***************
*** 239,249 ****
  inline void ARrcNonSymStdEig<ARFLOAT>::WorkspaceAllocate()
  {
  
!   lworkl  = 3*ncv*(ncv+2);
!   lworkv  = 3*ncv;
!   lrwork  = 0;
!   workl   = new ARFLOAT[lworkl+1];
!   workv   = new ARFLOAT[lworkv+1];
  
  } // WorkspaceAllocate.
  
--- 240,250 ----
  inline void ARrcNonSymStdEig<ARFLOAT>::WorkspaceAllocate()
  {
  
!   this->lworkl  = 3*this->ncv*(this->ncv+2);
!   this->lworkv  = 3*this->ncv;
!   this->lrwork  = 0;
!   this->workl   = new ARFLOAT[this->lworkl+1];
!   this->workv   = new ARFLOAT[this->lworkv+1];
  
  } // WorkspaceAllocate.
  
***************
*** 252,259 ****
  inline void ARrcNonSymStdEig<ARFLOAT>::Aupp()
  {
  
!   naupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
!         iparam, ipntr, workd, workl, lworkl, info);
  
  } // Aupp.
  
--- 253,260 ----
  inline void ARrcNonSymStdEig<ARFLOAT>::Aupp()
  {
  
!   naupp(this->ido,this-> bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
!         this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
  
  } // Aupp.
  
***************
*** 262,270 ****
  inline void ARrcNonSymStdEig<ARFLOAT>::Eupp()
  {
  
!   neupp(rvec, HowMny, EigValR, EigValI, EigVec, n, sigmaR,
!         sigmaI, workv, bmat, n, which, nev, tol, resid, ncv, V,
!         n, iparam, ipntr, workd, workl, lworkl, info);
  
  } // Eupp.
  
--- 263,271 ----
  inline void ARrcNonSymStdEig<ARFLOAT>::Eupp()
  {
  
!   neupp(this->rvec, this->HowMny, this->EigValR, this->EigValI, this->EigVec, this->n, this->sigmaR,
!         this->sigmaI, this->workv, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V,
!         this->n, this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
  
  } // Eupp.
  
***************
*** 273,279 ****
  inline int ARrcNonSymStdEig<ARFLOAT>::CheckNev(int nevp)
  {
  
!   if ((nevp<=1)||(nevp>=(n-1))) { // nev must satisfy 1 < nev < n-1.
      throw ArpackError(ArpackError::NEV_OUT_OF_BOUNDS);
    }
    return nevp;
--- 274,280 ----
  inline int ARrcNonSymStdEig<ARFLOAT>::CheckNev(int nevp)
  {
  
!   if ((nevp<=1)||(nevp>=(this->n-1))) { // nev must satisfy 1 < nev < n-1.
      throw ArpackError(ArpackError::NEV_OUT_OF_BOUNDS);
    }
    return nevp;
***************
*** 285,293 ****
  bool ARrcNonSymStdEig<ARFLOAT>::ConjEigVec(int i)
  {
  
!   if (EigValI[i] == (ARFLOAT)0.0) return false;
    int j = i-1;
!   while ((j >= 0) && (EigValI[j] != (ARFLOAT)0.0)) j--;
    if (((i-j)%2) == 0) {
      return true;
    }
--- 286,294 ----
  bool ARrcNonSymStdEig<ARFLOAT>::ConjEigVec(int i)
  {
  
!   if (this->EigValI[i] == (ARFLOAT)0.0) return false;
    int j = i-1;
!   while ((j >= 0) && (this->EigValI[j] != (ARFLOAT)0.0)) j--;
    if (((i-j)%2) == 0) {
      return true;
    }
***************
*** 395,404 ****
  ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::GetVectorImag()
  {
  
!   if (ido != 3) {
      throw ArpackError(ArpackError::CANNOT_GET_VECTOR, "GetVectorImag");
    }
!   return &workl[ipntr[6]];
  
  } // GetVectorImag.
  
--- 396,405 ----
  ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::GetVectorImag()
  {
  
!   if (this->ido != 3) {
      throw ArpackError(ArpackError::CANNOT_GET_VECTOR, "GetVectorImag");
    }
!   return &this->workl[this->ipntr[6]];
  
  } // GetVectorImag.
  
***************
*** 408,421 ****
  Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT* &EigValIp, bool ivec, bool ischur)
  {
  
!   if (ValuesOK) {                                 // Eigenvalues are available.
      if ((EigValRp == NULL)&&(EigValIp == NULL)) { // Moving eigenvalues.
!       EigValRp = EigValR;
!       EigValIp = EigValI;
!       EigValR  = NULL;
!       EigValI  = NULL;
!       newVal   = false;
!       ValuesOK = false;
      }
      else {                                        // Copying eigenvalues.
        try {
--- 409,422 ----
  Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT* &EigValIp, bool ivec, bool ischur)
  {
  
!   if (this->ValuesOK) {                                 // Eigenvalues are available.
      if ((EigValRp == NULL)&&(EigValIp == NULL)) { // Moving eigenvalues.
!       EigValRp = this->EigValR;
!       EigValIp = this->EigValI;
!       this->EigValR  = NULL;
!       this->EigValI  = NULL;
!       this->newVal   = false;
!       this->ValuesOK = false;
      }
      else {                                        // Copying eigenvalues.
        try {
***************
*** 423,455 ****
          if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
        }
        catch (ArpackError) { return 0; }
!       copy(nconv,EigValR,1,EigValRp,1);
!       copy(nconv,EigValI,1,EigValIp,1);
      }
    }
    else {
!     if (newVal) {
!       delete[] EigValR;
!       delete[] EigValI;
!       newVal = false;
      }
      try {
        if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
        if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
      }
      catch (ArpackError) { return 0; }
!     EigValR = EigValRp;
!     EigValI = EigValIp;
      if (ivec) {                              // Finding eigenvalues and vectors.
!       nconv = FindEigenvectors(ischur);
      }
      else {                                   // Finding eigenvalues only.
!       nconv = FindEigenvalues();
      }
!     EigValR = NULL;
!     EigValI = NULL;
    }
!   return nconv;
  
  } // Eigenvalues(EigValRp, EigValIp, ivec, ischur).
  
--- 424,456 ----
          if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
        }
        catch (ArpackError) { return 0; }
!       copy(this->nconv,this->EigValR,1,EigValRp,1);
!       copy(this->nconv,this->EigValI,1,EigValIp,1);
      }
    }
    else {
!     if (this->newVal) {
!       delete[] this->EigValR;
!       delete[] this->EigValI;
!       this->newVal = false;
      }
      try {
        if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
        if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
      }
      catch (ArpackError) { return 0; }
!     this->EigValR = EigValRp;
!     this->EigValI = EigValIp;
      if (ivec) {                              // Finding eigenvalues and vectors.
!       this->nconv = this->FindEigenvectors(ischur);
      }
      else {                                   // Finding eigenvalues only.
!       this->nconv = this->FindEigenvalues();
      }
!     this->EigValR = NULL;
!     this->EigValI = NULL;
    }
!   return this->nconv;
  
  } // Eigenvalues(EigValRp, EigValIp, ivec, ischur).
  
***************
*** 460,494 ****
                  ARFLOAT* &EigValIp, bool ischur)
  {
  
!   if (ValuesOK) {               // Eigenvalues are already available .
!     nconv = Eigenvalues(EigValRp, EigValIp, false);
!     nconv = Eigenvectors(EigVecp, ischur);
    }
    else {                        // Eigenvalues ans vectors are not available.
!     if (newVec) {
!       delete[] EigVec;
!       newVec = false;
!     }
!     if (newVal) {
!       delete[] EigValR;
!       delete[] EigValI;
!       newVal = false;
      }
      try {
!       if (EigVecp  == NULL) EigVecp  = new ARFLOAT[ValSize()*n];
        if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
        if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
      }
      catch (ArpackError) { return 0; }
!     EigVec  = EigVecp;
!     EigValR = EigValRp;
!     EigValI = EigValIp;
!     nconv   = FindEigenvectors(ischur);
!     EigVec  = NULL;
!     EigValR = NULL;
!     EigValI = NULL;
    }
!   return nconv;
  
  } // EigenValVectors(EigVecp, EigValRp, EigValIp, ischur).
  
--- 461,495 ----
                  ARFLOAT* &EigValIp, bool ischur)
  {
  
!   if (this->ValuesOK) {               // Eigenvalues are already available .
!     this->nconv = Eigenvalues(EigValRp, EigValIp, false);
!     this->nconv = this->Eigenvectors(EigVecp, ischur);
    }
    else {                        // Eigenvalues ans vectors are not available.
!     if (this->newVec) {
!       delete[] this->EigVec;
!       this->newVec = false;
!     }
!     if (this->newVal) {
!       delete[] this->EigValR;
!       delete[] this->EigValI;
!       this->newVal = false;
      }
      try {
!       if (EigVecp  == NULL) EigVecp  = new ARFLOAT[ValSize()*this->n];
        if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
        if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
      }
      catch (ArpackError) { return 0; }
!     this->EigVec  = EigVecp;
!     this->EigValR = EigValRp;
!     this->EigValI = EigValIp;
!     this->nconv   = this->FindEigenvectors(ischur);
!     this->EigVec  = NULL;
!     this->EigValR = NULL;
!     this->EigValI = NULL;
    }
!   return this->nconv;
  
  } // EigenValVectors(EigVecp, EigValRp, EigValIp, ischur).
  
***************
*** 500,512 ****
  
    // Returning i-eth eigenvalue.
  
!   if (!ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
    }
!   else if ((i>=nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
    }
!   return arcomplex<ARFLOAT>(EigValR[i],EigValI[i]);
  
  } // Eigenvalue(i).
  #endif // ARCOMP_H
--- 501,513 ----
  
    // Returning i-eth eigenvalue.
  
!   if (!this->ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
    }
!   else if ((i>=this->nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
    }
!   return arcomplex<ARFLOAT>(this->EigValR[i],this->EigValI[i]);
  
  } // Eigenvalue(i).
  #endif // ARCOMP_H
***************
*** 518,530 ****
  
    // Returning the real part of i-eth eigenvalue.
  
!   if (!ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueReal(i)");
    }
!   else if ((i>=nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueReal(i)");
    }
!   return EigValR[i];
  
  } // EigenvalueReal(i).
  
--- 519,531 ----
  
    // Returning the real part of i-eth eigenvalue.
  
!   if (!this->ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueReal(i)");
    }
!   else if ((i>=this->nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueReal(i)");
    }
!   return this->EigValR[i];
  
  } // EigenvalueReal(i).
  
***************
*** 535,547 ****
  
    // Returning the imaginary part of i-eth eigenvalue.
  
!   if (!ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueImag(i)");
    }
!   else if ((i>=nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueImag(i)");
    }
!   return EigValI[i];
  
  } // EigenvalueImag(i).
  
--- 536,548 ----
  
    // Returning the imaginary part of i-eth eigenvalue.
  
!   if (!this->ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueImag(i)");
    }
!   else if ((i>=this->nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueImag(i)");
    }
!   return this->EigValI[i];
  
  } // EigenvalueImag(i).
  
***************
*** 554,574 ****
  
    // Returning element j of i-eth eigenvector.
  
!   if ((!VectorsOK)||(!ValuesOK)) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
    }
!   else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
    }
!   if (EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
!     return arcomplex<ARFLOAT>(EigVec[i*n+j],(ARFLOAT)0.0);
    }
    else {                            // Complex eigenvalue.
!     if (EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
!       return arcomplex<ARFLOAT>(EigVec[i*n+j], EigVec[(i+1)*n+j]);
      }
      else {                          // with negative imaginary part.
!       return arcomplex<ARFLOAT>(EigVec[(i-1)*n+j], -EigVec[i*n+j]);
      }
    }
  
--- 555,575 ----
  
    // Returning element j of i-eth eigenvector.
  
!   if ((!this->VectorsOK)||(!this->ValuesOK)) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
    }
!   else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
    }
!   if (this->EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
!     return arcomplex<ARFLOAT>(this->EigVec[i*this->n+j],(ARFLOAT)0.0);
    }
    else {                            // Complex eigenvalue.
!     if (this->EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
!       return arcomplex<ARFLOAT>(this->EigVec[i*this->n+j], this->EigVec[(i+1)*this->n+j]);
      }
      else {                          // with negative imaginary part.
!       return arcomplex<ARFLOAT>(this->EigVec[(i-1)*this->n+j], -this->EigVec[i*this->n+j]);
      }
    }
  
***************
*** 582,594 ****
  
    // Returning the real part of element j of i-eth eigenvector.
  
!   if (!VectorsOK) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorReal(i,j)");
    }
!   else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorReal(i,j)");
    }
!   return EigVec[i*n+j];
  
  } // EigenvectorReal(i,j).
  
--- 583,595 ----
  
    // Returning the real part of element j of i-eth eigenvector.
  
!   if (!this->VectorsOK) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorReal(i,j)");
    }
!   else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorReal(i,j)");
    }
!   return this->EigVec[i*this->n+j];
  
  } // EigenvectorReal(i,j).
  
***************
*** 599,619 ****
  
    // Returning the imaginary part of element j of i-eth eigenvector.
  
!   if ((!VectorsOK)||(!ValuesOK)) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorImag(i,j)");
    }
!   else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorImag(i,j)");
    }
!   if (EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
      return (ARFLOAT)0.0;
    }
    else {                            // Complex eigenvalue.
!     if (EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
!       return EigVec[(i+1)*n+j];
      }
      else {                          // with negative imaginary part.
!       return -EigVec[i*n+j];
      }
    }
  
--- 600,620 ----
  
    // Returning the imaginary part of element j of i-eth eigenvector.
  
!   if ((!this->VectorsOK)||(!this->ValuesOK)) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorImag(i,j)");
    }
!   else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorImag(i,j)");
    }
!   if (this->EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
      return (ARFLOAT)0.0;
    }
    else {                            // Complex eigenvalue.
!     if (this->EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
!       return this->EigVec[(i+1)*this->n+j];
      }
      else {                          // with negative imaginary part.
!       return -this->EigVec[i*this->n+j];
      }
    }
  
***************
*** 624,633 ****
  inline ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::RawEigenvaluesImag()
  {
  
!   if (!ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "RawEigenvaluesImag");
    }
!   return EigValI;
  
  } // RawEigenvaluesImag.
  
--- 625,634 ----
  inline ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::RawEigenvaluesImag()
  {
  
!   if (!this->ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "RawEigenvaluesImag");
    }
!   return this->EigValI;
  
  } // RawEigenvaluesImag.
  
***************
*** 817,842 ****
  
  template<class ARFLOAT>
  inline ARrcNonSymStdEig<ARFLOAT>::
! ARrcNonSymStdEig(int np, int nevp, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcNonSymStdEig<ARFLOAT>::
! ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   ChangeShift(sigmap);
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
--- 818,843 ----
  
  template<class ARFLOAT>
  inline ARrcNonSymStdEig<ARFLOAT>::
! ARrcNonSymStdEig(int np, int nevp, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcNonSymStdEig<ARFLOAT>::
! ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigmap, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->ChangeShift(sigmap);
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
***************
*** 847,853 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 848,854 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arrssym.h arpack++new/include/arrssym.h
*** arpack++/include/arrssym.h	2000-03-03 15:29:21.000000000 -0500
--- arpack++new/include/arrssym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARRSSYM_H
  #define ARRSSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
--- 17,24 ----
  #ifndef ARRSSYM_H
  #define ARRSSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arerror.h"
  #include "debug.h"
***************
*** 50,56 ****
  
   // a.3) Functions that check user defined parameters.
  
!   char* CheckWhich(char* whichp);
    // Determines if the value of variable "which" is valid.
  
  
--- 51,57 ----
  
   // a.3) Functions that check user defined parameters.
  
!   std::string CheckWhich(const std::string& whichp);
    // Determines if the value of variable "which" is valid.
  
  
***************
*** 124,135 ****
    ARrcSymStdEig() { }
    // Short constructor.
  
!   ARrcSymStdEig(int np, int nevp, char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                  bool ishiftp = true);
    // Long constructor (regular mode).
  
!   ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 125,136 ----
    ARrcSymStdEig() { }
    // Short constructor.
  
!   ARrcSymStdEig(int np, int nevp, const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                  bool ishiftp = true);
    // Long constructor (regular mode).
  
!   ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, const std::string& whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 157,166 ****
  inline void ARrcSymStdEig<ARFLOAT>::WorkspaceAllocate()
  {
  
!   lworkl  = ncv*(ncv+9);
!   lworkv  = 0;
!   lrwork  = 0;
!   workl   = new ARFLOAT[lworkl+1];
  
  } // WorkspaceAllocate.
  
--- 158,167 ----
  inline void ARrcSymStdEig<ARFLOAT>::WorkspaceAllocate()
  {
  
!   this->lworkl  = this->ncv*(this->ncv+9);
!   this->lworkv  = 0;
!   this->lrwork  = 0;
!   this->workl   = new ARFLOAT[this->lworkl+1];
  
  } // WorkspaceAllocate.
  
***************
*** 169,176 ****
  inline void ARrcSymStdEig<ARFLOAT>::Aupp()
  {
  
!   saupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
!         iparam, ipntr, workd, workl, lworkl, info);
  
  } // Aupp.
  
--- 170,177 ----
  inline void ARrcSymStdEig<ARFLOAT>::Aupp()
  {
  
!   saupp(this->ido, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
!         this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
  
  } // Aupp.
  
***************
*** 179,193 ****
  inline void ARrcSymStdEig<ARFLOAT>::Eupp()
  {
  
!   seupp(rvec, HowMny, EigValR, EigVec, n, sigmaR, bmat,
!         n, which, nev, tol, resid, ncv, V, n, iparam,
!         ipntr, workd, workl, lworkl, info);
  
  } // Eupp.
  
  
  template<class ARFLOAT>
! char* ARrcSymStdEig<ARFLOAT>::CheckWhich(char* whichp)
  {
  
    switch (whichp[0]) {
--- 180,194 ----
  inline void ARrcSymStdEig<ARFLOAT>::Eupp()
  {
  
!   seupp(this->rvec, this->HowMny, this->EigValR, this->EigVec, this->n, this->sigmaR, this->bmat,
!         this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n, this->iparam,
!         this->ipntr, this->workd, this->workl, this->lworkl, this->info);
  
  } // Eupp.
  
  
  template<class ARFLOAT>
! std::string ARrcSymStdEig<ARFLOAT>::CheckWhich(const std::string& whichp)
  {
  
    switch (whichp[0]) {
***************
*** 211,223 ****
  ARFLOAT* ARrcSymStdEig<ARFLOAT>::PutVector()
  {
  
!   switch (ido) {
    case -1:
    case  1:                    // Returning OP*x.
    case  2:
!     return &workd[ipntr[2]];  // Returning B*x.
    case  3:
!     return &workl[ipntr[11]]; // Returning shifts.
    default:
      throw ArpackError(ArpackError::CANNOT_PUT_VECTOR, "PutVector");
    }
--- 212,224 ----
  ARFLOAT* ARrcSymStdEig<ARFLOAT>::PutVector()
  {
  
!   switch (this->ido) {
    case -1:
    case  1:                    // Returning OP*x.
    case  2:
!     return &this->workd[this->ipntr[2]];  // Returning B*x.
    case  3:
!     return &this->workl[this->ipntr[11]]; // Returning shifts.
    default:
      throw ArpackError(ArpackError::CANNOT_PUT_VECTOR, "PutVector");
    }
***************
*** 230,265 ****
  Eigenvalues(ARFLOAT* &EigValp, bool ivec, bool ischur)
  {
  
!   if (ValuesOK) {                      // Eigenvalues are available.
      if (EigValp == NULL) {             // Moving eigenvalues.
!       EigValp  = EigValR;
!       EigValR  = NULL;
!       newVal   = false;
!       ValuesOK = false;
      }
      else {                             // Copying eigenvalues.
!       copy(nconv,EigValR,1,EigValp,1);
      }
    }
    else {                               // Eigenvalues are not available.
!     if (newVal) {
!       delete[] EigValR;
!       newVal = false;
      }
      if (EigValp == NULL) {
!       try { EigValp = new ARFLOAT[ValSize()]; }
        catch (ArpackError) { return 0; }
      }
!     EigValR = EigValp;
      if (ivec) {                        // Finding eigenvalues and eigenvectors.
!       nconv = FindEigenvectors(ischur);
      }
      else {                             // Finding eigenvalues only.
!       nconv = FindEigenvalues();
      }
!     EigValR = NULL;
    }
!   return nconv;
  
  } // Eigenvalues(EigValp, ivec, ischur).
  
--- 231,266 ----
  Eigenvalues(ARFLOAT* &EigValp, bool ivec, bool ischur)
  {
  
!   if (this->ValuesOK) {                      // Eigenvalues are available.
      if (EigValp == NULL) {             // Moving eigenvalues.
!       EigValp  = this->EigValR;
!       this->EigValR  = NULL;
!       this->newVal   = false;
!       this->ValuesOK = false;
      }
      else {                             // Copying eigenvalues.
!       copy(this->nconv,this->EigValR,1,EigValp,1);
      }
    }
    else {                               // Eigenvalues are not available.
!     if (this->newVal) {
!       delete[] this->EigValR;
!       this->newVal = false;
      }
      if (EigValp == NULL) {
!       try { EigValp = new ARFLOAT[this->ValSize()]; }
        catch (ArpackError) { return 0; }
      }
!     this->EigValR = EigValp;
      if (ivec) {                        // Finding eigenvalues and eigenvectors.
!       this->nconv = this->FindEigenvectors(ischur);
      }
      else {                             // Finding eigenvalues only.
!       this->nconv = this->FindEigenvalues();
      }
!     this->EigValR = NULL;
    }
!   return this->nconv;
  
  } // Eigenvalues(EigValp, ivec, ischur).
  
***************
*** 269,299 ****
  EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValp, bool ischur)
  {
  
!   if (ValuesOK) {                  // Eigenvalues are already available .
!     nconv = Eigenvalues(EigValp, false);
!     nconv = Eigenvectors(EigVecp, ischur);
    }
    else {                           // Eigenvalues and vectors are not available.
      try {
!       if (EigVecp == NULL) EigVecp = new ARFLOAT[ValSize()*n];
!       if (EigValp == NULL) EigValp = new ARFLOAT[ValSize()];
      }
      catch (ArpackError) { return 0; }
!     if (newVec) {
!       delete[] EigVec;
!       newVec = false;
      }
!     if (newVal) {
!       delete[] EigValR;
!       newVal = false;
      }
!     EigVec  = EigVecp;
!     EigValR = EigValp;
!     nconv   = FindEigenvectors(ischur);
!     EigVec  = NULL;
!     EigValR = NULL;
    }
!   return nconv;
  
  } // EigenValVectors(EigVecp, EigValp, ischur).
  
--- 270,300 ----
  EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValp, bool ischur)
  {
  
!   if (this->ValuesOK) {                  // Eigenvalues are already available .
!     this->nconv = Eigenvalues(EigValp, false);
!     this->nconv = this->Eigenvectors(EigVecp, ischur);
    }
    else {                           // Eigenvalues and vectors are not available.
      try {
!       if (EigVecp == NULL) EigVecp = new ARFLOAT[this->ValSize()*this->n];
!       if (EigValp == NULL) EigValp = new ARFLOAT[this->ValSize()];
      }
      catch (ArpackError) { return 0; }
!     if (this->newVec) {
!       delete[] this->EigVec;
!       this->newVec = false;
      }
!     if (this->newVal) {
!       delete[] this->EigValR;
!       this->newVal = false;
      }
!     this->EigVec  = EigVecp;
!     this->EigValR = EigValp;
!     this->nconv   = this->FindEigenvectors(ischur);
!     this->EigVec  = NULL;
!     this->EigValR = NULL;
    }
!   return this->nconv;
  
  } // EigenValVectors(EigVecp, EigValp, ischur).
  
***************
*** 304,316 ****
  
    // Returning i-eth eigenvalue.
  
!   if (!ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
    }
!   else if ((i>=nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
    }
!   return EigValR[i];
  
  } // Eigenvalue(i).
  
--- 305,317 ----
  
    // Returning i-eth eigenvalue.
  
!   if (!this->ValuesOK) {
      throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
    }
!   else if ((i>=this->nconv)||(i<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
    }
!   return this->EigValR[i];
  
  } // Eigenvalue(i).
  
***************
*** 321,333 ****
  
    // Returning element j of i-eth eigenvector.
  
!   if (!VectorsOK) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
    }
!   else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
    }
!   return EigVec[i*n+j];
  
  } // Eigenvector(i,j).
  
--- 322,334 ----
  
    // Returning element j of i-eth eigenvector.
  
!   if (!this->VectorsOK) {
      throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
    }
!   else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
      throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
    }
!   return this->EigVec[i*this->n+j];
  
  } // Eigenvector(i,j).
  
***************
*** 380,406 ****
  
  template<class ARFLOAT>
  inline ARrcSymStdEig<ARFLOAT>::
! ARrcSymStdEig(int np, int nevp, char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcSymStdEig<ARFLOAT>::
! ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp,
                int ncvp, ARFLOAT tolp, int maxitp, ARFLOAT* residp,
                bool ishiftp)
  
  {
  
!   ChangeShift(sigmap);
!   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
--- 381,407 ----
  
  template<class ARFLOAT>
  inline ARrcSymStdEig<ARFLOAT>::
! ARrcSymStdEig(int np, int nevp, const std::string& whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
  
  
  template<class ARFLOAT>
  inline ARrcSymStdEig<ARFLOAT>::
! ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, const std::string& whichp,
                int ncvp, ARFLOAT tolp, int maxitp, ARFLOAT* residp,
                bool ishiftp)
  
  {
  
!   this->ChangeShift(sigmap);
!   this->DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (shift and invert mode).
  
***************
*** 411,417 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 412,418 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arscomp.h arpack++new/include/arscomp.h
*** arpack++/include/arscomp.h	2000-02-21 08:36:40.000000000 -0500
--- arpack++new/include/arscomp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARSCOMP_H
  #define ARSCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arseig.h"
  #include "arrscomp.h"
--- 17,24 ----
  #ifndef ARSCOMP_H
  #define ARSCOMP_H
  
! #include <cstddef>
! 
  #include "arch.h"
  #include "arseig.h"
  #include "arrscomp.h"
***************
*** 36,49 ****
  
    ARCompStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!                char* whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARCompStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!                arcomplex<ARFLOAT> sigma,  char* whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 37,50 ----
  
    ARCompStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!                const std::string& whichp = "LM", int ncvp = 0,
                 ARFLOAT tolp = 0.0, int maxitp = 0,
                 arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARCompStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!                arcomplex<ARFLOAT> sigma,  const std::string& whichp = "LM",
                 int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                 arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 71,82 ****
  inline ARCompStdEig<ARFLOAT, ARFOP>::
  ARCompStdEig(int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!              char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
               arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
  
--- 72,83 ----
  inline ARCompStdEig<ARFLOAT, ARFOP>::
  ARCompStdEig(int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!              const std::string& whichp, int ncvp, ARFLOAT tolp, int maxitp,
               arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 87,93 ****
  inline ARCompStdEig<ARFLOAT, ARFOP>::
  ARCompStdEig(int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!              arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
               ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
               bool ishiftp)
  
--- 88,94 ----
  inline ARCompStdEig<ARFLOAT, ARFOP>::
  ARCompStdEig(int np, int nevp, ARFOP* objOPp,
               void (ARFOP::* MultOPxp)(arcomplex<ARFLOAT>[],arcomplex<ARFLOAT>[]),
!              arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
               ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
               bool ishiftp)
  
***************
*** 106,112 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 107,113 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arseig.h arpack++new/include/arseig.h
*** arpack++/include/arseig.h	2000-03-03 11:14:14.000000000 -0500
--- arpack++new/include/arseig.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 19,25 ****
  #ifndef ARSEIG_H
  #define ARSEIG_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arerror.h"
  #include "arrseig.h"
--- 19,25 ----
  #ifndef ARSEIG_H
  #define ARSEIG_H
  
! #include <cstddef>
  #include "arch.h"
  #include "arerror.h"
  #include "arrseig.h"
***************
*** 58,64 ****
   // d.1) Function that stores user defined parameters.
  
    virtual void DefineParameters(int np, int nevp, ARFOP* objOPp,
!                                 TypeOPx MultOPxp, char* whichp="LM",
                                  int ncvp=0, ARFLOAT tolp=0.0, int maxitp=0,
                                  ARTYPE* residp=NULL, bool ishiftp=true);
    // Set values of problem parameters (also called by constructors).
--- 58,64 ----
   // d.1) Function that stores user defined parameters.
  
    virtual void DefineParameters(int np, int nevp, ARFOP* objOPp,
!                                 TypeOPx MultOPxp, const std::string& whichp="LM",
                                  int ncvp=0, ARFLOAT tolp=0.0, int maxitp=0,
                                  ARTYPE* residp=NULL, bool ishiftp=true);
    // Set values of problem parameters (also called by constructors).
***************
*** 130,136 ****
  template<class ARFLOAT, class ARTYPE, class ARFOP>
  void ARStdEig<ARFLOAT, ARTYPE, ARFOP>::
  DefineParameters(int np, int nevp, ARFOP* objOPp,
!                  void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]), char* whichp,
                   int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp, 
                   bool ishiftp)
  
--- 130,136 ----
  template<class ARFLOAT, class ARTYPE, class ARFOP>
  void ARStdEig<ARFLOAT, ARTYPE, ARFOP>::
  DefineParameters(int np, int nevp, ARFOP* objOPp,
!                  void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]), const std::string& whichp,
                   int ncvp, ARFLOAT tolp, int maxitp, ARTYPE* residp, 
                   bool ishiftp)
  
***************
*** 152,158 ****
  
    objOP   = objOPp;
    MultOPx = MultOPxp;
!   Restart();
  
  } // ChangeMultOPx.
  
--- 152,158 ----
  
    objOP   = objOPp;
    MultOPx = MultOPxp;
!   this->Restart();
  
  } // ChangeMultOPx.
  
***************
*** 163,169 ****
  {
  
    ChangeMultOPx(objOPp, MultOPxp);
!   NoShift();
  
  } // SetRegularMode.
  
--- 163,169 ----
  {
  
    ChangeMultOPx(objOPp, MultOPxp);
!   this->NoShift();
  
  } // SetRegularMode.
  
***************
*** 175,181 ****
  {
  
    ChangeMultOPx(objOPp, MultOPxp);
!   ChangeShift(sigmap);
  
  } // SetShiftInvertMode.
  
--- 175,181 ----
  {
  
    ChangeMultOPx(objOPp, MultOPxp);
!   this->ChangeShift(sigmap);
  
  } // SetShiftInvertMode.
  
***************
*** 184,220 ****
  int ARStdEig<ARFLOAT, ARTYPE, ARFOP>::FindArnoldiBasis()
  {
  
!   if (!BasisOK) Restart();
  
    // Changing to auto shift mode.
  
!   if (!AutoShift) {
      ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
!     AutoShift=true;
    }
  
    // ARPACK main loop.
  
!   while (!BasisOK) {
  
      // Calling Aupp.
  
!     try { TakeStep(); }
      catch (ArpackError) {
        ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
        return 0;
      }
  
!     if ((ido == -1) || (ido == 1)) {
  
        // Performing Matrix vector multiplication: y <- OP*x.
  
!       (objOP->*MultOPx)(&workd[ipntr[1]],&workd[ipntr[2]]);
  
      }
  
    }
!   return nconv;
  
  } // FindArnoldiBasis.
  
--- 184,220 ----
  int ARStdEig<ARFLOAT, ARTYPE, ARFOP>::FindArnoldiBasis()
  {
  
!   if (!this->BasisOK) this->Restart();
  
    // Changing to auto shift mode.
  
!   if (!this->AutoShift) {
      ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
!     this->AutoShift=true;
    }
  
    // ARPACK main loop.
  
!   while (!this->BasisOK) {
  
      // Calling Aupp.
  
!     try { this->TakeStep(); }
      catch (ArpackError) {
        ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
        return 0;
      }
  
!     if ((this->ido == -1) || (this->ido == 1)) {
  
        // Performing Matrix vector multiplication: y <- OP*x.
  
!       (objOP->*MultOPx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
  
      }
  
    }
!   return this->nconv;
  
  } // FindArnoldiBasis.
  
***************
*** 225,231 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 225,231 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arsnsym.h arpack++new/include/arsnsym.h
*** arpack++/include/arsnsym.h	2000-02-21 07:06:14.000000000 -0500
--- arpack++new/include/arsnsym.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARSNSYM_H
  #define ARSNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arseig.h"
  #include "arrsnsym.h"
--- 17,24 ----
  #ifndef ARSNSYM_H
  #define ARSNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arseig.h"
  #include "arrsnsym.h"
***************
*** 37,49 ****
  
    ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                  char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                  ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 38,50 ----
  
    ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                  const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                   int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                   void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                  ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                   bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 71,82 ****
  inline ARNonSymStdEig<ARFLOAT, ARFOP>::
  ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                char* whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
  
--- 72,83 ----
  inline ARNonSymStdEig<ARFLOAT, ARFOP>::
  ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                const std::string& whichp, int ncvp, ARFLOAT tolp, int maxitp,
                 ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
    DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
  
***************
*** 87,93 ****
  inline ARNonSymStdEig<ARFLOAT, ARFOP>::
  ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
--- 88,94 ----
  inline ARNonSymStdEig<ARFLOAT, ARFOP>::
  ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,
                 void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!                ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 105,111 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 106,112 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arssym.h arpack++new/include/arssym.h
*** arpack++/include/arssym.h	2000-02-21 07:05:00.000000000 -0500
--- arpack++new/include/arssym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 17,23 ****
  #ifndef ARSSYM_H
  #define ARSSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arseig.h"
  #include "arrssym.h"
--- 17,24 ----
  #ifndef ARSSYM_H
  #define ARSSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arseig.h"
  #include "arrssym.h"
***************
*** 37,49 ****
  
    ARSymStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!               char* whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARSymStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!               ARFLOAT sigmap, char* whichp = "LM", int ncvp = 0,
                ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 38,50 ----
  
    ARSymStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!               const std::string& whichp = "LM", int ncvp = 0, ARFLOAT tolp = 0.0,
                int maxitp = 0, ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARSymStdEig(int np, int nevp, ARFOP* objOPp,
                void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!               ARFLOAT sigmap, const std::string& whichp = "LM", int ncvp = 0,
                ARFLOAT tolp = 0.0, int maxitp = 0, ARFLOAT* residp = NULL,
                bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 71,83 ****
  inline ARSymStdEig<ARFLOAT, ARFOP>::
  ARSymStdEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!             char* whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
!   DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
--- 72,84 ----
  inline ARSymStdEig<ARFLOAT, ARFOP>::
  ARSymStdEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!             const std::string& whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
!   this->DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
***************
*** 87,93 ****
  inline ARSymStdEig<ARFLOAT, ARFOP>::
  ARSymStdEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!             ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
--- 88,94 ----
  inline ARSymStdEig<ARFLOAT, ARFOP>::
  ARSymStdEig(int np, int nevp, ARFOP* objOPp,
              void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]),
!             ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
              int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 105,111 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 106,112 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arugcomp.h arpack++new/include/arugcomp.h
*** arpack++/include/arugcomp.h	2000-02-21 12:46:32.000000000 -0500
--- arpack++new/include/arugcomp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARUGCOMP_H
  #define ARUGCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arunsmat.h"
  #include "arunspen.h"
--- 18,25 ----
  #ifndef ARUGCOMP_H
  #define ARUGCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arunsmat.h"
  #include "arunspen.h"
***************
*** 65,78 ****
  
    ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 66,79 ----
  
    ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                   ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 103,110 ****
    ARCompGenEig<ARFLOAT, ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
  
  } // Copy.
  
--- 104,111 ----
    ARCompGenEig<ARFLOAT, ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                 ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
  
  } // Copy.
  
***************
*** 114,120 ****
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   objOP->FactorAsB(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
--- 115,121 ----
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   this->objOP->FactorAsB(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
***************
*** 148,161 ****
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, char* whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
    DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
--- 149,162 ----
  template<class ARFLOAT>
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B, const std::string& whichp,
                 int ncvp, ARFLOAT tolp, int maxitp,
                 arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
    DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                     &Pencil, 
***************
*** 169,175 ****
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
--- 170,176 ----
  inline ARluCompGenEig<ARFLOAT>::
  ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
                 ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& B,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
***************
*** 192,198 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 193,199 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arugnsym.h arpack++new/include/arugnsym.h
*** arpack++/include/arugnsym.h	2000-02-21 12:42:32.000000000 -0500
--- arpack++new/include/arugnsym.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARUGNSYM_H
  #define ARUGNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arunsmat.h"
  #include "arunspen.h"
--- 18,25 ----
  #ifndef ARUGNSYM_H
  #define ARUGNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arunsmat.h"
  #include "arunspen.h"
***************
*** 65,85 ****
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, char* whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
--- 66,86 ----
    // Short constructor.
  
    ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigma,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (real shift and invert mode).
  
    ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                     ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, char partp,
!                    ARFLOAT sigmaRp, ARFLOAT sigmaIp, const std::string& whichp = "LM",
                     int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (complex shift and invert mode).
***************
*** 111,119 ****
    ARNonSymGenEig<ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARumNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
  
  } // Copy.
  
--- 112,120 ----
    ARNonSymGenEig<ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT>,
                   ARumNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
  
  } // Copy.
  
***************
*** 124,133 ****
  {
  
    if (sigmaIp == 0.0) {
!     objOP->FactorAsB(sigmaRp);
    }
    else {
!     objOP->FactorAsB(sigmaRp, sigmaIp, part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
--- 125,134 ----
  {
  
    if (sigmaIp == 0.0) {
!     this->objOP->FactorAsB(sigmaRp);
    }
    else {
!     this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
    }
    ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
  
***************
*** 173,185 ****
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, char* whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   NoShift();
    DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
--- 174,186 ----
  template<class ARFLOAT>
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, const std::string& whichp, int ncvp,
                   ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->NoShift();
    DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                     &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
***************
*** 192,198 ****
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
--- 193,199 ----
  inline ARluNonSymGenEig<ARFLOAT>::
  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, ARFLOAT sigmap,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 212,218 ****
  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
                   char partp, ARFLOAT sigmaRp,
!                  ARFLOAT sigmaIp, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
--- 213,219 ----
  ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
                   ARumNonSymMatrix<ARFLOAT, ARFLOAT>& B, 
                   char partp, ARFLOAT sigmaRp,
!                  ARFLOAT sigmaIp, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 233,239 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 234,240 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arugsym.h arpack++new/include/arugsym.h
*** arpack++/include/arugsym.h	2000-02-21 12:00:41.000000000 -0500
--- arpack++new/include/arugsym.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 19,25 ****
  #ifndef ARUGSYM_H
  #define ARUGSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arusmat.h"
  #include "aruspen.h"
--- 19,26 ----
  #ifndef ARUGSYM_H
  #define ARUGSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arusmat.h"
  #include "aruspen.h"
***************
*** 67,79 ****
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 ARumSymMatrix<ARFLOAT>& B, char* whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 ARumSymMatrix<ARFLOAT>& B, ARFLOAT sigma, char* whichp = "LM", 
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
--- 68,80 ----
    // Short constructor.
  
    ARluSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 ARumSymMatrix<ARFLOAT>& B, const std::string& whichp = "LM",
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 ARumSymMatrix<ARFLOAT>& B, ARFLOAT sigma, const std::string& whichp = "LM", 
                  int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert, buckling and Cayley modes).
***************
*** 105,113 ****
    ARSymGenEig<ARFLOAT, ARumSymPencil<ARFLOAT>,
                ARumSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   objOP  = &Pencil;
!   objB   = &Pencil;
!   objA   = &Pencil;
  
  } // Copy.
  
--- 106,114 ----
    ARSymGenEig<ARFLOAT, ARumSymPencil<ARFLOAT>,
                ARumSymPencil<ARFLOAT> >:: Copy(other);
    Pencil = other.Pencil;
!   this->objOP  = &Pencil;
!   this->objB   = &Pencil;
!   this->objA   = &Pencil;
  
  } // Copy.
  
***************
*** 116,122 ****
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
--- 117,123 ----
  inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
  {
  
!   this->objOP->FactorAsB(sigmap);
    ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
  
  } // ChangeShift.
***************
*** 172,185 ****
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!               ARumSymMatrix<ARFLOAT>& B, char* whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   InvertMode = 'S';
!   NoShift();
    DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARumSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARumSymPencil<ARFLOAT>::MultBv, whichp,
--- 173,186 ----
  template<class ARFLOAT>
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!               ARumSymMatrix<ARFLOAT>& B, const std::string& whichp, int ncvp,
                ARFLOAT tolp, int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
    Pencil.DefineMatrices(A, B);
!   this->InvertMode = 'S';
!   this->NoShift();
    DefineParameters(A.ncols(), nevp, &Pencil,
                     &ARumSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                     &ARumSymPencil<ARFLOAT>::MultBv, whichp,
***************
*** 192,198 ****
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
                ARumSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
--- 193,199 ----
  inline ARluSymGenEig<ARFLOAT>::
  ARluSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,
                ARumSymMatrix<ARFLOAT>& B, ARFLOAT sigmap,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 202,209 ****
                     &ARumSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARumSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   InvertMode = CheckInvertMode(InvertModep);
!   switch (InvertMode) {
    case 'B':  // Buckling mode.
      ChangeMultBx(&Pencil, &ARumSymPencil<ARFLOAT>::MultAv);
    case 'S':  // Shift and invert mode.
--- 203,210 ----
                     &ARumSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                     &ARumSymPencil<ARFLOAT>::MultBv, whichp,
                     ncvp, tolp, maxitp, residp, ishiftp);
!   this->InvertMode = this->CheckInvertMode(InvertModep);
!   switch (this->InvertMode) {
    case 'B':  // Buckling mode.
      ChangeMultBx(&Pencil, &ARumSymPencil<ARFLOAT>::MultAv);
    case 'S':  // Shift and invert mode.
***************
*** 222,228 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 223,229 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!    this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arunsmat.h arpack++new/include/arunsmat.h
*** arpack++/include/arunsmat.h	2000-02-21 11:42:41.000000000 -0500
--- arpack++new/include/arunsmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARUNSMAT_H
  #define ARUNSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
--- 20,27 ----
  #ifndef ARUNSMAT_H
  #define ARUNSMAT_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
***************
*** 115,121 ****
                     int* irowp, int* pcolp);
    // Long constructor (rectangular matrix).
  
!   ARumNonSymMatrix(char* name, double thresholdp = 0.1,
                     int fillinp = 9, bool simest = false,
                     bool reducible = true, bool check = true);
    // Long constructor (Harwell-Boeing file).
--- 116,122 ----
                     int* irowp, int* pcolp);
    // Long constructor (rectangular matrix).
  
!   ARumNonSymMatrix(const std::string& name, double thresholdp = 0.1,
                     int fillinp = 9, bool simest = false,
                     bool reducible = true, bool check = true);
    // Long constructor (Harwell-Boeing file).
***************
*** 145,160 ****
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
!       if ((irow[j]<0)||(irow[k]>=n)) return false;
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
      }  
--- 146,161 ----
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=this->n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=this->n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
!       if ((irow[j]<0)||(irow[k]>=this->n)) return false;
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
      }  
***************
*** 190,198 ****
  
    // Copying very fundamental variables and user-defined parameters.
  
!   m         = other.m;
!   n         = other.n;
!   defined   = other.defined;
    factored  = other.factored;
    fillin    = other.fillin;
    nnz       = other.nnz;
--- 191,199 ----
  
    // Copying very fundamental variables and user-defined parameters.
  
!   this->m         = other.m;
!   this->n         = other.n;
!   this->defined   = other.defined;
    factored  = other.factored;
    fillin    = other.fillin;
    nnz       = other.nnz;
***************
*** 205,211 ****
  
    // Returning from here if "other" was not initialized.
  
!   if (!defined) return;
  
    // Copying arrays with static dimension.
  
--- 206,212 ----
  
    // Returning from here if "other" was not initialized.
  
!   if (!this->defined) return;
  
    // Copying arrays with static dimension.
  
***************
*** 237,246 ****
    // Subtracting sigma from diagonal elements.
  
    k        = 0;
!   ki       = n+1;
    index[0] = 1;
  
!   for (i=0; i!=n; i++) {
  
      j = pcol[i];
      end = pcol[i+1];
--- 238,247 ----
    // Subtracting sigma from diagonal elements.
  
    k        = 0;
!   ki       = this->n+1;
    index[0] = 1;
  
!   for (i=0; i!=this->n; i++) {
  
      j = pcol[i];
      end = pcol[i+1];
***************
*** 280,290 ****
  inline void ARumNonSymMatrix<ARTYPE, ARFLOAT>::CreateStructure()
  {
  
!   int dimfact = (((fillin+1)*nnz)<(n*n)) ? (fillin+1)*nnz : n*n;
  
!   ClearMem();
  
!   lindex = 30*n+dimfact;     // ?????
    lvalue = dimfact;
  
    value  = new ARTYPE[lvalue];
--- 281,291 ----
  inline void ARumNonSymMatrix<ARTYPE, ARFLOAT>::CreateStructure()
  {
  
!   int dimfact = (((fillin+1)*nnz)<(this->n*this->n)) ? (fillin+1)*nnz : this->n*this->n;
  
!   this->ClearMem();
  
!   lindex = 30*this->n+dimfact;     // ?????
    lvalue = dimfact;
  
    value  = new ARTYPE[lvalue];
***************
*** 319,331 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::FactorA");
    }
  
    // Quitting the function if A is not square.
  
!   if (m != n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARumNonSymMatrix::FactorA");
    }
--- 320,332 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::FactorA");
    }
  
    // Quitting the function if A is not square.
  
!   if (this->m != this->n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARumNonSymMatrix::FactorA");
    }
***************
*** 344,356 ****
    copy(nnz, a, 1, value, 1);
    pi=pcol;
    pj=index;
!   for (i=0; i<=n; i++) *pj++ = (*pi++)+1;
    pi=irow;
    for (i=0; i<nnz; i++) *pj++ = (*pi++)+1;
  
    // Decomposing A.
  
!   um2fa(n, nnz, 0, false, lvalue, lindex, value, 
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
--- 345,357 ----
    copy(nnz, a, 1, value, 1);
    pi=pcol;
    pj=index;
!   for (i=0; i<=this->n; i++) *pj++ = (*pi++)+1;
    pi=irow;
    for (i=0; i<nnz; i++) *pj++ = (*pi++)+1;
  
    // Decomposing A.
  
!   um2fa(this->n, nnz, 0, false, lvalue, lindex, value, 
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
***************
*** 368,381 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARumNonSymMatrix::FactorAsI");
    }
  
    // Quitting the function if A is not square.
  
!   if (m != n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARumNonSymMatrix::FactorAsI");
    }
--- 369,382 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,
                        "ARumNonSymMatrix::FactorAsI");
    }
  
    // Quitting the function if A is not square.
  
!   if (this->m != this->n) {
      throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                        "ARumNonSymMatrix::FactorAsI");
    }
***************
*** 390,396 ****
  
    // Decomposing AsI.
  
!   um2fa(n, nnz, 0, false, lvalue, lindex, value,
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
--- 391,397 ----
  
    // Decomposing AsI.
  
!   um2fa(this->n, nnz, 0, false, lvalue, lindex, value,
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
***************
*** 411,425 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumNonSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
  
!   for (i=0; i!=n; i++) {
      t = v[i];
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        w[irow[j]] += t*a[j];
--- 412,426 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumNonSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
  
!   for (i=0; i!=this->n; i++) {
      t = v[i];
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        w[irow[j]] += t*a[j];
***************
*** 438,450 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::MultMtv");
    }
  
    // Determining w = M'.v.
  
!   for (i=0; i!=n; i++) {
      t = (ARTYPE)0;
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        t += v[irow[j]]*a[j];
--- 439,451 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::MultMtv");
    }
  
    // Determining w = M'.v.
  
!   for (i=0; i!=this->n; i++) {
      t = (ARTYPE)0;
      for (j=pcol[i]; j!=pcol[i+1]; j++) {
        t += v[irow[j]]*a[j];
***************
*** 459,465 ****
  void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[m];
  
    MultMv(v,t);
    MultMtv(t,w);
--- 460,466 ----
  void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[this->m];
  
    MultMv(v,t);
    MultMtv(t,w);
***************
*** 473,479 ****
  void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[n];
  
    MultMtv(v,t);
    MultMv(t,w);
--- 474,480 ----
  void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
  {
  
!   ARTYPE* t = new ARTYPE[this->n];
  
    MultMtv(v,t);
    MultMv(t,w);
***************
*** 487,494 ****
  void ARumNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[m],w);
!   MultMtv(v,&w[m]);
  
  } // Mult0MMt0v.
  
--- 488,495 ----
  void ARumNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
  {
  
!   MultMv(&v[this->m],w);
!   MultMtv(v,&w[this->m]);
  
  } // Mult0MMt0v.
  
***************
*** 506,514 ****
  
    // Solving A.w = v (or AsI.w = v).
  
!   ARTYPE* space = new ARTYPE[2*n];
  
!   um2so(n, 0, false, lvalue, lindex, value, index,
          keep, v, w, space, cntl, icntl, info, rinfo);
  
    delete[] space;
--- 507,515 ----
  
    // Solving A.w = v (or AsI.w = v).
  
!   ARTYPE* space = new ARTYPE[2*this->n];
  
!   um2so(this->n, 0, false, lvalue, lindex, value, index,
          keep, v, w, space, cntl, icntl, info, rinfo);
  
    delete[] space;
***************
*** 525,537 ****
  
    // Defining member variables.
  
!   m         = np;
!   n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[n]   = nnz;
    fillin    = (fillinp>2) ? fillinp : 2;
    threshold = thresholdp;
    value     = NULL;
--- 526,538 ----
  
    // Defining member variables.
  
!   this->m         = np;
!   this->n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[this->n]   = nnz;
    fillin    = (fillinp>2) ? fillinp : 2;
    threshold = thresholdp;
    value     = NULL;
***************
*** 548,554 ****
                        "ARumNonSymMatrix::DefineMatrix");
    }
    else {
!     defined = true;
    }
  
  } // DefineMatrix (square).
--- 549,555 ----
                        "ARumNonSymMatrix::DefineMatrix");
    }
    else {
!     this->defined = true;
    }
  
  } // DefineMatrix (square).
***************
*** 561,575 ****
  
    // Defining member variables.
  
!   m        = mp;
!   n        = np;
    nnz      = nnzp;
    a        = ap;
    irow     = irowp;
    pcol     = pcolp;
!   pcol[n]  = nnz;
    fillin   = 0;
!   defined  = true;
  
  } // DefineMatrix (rectangular).
  
--- 562,576 ----
  
    // Defining member variables.
  
!   this->m        = mp;
!   this->n        = np;
    nnz      = nnzp;
    a        = ap;
    irow     = irowp;
    pcol     = pcolp;
!   pcol[this->n]  = nnz;
    fillin   = 0;
!   this->defined  = true;
  
  } // DefineMatrix (rectangular).
  
***************
*** 602,608 ****
  
  template<class ARTYPE, class ARFLOAT>
  ARumNonSymMatrix<ARTYPE, ARFLOAT>::
! ARumNonSymMatrix(char* name, double thresholdp, int fillinp,
                   bool simest, bool reducible, bool check)
  {
  
--- 603,609 ----
  
  template<class ARTYPE, class ARFLOAT>
  ARumNonSymMatrix<ARTYPE, ARFLOAT>::
! ARumNonSymMatrix(const std::string& name, double thresholdp, int fillinp,
                   bool simest, bool reducible, bool check)
  {
  
diff -crB arpack++/include/aruscomp.h arpack++new/include/aruscomp.h
*** arpack++/include/aruscomp.h	2000-02-21 12:38:55.000000000 -0500
--- arpack++new/include/aruscomp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARUSCOMP_H
  #define ARUSCOMP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arscomp.h"
  #include "arunsmat.h"
--- 18,25 ----
  #ifndef ARUSCOMP_H
  #define ARUSCOMP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arscomp.h"
  #include "arunsmat.h"
***************
*** 48,60 ****
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
!                  char* whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, char* whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 49,61 ----
    // Short constructor.
  
    ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A, 
!                  const std::string& whichp = "LM", int ncvp = 0,
                   ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                  arcomplex<ARFLOAT> sigma, const std::string& whichp = "LM",
                   int ncvp = 0, ARFLOAT tolp = 0.0, int maxitp = 0,
                   arcomplex<ARFLOAT>* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 84,90 ****
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   objOP->FactorAsI(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
--- 85,91 ----
  ChangeShift(arcomplex<ARFLOAT> sigmaRp)
  {
  
!   this->objOP->FactorAsI(sigmaRp);
    ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
  
  } // ChangeShift.
***************
*** 96,102 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetRegularMode(objOP, 
                     &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
--- 97,103 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetRegularMode(this->objOP, 
                     &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
***************
*** 109,115 ****
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP,
                         &ARumNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 110,116 ----
  
    ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
             ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP,
                         &ARumNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 118,129 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                char* whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   NoShift();
    DefineParameters(A.ncols(), nevp, &A,
                     &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
--- 119,130 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                const std::string& whichp, int ncvp, ARFLOAT tolp,
                 int maxitp, arcomplex<ARFLOAT>* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
    DefineParameters(A.ncols(), nevp, &A,
                     &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 134,140 ****
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, char* whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
--- 135,141 ----
  template<class ARFLOAT>
  inline ARluCompStdEig<ARFLOAT>::
  ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,
!                arcomplex<ARFLOAT> sigmap, const std::string& whichp, int ncvp,
                 ARFLOAT tolp, int maxitp, arcomplex<ARFLOAT>* residp,
                 bool ishiftp)
  
***************
*** 154,160 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 155,161 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arusmat.h arpack++new/include/arusmat.h
*** arpack++/include/arusmat.h	2000-02-21 11:53:51.000000000 -0500
--- arpack++new/include/arusmat.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 20,26 ****
  #ifndef ARUSMAT_H
  #define ARUSMAT_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
--- 20,27 ----
  #ifndef ARUSMAT_H
  #define ARUSMAT_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "armat.h"
  #include "arhbmat.h"
***************
*** 96,102 ****
                  int fillinp = 9, bool reducible = true, bool check = true);
    // Long constructor.
  
!   ARumSymMatrix(char* name, double thresholdp = 0.1, int fillinp = 9,
                  bool reducible = true, bool check = true);
    // Long constructor (Harwell-Boeing file).
  
--- 97,103 ----
                  int fillinp = 9, bool reducible = true, bool check = true);
    // Long constructor.
  
!   ARumSymMatrix(const std::string& name, double thresholdp = 0.1, int fillinp = 9,
                  bool reducible = true, bool check = true);
    // Long constructor (Harwell-Boeing file).
  
***************
*** 125,136 ****
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
--- 126,137 ----
    // Checking if pcol is in ascending order.
  
    i = 0;
!   while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
!   if (i!=this->n) return false;
  
    // Checking if irow components are in order and within bounds.
  
!   for (i=0; i!=this->n; i++) {
      j = pcol[i];
      k = pcol[i+1]-1;
      if (j<=k) {
***************
*** 138,144 ****
          if ((irow[j]<0)||(irow[k]>i)) return false;
        }
        else { // uplo == 'L'.
!         if ((irow[j]<i)||(irow[k]>=n)) return false;
        }
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
--- 139,145 ----
          if ((irow[j]<0)||(irow[k]>i)) return false;
        }
        else { // uplo == 'L'.
!         if ((irow[j]<i)||(irow[k]>=this->n)) return false;
        }
        while ((j!=k)&&(irow[j]<irow[j+1])) j++;
        if (j!=k) return false;
***************
*** 174,182 ****
  
    // Copying very fundamental variables and user-defined parameters.
  
!   m         = other.m;
!   n         = other.n;
!   defined   = other.defined;
    factored  = other.factored;
    fillin    = other.fillin;
    nnz       = other.nnz;
--- 175,183 ----
  
    // Copying very fundamental variables and user-defined parameters.
  
!   this->m         = other.m;
!   this->n         = other.n;
!   this->defined   = other.defined;
    factored  = other.factored;
    fillin    = other.fillin;
    nnz       = other.nnz;
***************
*** 190,196 ****
  
    // Returning from here if "other" was not initialized.
  
!   if (!defined) return;
  
    // Copying arrays with static dimension.
  
--- 191,197 ----
  
    // Returning from here if "other" was not initialized.
  
!   if (!this->defined) return;
  
    // Copying arrays with static dimension.
  
***************
*** 226,238 ****
  
    // Filling index with zeros.
  
!   for (i=0; i<=n; i++) index[i] = 0;
  
    // Counting the elements in each column of A.
  
    if (uplo == 'U') {
  
!     for (i=0; i!=n; i++) {
        k = pcol[i+1];
        if ((k!=pcol[i])&&(irow[k-1]==i)) {
          k--;
--- 227,239 ----
  
    // Filling index with zeros.
  
!   for (i=0; i<=this->n; i++) index[i] = 0;
  
    // Counting the elements in each column of A.
  
    if (uplo == 'U') {
  
!     for (i=0; i!=this->n; i++) {
        k = pcol[i+1];
        if ((k!=pcol[i])&&(irow[k-1]==i)) {
          k--;
***************
*** 246,252 ****
    }
    else { // uplo == 'L'
  
!     for (i=0; i!=n; i++) {
        k = pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
          k++;
--- 247,253 ----
    }
    else { // uplo == 'L'
  
!     for (i=0; i!=this->n; i++) {
        k = pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
          k++;
***************
*** 261,280 ****
  
    // Summing up index elements.
  
!   for (i=0; i<n; i++) index[i+1]+=index[i];
  
    // Adding pcol to index.
  
!   for (i=n; i>0; i--) index[i] = index[i-1]+pcol[i];
    index[0] = pcol[0];    
  
    // Expanding A.
  
!   ki = n+1;
  
    if (uplo == 'U') {
  
!     for (i=0; i<n; i++) {
        for (j=pcol[i]; j<(pcol[i+1]-1); j++) {
          index[ki+index[i]] = irow[j]+1;
          index[ki+index[irow[j]]] = i+1; 
--- 262,281 ----
  
    // Summing up index elements.
  
!   for (i=0; i<this->n; i++) index[i+1]+=index[i];
  
    // Adding pcol to index.
  
!   for (i=this->n; i>0; i--) index[i] = index[i-1]+pcol[i];
    index[0] = pcol[0];    
  
    // Expanding A.
  
!   ki = this->n+1;
  
    if (uplo == 'U') {
  
!     for (i=0; i<this->n; i++) {
        for (j=pcol[i]; j<(pcol[i+1]-1); j++) {
          index[ki+index[i]] = irow[j]+1;
          index[ki+index[irow[j]]] = i+1; 
***************
*** 301,307 ****
    }
    else { // uplo  == 'L'
  
!     for (i=0; i<n; i++) {
        k=pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
          index[ki+index[i]] = i+1;
--- 302,308 ----
    }
    else { // uplo  == 'L'
  
!     for (i=0; i<this->n; i++) {
        k=pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
          index[ki+index[i]] = i+1;
***************
*** 331,337 ****
  
    // Adjusting index.
  
!   for (i=n; i>0; i--) {
      index[i] = index[i-1]+1;
    } 
    index[0] = 1;
--- 332,338 ----
  
    // Adjusting index.
  
!   for (i=this->n; i>0; i--) {
      index[i] = index[i-1]+1;
    } 
    index[0] = 1;
***************
*** 343,353 ****
  inline void ARumSymMatrix<ARTYPE>::CreateStructure()
  {
  
!   int dimfact = (((fillin+1)*nnz*2)<(n*n)) ? (fillin+1)*nnz*2 : n*n;
  
    ClearMem();
  
!   lindex = 30*n+dimfact;          // ?????
    lvalue = dimfact;
  
    value  = new ARTYPE[lvalue];
--- 344,354 ----
  inline void ARumSymMatrix<ARTYPE>::CreateStructure()
  {
  
!   int dimfact = (((fillin+1)*nnz*2)<(this->n*this->n)) ? (fillin+1)*nnz*2 : this->n*this->n;
  
    ClearMem();
  
!   lindex = 30*this->n+dimfact;          // ?????
    lvalue = dimfact;
  
    value  = new ARTYPE[lvalue];
***************
*** 382,388 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorA");
    }
  
--- 383,389 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorA");
    }
  
***************
*** 396,402 ****
  
    // Decomposing A.
  
!   um2fa(n, index[n], 0, false, lvalue, lindex, value, 
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
--- 397,403 ----
  
    // Decomposing A.
  
!   um2fa(this->n, index[this->n], 0, false, lvalue, lindex, value, 
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
***************
*** 414,420 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorAsI");
    }
  
--- 415,421 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorAsI");
    }
  
***************
*** 428,434 ****
  
    // Decomposing AsI.
  
!   um2fa(n, index[n], 0, false, lvalue, lindex, value,
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
--- 429,435 ----
  
    // Decomposing AsI.
  
!   um2fa(this->n, index[this->n], 0, false, lvalue, lindex, value,
          index, keep, cntl, icntl, info, rinfo);
  
    // Handling errors.
***************
*** 449,465 ****
  
    // Quitting the function if A was not defined.
  
!   if (!IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
  
    if (uplo == 'U') {
  
!     for (i=0; i!=n; i++) {
        t = v[i];
        k = pcol[i+1];
        if ((k!=pcol[i])&&(irow[k-1]==i)) {
--- 450,466 ----
  
    // Quitting the function if A was not defined.
  
!   if (!this->IsDefined()) {
      throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::MultMv");
    }
  
    // Determining w = M.v.
  
!   for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
  
    if (uplo == 'U') {
  
!     for (i=0; i!=this->n; i++) {
        t = v[i];
        k = pcol[i+1];
        if ((k!=pcol[i])&&(irow[k-1]==i)) {
***************
*** 475,481 ****
    }
    else {
  
!     for (i=0; i!=n; i++) {
        t = v[i];
        k = pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
--- 476,482 ----
    }
    else {
  
!     for (i=0; i!=this->n; i++) {
        t = v[i];
        k = pcol[i];
        if ((k!=pcol[i+1])&&(irow[k]==i)) {
***************
*** 506,514 ****
  
    // Solving A.w = v (or AsI.w = v).
  
!   ARTYPE* space = new ARTYPE[2*n];
  
!   um2so(n, 0, false, lvalue, lindex, value, index,
          keep, v, w, space, cntl, icntl, info, rinfo);
  
    delete[] space;
--- 507,515 ----
  
    // Solving A.w = v (or AsI.w = v).
  
!   ARTYPE* space = new ARTYPE[2*this->n];
  
!   um2so(this->n, 0, false, lvalue, lindex, value, index,
          keep, v, w, space, cntl, icntl, info, rinfo);
  
    delete[] space;
***************
*** 525,537 ****
  
    // Defining member variables.
  
!   m         = np;
!   n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[n]   = nnz;
    uplo      = uplop;
    fillin    = (fillinp>2) ? fillinp : 2;
    threshold = thresholdp;
--- 526,538 ----
  
    // Defining member variables.
  
!   this->m         = np;
!   this->n         = np;
    nnz       = nnzp;
    a         = ap;
    irow      = irowp;
    pcol      = pcolp;
!   pcol[this->n]   = nnz;
    uplo      = uplop;
    fillin    = (fillinp>2) ? fillinp : 2;
    threshold = thresholdp;
***************
*** 549,555 ****
                        "ARumSymMatrix::DefineMatrix");
    }
    else {
!     defined = true;
    }
  
  } // DefineMatrix.
--- 550,556 ----
                        "ARumSymMatrix::DefineMatrix");
    }
    else {
!     this->defined = true;
    }
  
  } // DefineMatrix.
***************
*** 571,577 ****
  
  template<class ARTYPE>
  ARumSymMatrix<ARTYPE>::
! ARumSymMatrix(char* file, double thresholdp, int fillinp,
                bool reducible, bool check)
  {
  
--- 572,578 ----
  
  template<class ARTYPE>
  ARumSymMatrix<ARTYPE>::
! ARumSymMatrix(const std::string& file, double thresholdp, int fillinp,
                bool reducible, bool check)
  {
  
diff -crB arpack++/include/arusnsym.h arpack++new/include/arusnsym.h
*** arpack++/include/arusnsym.h	2000-02-21 12:35:24.000000000 -0500
--- arpack++new/include/arusnsym.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARUSNSYM_H
  #define ARUSNSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arsnsym.h"
  #include "arunsmat.h"
--- 18,25 ----
  #ifndef ARUSNSYM_H
  #define ARUSNSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arsnsym.h"
  #include "arunsmat.h"
***************
*** 46,58 ****
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 47,59 ----
    // Short constructor.
  
    ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                    ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                     ARFLOAT tolp = 0.0, int maxitp = 0,
                     ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 80,92 ****
  inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 81,93 ----
  inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = 0.0;
!   this->mode      = 3;
!   this->iparam[7] = this->mode;
  
!   this->objOP->FactorAsI(this->sigmaR);
!   this->Restart();
  
  } // ChangeShift.
  
***************
*** 96,102 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode(objOP, &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 97,103 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetRegularMode(this->objOP, &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 106,112 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, 
                         &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
--- 107,113 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP, 
                         &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
***************
*** 115,126 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   NoShift();
    DefineParameters(A.ncols(), nevp, &A, 
                     &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
--- 116,127 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->NoShift();
    DefineParameters(A.ncols(), nevp, &A, 
                     &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
***************
*** 131,137 ****
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
--- 132,138 ----
  template<class ARFLOAT>
  inline ARluNonSymStdEig<ARFLOAT>::
  ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,
!                  ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                   int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
***************
*** 150,156 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 151,157 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/arussym.h arpack++new/include/arussym.h
*** arpack++/include/arussym.h	2000-02-21 11:57:27.000000000 -0500
--- arpack++new/include/arussym.h	2013-01-04 11:57:58.000000000 -0500
***************
*** 18,24 ****
  #ifndef ARUSSYM_H
  #define ARUSSYM_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arssym.h"
  #include "arusmat.h"
--- 18,25 ----
  #ifndef ARUSSYM_H
  #define ARUSSYM_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arssym.h"
  #include "arusmat.h"
***************
*** 46,58 ****
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, char* whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
--- 47,59 ----
    // Short constructor.
  
    ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (regular mode).
  
    ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!                 ARFLOAT sigma, const std::string& whichp = "LM", int ncvp = 0,
                  ARFLOAT tolp = 0.0, int maxitp = 0,
                  ARFLOAT* residp = NULL, bool ishiftp = true);
    // Long constructor (shift and invert mode).
***************
*** 80,92 ****
  inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   sigmaR    = sigmaRp;
!   sigmaI    = 0.0;
!   mode      = 3;
!   iparam[7] = mode;
  
!   objOP->FactorAsI(sigmaR);
!   Restart();
  
  } // ChangeShift.
  
--- 81,93 ----
  inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
  {
  
!   this->sigmaR    = sigmaRp;
!   this->sigmaI    = 0.0;
!   this->mode      = 3;
!   this->iparam[7] = this->mode;
  
!   this->objOP->FactorAsI(this->sigmaR);
!   this->Restart();
  
  } // ChangeShift.
  
***************
*** 96,102 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
!     SetRegularMode(objOP, &ARumSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
--- 97,103 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
!     SetRegularMode(this->objOP, &ARumSymMatrix<ARFLOAT>::MultMv);
  
  } // SetRegularMode.
  
***************
*** 106,112 ****
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, objOP, &ARumSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
--- 107,113 ----
  {
  
    ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
!     SetShiftInvertMode(sigmap, this->objOP, &ARumSymMatrix<ARFLOAT>::MultInvv);
  
  } // SetShiftInvertMode.
  
***************
*** 114,125 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!               char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   NoShift();
!   DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
--- 115,126 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!               const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  {
  
!   this->NoShift();
!   this->DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultMv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
  
  } // Long constructor (regular mode).
***************
*** 128,139 ****
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, char* whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
--- 129,140 ----
  template<class ARFLOAT>
  inline ARluSymStdEig<ARFLOAT>::
  ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,
!               ARFLOAT sigmap, const std::string& whichp, int ncvp, ARFLOAT tolp,
                int maxitp, ARFLOAT* residp, bool ishiftp)
  
  {
  
!   this->DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultInvv,
                     whichp, ncvp, tolp, maxitp, residp, ishiftp);
    ChangeShift(sigmap);
  
***************
*** 146,152 ****
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     ClearMem();
      Copy(other);
    }
    return *this;
--- 147,153 ----
  {
  
    if (this != &other) { // Stroustrup suggestion.
!     this->ClearMem();
      Copy(other);
    }
    return *this;
diff -crB arpack++/include/caupp.h arpack++new/include/caupp.h
*** arpack++/include/caupp.h	2000-02-21 06:55:52.000000000 -0500
--- arpack++new/include/caupp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,26 ****
  #ifndef CAUPP_H
  #define CAUPP_H
  
  #include "arch.h"
  #include "arpackf.h"
  
! inline void caupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,
                    double& tol, arcomplex<double> resid[], ARint ncv,
                    arcomplex<double> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<double> workd[], 
--- 17,27 ----
  #ifndef CAUPP_H
  #define CAUPP_H
  
+ #include <string>
  #include "arch.h"
  #include "arpackf.h"
  
! inline void caupp(ARint& ido, char bmat, ARint n, const std::string& which, ARint nev,
                    double& tol, arcomplex<double> resid[], ARint ncv,
                    arcomplex<double> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<double> workd[], 
***************
*** 285,297 ****
  
  {
  
!   F77NAME(znaupd)(&ido, &bmat, &n, which, &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1],
                    &workl[1], &lworkl, &rwork[1], &info);
  
  } // caupp (arcomplex<double>).
  
! inline void caupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,
                    float& tol, arcomplex<float> resid[], ARint ncv,
                    arcomplex<float> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<float> workd[], 
--- 286,298 ----
  
  {
  
!   F77NAME(znaupd)(&ido, &bmat, &n, which.c_str(), &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1],
                    &workl[1], &lworkl, &rwork[1], &info);
  
  } // caupp (arcomplex<double>).
  
! inline void caupp(ARint& ido, char bmat, ARint n, const std::string& which, ARint nev,
                    float& tol, arcomplex<float> resid[], ARint ncv,
                    arcomplex<float> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<float> workd[], 
***************
*** 307,313 ****
  
  {
  
!   F77NAME(cnaupd)(&ido, &bmat, &n, which, &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1],
                    &workl[1], &lworkl, &rwork[1], &info);
  
--- 308,314 ----
  
  {
  
!   F77NAME(cnaupd)(&ido, &bmat, &n, which.c_str(), &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1],
                    &workl[1], &lworkl, &rwork[1], &info);
  
diff -crB arpack++/include/ceupp.h arpack++new/include/ceupp.h
*** arpack++/include/ceupp.h	2000-02-21 06:54:11.000000000 -0500
--- arpack++new/include/ceupp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,29 ****
  #ifndef CEUPP_H
  #define CEUPP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arpackf.h"
  
  inline void ceupp(bool rvec, char HowMny, arcomplex<double> d[],
                    arcomplex<double> Z[], ARint ldz, arcomplex<double> sigma,
!                   arcomplex<double> workev[], char bmat, ARint n, char* which,
                    ARint nev, double tol, arcomplex<double> resid[], ARint ncv,
                    arcomplex<double> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<double> workd[], 
--- 17,30 ----
  #ifndef CEUPP_H
  #define CEUPP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arpackf.h"
  
  inline void ceupp(bool rvec, char HowMny, arcomplex<double> d[],
                    arcomplex<double> Z[], ARint ldz, arcomplex<double> sigma,
!                   arcomplex<double> workev[], char bmat, ARint n, const std::string& which,
                    ARint nev, double tol, arcomplex<double> resid[], ARint ncv,
                    arcomplex<double> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<double> workd[], 
***************
*** 177,183 ****
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(zneupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma,
!                   &workev[1], &bmat, &n, which, &nev, &tol, resid,
                    &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &rwork[1], &info);
  
--- 178,184 ----
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(zneupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma,
!                   &workev[1], &bmat, &n, which.c_str(), &nev, &tol, resid,
                    &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &rwork[1], &info);
  
***************
*** 187,193 ****
  
  inline void ceupp(bool rvec, char HowMny, arcomplex<float> d[],
                    arcomplex<float> Z[], ARint ldz, arcomplex<float> sigma,
!                   arcomplex<float> workev[], char bmat, ARint n, char* which,
                    ARint nev, float tol, arcomplex<float> resid[], ARint ncv,
                    arcomplex<float> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<float> workd[], 
--- 188,194 ----
  
  inline void ceupp(bool rvec, char HowMny, arcomplex<float> d[],
                    arcomplex<float> Z[], ARint ldz, arcomplex<float> sigma,
!                   arcomplex<float> workev[], char bmat, ARint n, const std::string& which,
                    ARint nev, float tol, arcomplex<float> resid[], ARint ncv,
                    arcomplex<float> V[], ARint ldv, ARint iparam[], 
                    ARint ipntr[], arcomplex<float> workd[], 
***************
*** 212,218 ****
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(cneupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma,
!                   &workev[1], &bmat, &n, which, &nev, &tol, resid,
                    &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &rwork[1], &info);
  
--- 213,219 ----
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(cneupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma,
!                   &workev[1], &bmat, &n, which.c_str(), &nev, &tol, resid,
                    &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &rwork[1], &info);
  
diff -crB arpack++/include/naupp.h arpack++new/include/naupp.h
*** arpack++/include/naupp.h	2000-02-21 06:52:05.000000000 -0500
--- arpack++new/include/naupp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,26 ****
  #ifndef NAUPP_H
  #define NAUPP_H
  
  #include "arch.h"
  #include "arpackf.h"
  
! inline void naupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,
                    double& tol, double resid[], ARint ncv, double V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], double workd[],
                    double workl[], ARint lworkl, ARint& info)
--- 17,27 ----
  #ifndef NAUPP_H
  #define NAUPP_H
  
+ #include <string>
  #include "arch.h"
  #include "arpackf.h"
  
! inline void naupp(ARint& ido, char bmat, ARint n, const std::string& which, ARint nev,
                    double& tol, double resid[], ARint ncv, double V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], double workd[],
                    double workl[], ARint lworkl, ARint& info)
***************
*** 302,314 ****
  
  {
  
!   F77NAME(dnaupd)(&ido, &bmat, &n, which, &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
  } // naupp (double).
  
! inline void naupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,
                    float& tol, float resid[], ARint ncv, float V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], float workd[],
                    float workl[], ARint lworkl, ARint& info)
--- 303,315 ----
  
  {
  
!   F77NAME(dnaupd)(&ido, &bmat, &n, which.c_str(), &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
  } // naupp (double).
  
! inline void naupp(ARint& ido, char bmat, ARint n, const std::string& which, ARint nev,
                    float& tol, float resid[], ARint ncv, float V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], float workd[],
                    float workl[], ARint lworkl, ARint& info)
***************
*** 322,328 ****
  
  {
  
!   F77NAME(snaupd)(&ido, &bmat, &n, which, &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
--- 323,329 ----
  
  {
  
!   F77NAME(snaupd)(&ido, &bmat, &n, which.c_str(), &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
diff -crB arpack++/include/neupp.h arpack++new/include/neupp.h
*** arpack++/include/neupp.h	2000-02-21 06:51:10.000000000 -0500
--- arpack++new/include/neupp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,30 ****
  #ifndef NEUPP_H
  #define NEUPP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arpackf.h"
  
  inline void neupp(bool rvec, char HowMny, double dr[],
                    double di[], double Z[], ARint ldz, double sigmar,
                    double sigmai, double workv[], char bmat, ARint n,
!                   char* which, ARint nev, double tol, double resid[],
                    ARint ncv, double V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], double workd[], double workl[],
                    ARint lworkl, ARint& info)
--- 17,31 ----
  #ifndef NEUPP_H
  #define NEUPP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arpackf.h"
  
  inline void neupp(bool rvec, char HowMny, double dr[],
                    double di[], double Z[], ARint ldz, double sigmar,
                    double sigmai, double workv[], char bmat, ARint n,
!                   const std::string& which, ARint nev, double tol, double resid[],
                    ARint ncv, double V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], double workd[], double workl[],
                    ARint lworkl, ARint& info)
***************
*** 223,229 ****
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(dneupd)(&irvec, &HowMny, iselect, dr, di, iZ, &ldz, &sigmar,
!                   &sigmai, &workv[1], &bmat, &n, which, &nev, &tol,
                    resid, &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &info);
  
--- 224,230 ----
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(dneupd)(&irvec, &HowMny, iselect, dr, di, iZ, &ldz, &sigmar,
!                   &sigmai, &workv[1], &bmat, &n, which.c_str(), &nev, &tol,
                    resid, &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &info);
  
***************
*** 234,240 ****
  inline void neupp(bool rvec, char HowMny, float dr[],
                    float di[], float Z[], ARint ldz, float sigmar,
                    float sigmai, float workv[], char bmat, ARint n,
!                   char* which, ARint nev, float tol, float resid[],
                    ARint ncv, float V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], float workd[], float workl[],
                    ARint lworkl, ARint& info)
--- 235,241 ----
  inline void neupp(bool rvec, char HowMny, float dr[],
                    float di[], float Z[], ARint ldz, float sigmar,
                    float sigmai, float workv[], char bmat, ARint n,
!                   const std::string& which, ARint nev, float tol, float resid[],
                    ARint ncv, float V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], float workd[], float workl[],
                    ARint lworkl, ARint& info)
***************
*** 257,263 ****
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(sneupd)(&irvec, &HowMny, iselect, dr, di, iZ, &ldz, &sigmar,
!                   &sigmai, &workv[1], &bmat, &n, which, &nev, &tol,
                    resid, &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &info );
  
--- 258,264 ----
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(sneupd)(&irvec, &HowMny, iselect, dr, di, iZ, &ldz, &sigmar,
!                   &sigmai, &workv[1], &bmat, &n, which.c_str(), &nev, &tol,
                    resid, &ncv, &V[1], &ldv, &iparam[1], &ipntr[1],
                    &workd[1], &workl[1], &lworkl, &info );
  
diff -crB arpack++/include/README arpack++new/include/README
*** arpack++/include/README	2073-03-19 04:12:44.000000000 -0400
--- arpack++new/include/README	2013-01-04 11:51:23.000000000 -0500
***************
*** 129,135 ****
                          csp_defs.h and zsp_defs.h header files.
        arlsupm.h         Unaltered copy of supermatrix.h header file.
        arlnames.h        Unaltered copy of Cnames.h header file.
!       arlutil.h         Unaltered copy of util.h header file.
        arlcomp.h         Unaltered copy of dcomplex.h and scomplex.h.
  
  
--- 129,135 ----
                          csp_defs.h and zsp_defs.h header files.
        arlsupm.h         Unaltered copy of supermatrix.h header file.
        arlnames.h        Unaltered copy of Cnames.h header file.
!       arlutil.h         Unaltered copy of util.h, superlu_enum_consts.h.
        arlcomp.h         Unaltered copy of dcomplex.h and scomplex.h.
  
  
diff -crB arpack++/include/saupp.h arpack++new/include/saupp.h
*** arpack++/include/saupp.h	2000-02-21 06:56:49.000000000 -0500
--- arpack++new/include/saupp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,26 ****
  #ifndef SAUPP_H
  #define SAUPP_H
  
  #include "arch.h"
  #include "arpackf.h"
  
! inline void saupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,
                    double& tol, double resid[], ARint ncv, double V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], double workd[],
                    double workl[], ARint lworkl, ARint& info)
--- 17,27 ----
  #ifndef SAUPP_H
  #define SAUPP_H
  
+ #include <string>
  #include "arch.h"
  #include "arpackf.h"
  
! inline void saupp(ARint& ido, char bmat, ARint n, const std::string& which, ARint nev,
                    double& tol, double resid[], ARint ncv, double V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], double workd[],
                    double workl[], ARint lworkl, ARint& info)
***************
*** 290,302 ****
  
  {
  
!   F77NAME(dsaupd)(&ido, &bmat, &n, which, &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
  } // saupp (double).
  
! inline void saupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,
                    float& tol, float resid[], ARint ncv, float V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], float workd[],
                    float workl[], ARint lworkl, ARint& info)
--- 291,303 ----
  
  {
  
!   F77NAME(dsaupd)(&ido, &bmat, &n, which.c_str(), &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
  } // saupp (double).
  
! inline void saupp(ARint& ido, char bmat, ARint n, const std::string& which, ARint nev,
                    float& tol, float resid[], ARint ncv, float V[],
                    ARint ldv, ARint iparam[], ARint ipntr[], float workd[],
                    float workl[], ARint lworkl, ARint& info)
***************
*** 310,316 ****
  
  {
  
!   F77NAME(ssaupd)(&ido, &bmat, &n, which, &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
--- 311,317 ----
  
  {
  
!   F77NAME(ssaupd)(&ido, &bmat, &n, which.c_str(), &nev, &tol, resid, &ncv,
                    &V[1], &ldv, &iparam[1], &ipntr[1], &workd[1], &workl[1],
                    &lworkl, &info);
  
diff -crB arpack++/include/seupp.h arpack++new/include/seupp.h
*** arpack++/include/seupp.h	2000-02-21 06:57:23.000000000 -0500
--- arpack++new/include/seupp.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 17,29 ****
  #ifndef SEUPP_H
  #define SEUPP_H
  
! #include <stddef.h>
  #include "arch.h"
  #include "arpackf.h"
  
  inline void seupp(bool rvec, char HowMny, double d[], double Z[],
                    ARint ldz, double sigma, char bmat, ARint n,
!                   char* which, ARint nev, double tol, double resid[],
                    ARint ncv, double V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], double workd[], double workl[],
                    ARint lworkl, ARint& info)
--- 17,30 ----
  #ifndef SEUPP_H
  #define SEUPP_H
  
! #include <cstddef>
! #include <string>
  #include "arch.h"
  #include "arpackf.h"
  
  inline void seupp(bool rvec, char HowMny, double d[], double Z[],
                    ARint ldz, double sigma, char bmat, ARint n,
!                   const std::string& which, ARint nev, double tol, double resid[],
                    ARint ncv, double V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], double workd[], double workl[],
                    ARint lworkl, ARint& info)
***************
*** 146,152 ****
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(dseupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma, &bmat,
!                   &n, which, &nev, &tol, resid, &ncv, &V[1], &ldv, &iparam[1],
                    &ipntr[1], &workd[1], &workl[1], &lworkl, &info );
  
    delete[] iselect;
--- 147,153 ----
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(dseupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma, &bmat,
!                   &n, which.c_str(), &nev, &tol, resid, &ncv, &V[1], &ldv, &iparam[1],
                    &ipntr[1], &workd[1], &workl[1], &lworkl, &info );
  
    delete[] iselect;
***************
*** 155,161 ****
  
  inline void seupp(bool rvec, char HowMny, float d[], float Z[],
                    ARint ldz, float sigma, char bmat, ARint n,
!                   char* which, ARint nev, float tol, float resid[],
                    ARint ncv, float V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], float workd[], float workl[],
                    ARint lworkl, ARint& info)
--- 156,162 ----
  
  inline void seupp(bool rvec, char HowMny, float d[], float Z[],
                    ARint ldz, float sigma, char bmat, ARint n,
!                   const std::string& which, ARint nev, float tol, float resid[],
                    ARint ncv, float V[], ARint ldv, ARint iparam[],
                    ARint ipntr[], float workd[], float workl[],
                    ARint lworkl, ARint& info)
***************
*** 178,184 ****
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(sseupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma, &bmat,
!                   &n, which, &nev, &tol, resid, &ncv, &V[1], &ldv, &iparam[1],
                    &ipntr[1], &workd[1], &workl[1], &lworkl, &info );
  
    delete[] iselect;
--- 179,185 ----
    iZ = (Z == NULL) ? &V[1] : Z;
  
    F77NAME(sseupd)(&irvec, &HowMny, iselect, d, iZ, &ldz, &sigma, &bmat,
!                   &n, which.c_str(), &nev, &tol, resid, &ncv, &V[1], &ldv, &iparam[1],
                    &ipntr[1], &workd[1], &workl[1], &lworkl, &info );
  
    delete[] iselect;
diff -crB arpack++/include/superluc.h arpack++new/include/superluc.h
*** arpack++/include/superluc.h	2000-02-21 13:04:07.000000000 -0500
--- arpack++new/include/superluc.h	2013-01-04 11:51:23.000000000 -0500
***************
*** 24,77 ****
  
  // gstrf.
  
! inline void gstrf(char* refact, SuperMatrix* A, double diag_pivot_thresh,
!                   double drop_tol, int relax, int panel_size,
!                   int* etree, void* work, int lwork, int* perm_r,
!                   int *perm_c, SuperMatrix *L, SuperMatrix *U, int *info)
! {
! 
!   if (A->Dtype == _D) {       // calling the double precision routine.
!     dgstrf(refact,A,diag_pivot_thresh,drop_tol,relax,
!            panel_size,etree,work,lwork,perm_r,perm_c,L,U,info);
!   }
!   else if (A->Dtype == _S) {  // calling the single precision routine.
!     sgstrf(refact,A,(float)diag_pivot_thresh,(float)drop_tol,relax,
!            panel_size,etree,work,lwork,perm_r,perm_c,L,U,info);
    }
!   else if (A->Dtype == _Z) {  // calling the double precision complex routine.
  #ifdef ARCOMP_H
!     zgstrf(refact,A,diag_pivot_thresh,drop_tol,relax,
!            panel_size,etree,work,lwork,perm_r,perm_c,L,U,info);
  #endif
    }
    else {                      // calling the single precision complex routine.
  #ifdef ARCOMP_H
!     cgstrf(refact,A,(float)diag_pivot_thresh,(float)drop_tol,relax,
!            panel_size,etree,work,lwork,perm_r,perm_c,L,U,info);
  #endif
    }
  
  } // gstrf.
  
  
! inline void gstrs(char *trans, SuperMatrix *L, SuperMatrix *U,
! 	          int *perm_r, int *perm_c, SuperMatrix *B, int *info)
  {
  
!   if (L->Dtype == _D) {       // calling the double precision routine.
!     dgstrs(trans,L,U,perm_r,perm_c,B,info);
    }
!   else if (L->Dtype == _S) {  // calling the single precision routine.
!     sgstrs(trans,L,U,perm_r,perm_c,B,info);
    }
!   else if (L->Dtype == _Z) {  // calling the double precision complex routine.
  #ifdef ARCOMP_H
!     zgstrs(trans,L,U,perm_r,perm_c,B,info);
  #endif
    }
    else {                      // calling the single precision complex routine.
  #ifdef ARCOMP_H
!     cgstrs(trans,L,U,perm_r,perm_c,B,info);
  #endif
    }
  
--- 24,81 ----
  
  // gstrf.
  
! inline void gstrf(superlu_options_t *options, SuperMatrix *A, double drop_tol,
!         int relax, int panel_size, int *etree, void *work, int lwork,
!         int *perm_c, int *perm_r, SuperMatrix *L, SuperMatrix *U,
!         SuperLUStat_t *stat, int *info)
! //		  superlu_options_t* options, SuperMatrix* A, double diag_pivot_thresh,
! //                  double drop_tol, int relax, int panel_size,
! //                  int* etree, void* work, int lwork, int* perm_r,
! //                  int *perm_c, SuperMatrix *L, SuperMatrix *U, SuperLUStat_t* stat, int *info)
! {
! 
!   if (A->Dtype == SLU_D) {       // calling the double precision routine.
!     dgstrf(options,A,drop_tol,relax,
!            panel_size,etree,work,lwork,perm_c,perm_r,L,U,stat,info);
!   }
!   else if (A->Dtype == SLU_S) {  // calling the single precision routine.
!     sgstrf(options,A,(float)drop_tol,relax,
!            panel_size,etree,work,lwork,perm_c,perm_r,L,U,stat,info);
    }
!   else if (A->Dtype == SLU_Z) {  // calling the double precision complex routine.
  #ifdef ARCOMP_H
!     zgstrf(options,A,drop_tol,relax,
!            panel_size,etree,work,lwork,perm_c,perm_r,L,U,stat,info);
  #endif
    }
    else {                      // calling the single precision complex routine.
  #ifdef ARCOMP_H
!     cgstrf(options,A,(float)drop_tol,relax,
!            panel_size,etree,work,lwork,perm_c,perm_r,L,U,stat,info);
  #endif
    }
  
  } // gstrf.
  
  
! inline void gstrs(trans_t trans, SuperMatrix *L, SuperMatrix *U,
! 	          int *perm_c, int *perm_r, SuperMatrix *B, SuperLUStat_t* stat, int *info)
  {
  
!   if (L->Dtype == SLU_D) {       // calling the double precision routine.
!     dgstrs(trans,L,U,perm_c,perm_r,B,stat,info);
    }
!   else if (L->Dtype == SLU_S) {  // calling the single precision routine.
!     sgstrs(trans,L,U,perm_c,perm_r,B,stat,info);
    }
!   else if (L->Dtype == SLU_Z) {  // calling the double precision complex routine.
  #ifdef ARCOMP_H
!     zgstrs(trans,L,U,perm_c,perm_r,B,stat,info);
  #endif
    }
    else {                      // calling the single precision complex routine.
  #ifdef ARCOMP_H
!     cgstrs(trans,L,U,perm_c,perm_r,B,stat,info);
  #endif
    }
  
***************
*** 85,91 ****
                                    Stype_t S, Mtype_t M)
  {
  
!   dCreate_CompCol_Matrix(A,m,n,nnz,a,irow,pcol,S,_D,M);
  
  } // Create_CompCol_Matrix (double).
  
--- 89,95 ----
                                    Stype_t S, Mtype_t M)
  {
  
!   dCreate_CompCol_Matrix(A,m,n,nnz,a,irow,pcol,S,SLU_D,M);
  
  } // Create_CompCol_Matrix (double).
  
***************
*** 94,100 ****
                                    Stype_t S, Mtype_t M)
  {
  
!   sCreate_CompCol_Matrix(A,m,n,nnz,a,irow,pcol,S,_S,M);
  
  } // Create_CompCol_Matrix (float).
  
--- 98,104 ----
                                    Stype_t S, Mtype_t M)
  {
  
!   sCreate_CompCol_Matrix(A,m,n,nnz,a,irow,pcol,S,SLU_S,M);
  
  } // Create_CompCol_Matrix (float).
  
***************
*** 105,111 ****
                                    Stype_t S, Mtype_t M)
  {
  
!   zCreate_CompCol_Matrix(A,m,n,nnz,(ldcomplex*)a,irow,pcol,S,_Z,M);
  
  } // Create_CompCol_Matrix (complex<double>).
  
--- 109,115 ----
                                    Stype_t S, Mtype_t M)
  {
  
!   zCreate_CompCol_Matrix(A,m,n,nnz,(ldcomplex*)a,irow,pcol,S,SLU_Z,M);
  
  } // Create_CompCol_Matrix (complex<double>).
  
***************
*** 114,120 ****
                                    Stype_t S, Mtype_t M)
  {
  
!   cCreate_CompCol_Matrix(A,m,n,nnz,(lscomplex*)a,irow,pcol,S,_C,M);
  
  } // Create_CompCol_Matrix (complex<float>).
  
--- 118,124 ----
                                    Stype_t S, Mtype_t M)
  {
  
!   cCreate_CompCol_Matrix(A,m,n,nnz,(lscomplex*)a,irow,pcol,S,SLU_C,M);
  
  } // Create_CompCol_Matrix (complex<float>).
  
***************
*** 127,133 ****
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   dCreate_Dense_Matrix(A,m,n,x,ldx,S,_D,M);
  
  } // Create_Dense_Matrix (double).
  
--- 131,137 ----
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   dCreate_Dense_Matrix(A,m,n,x,ldx,S,SLU_D,M);
  
  } // Create_Dense_Matrix (double).
  
***************
*** 135,141 ****
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   sCreate_Dense_Matrix(A,m,n,x,ldx,S,_S,M);
  
  } // Create_Dense_Matrix (float).
  
--- 139,145 ----
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   sCreate_Dense_Matrix(A,m,n,x,ldx,S,SLU_S,M);
  
  } // Create_Dense_Matrix (float).
  
***************
*** 145,151 ****
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   zCreate_Dense_Matrix(A,m,n,(ldcomplex*)x,ldx,S,_Z,M);
  
  } // Create_Dense_Matrix (complex<double>).
  
--- 149,155 ----
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   zCreate_Dense_Matrix(A,m,n,(ldcomplex*)x,ldx,S,SLU_Z,M);
  
  } // Create_Dense_Matrix (complex<double>).
  
***************
*** 153,159 ****
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   cCreate_Dense_Matrix(A,m,n,(lscomplex*)x,ldx,S,_C,M);
  
  } // Create_Dense_Matrix (complex<float>).
  
--- 157,163 ----
                                  int ldx, Stype_t S, Mtype_t M)
  {
  
!   cCreate_Dense_Matrix(A,m,n,(lscomplex*)x,ldx,S,SLU_C,M);
  
  } // Create_Dense_Matrix (complex<float>).
  
diff -crB arpack++/Makefile.inc arpack++new/Makefile.inc
*** arpack++/Makefile.inc	2000-04-05 08:00:59.000000000 -0400
--- arpack++new/Makefile.inc	2013-01-04 11:54:47.000000000 -0500
***************
*** 6,12 ****
  
  # Defining the machine.
  
! PLAT         = solaris
  
  # Defining the compiler.
  
--- 6,12 ----
  
  # Defining the machine.
  
! PLAT         = linux
  
  # Defining the compiler.
  
***************
*** 16,22 ****
  # ARPACKPP_INC is the directory that contains all arpack++ header files.
  # SUPERLU_DIR and UMFPACK_DIR must be set to ARPACKPP_INC.
  
! ARPACKPP_DIR = $(HOME)/arpack++
  ARPACKPP_INC = $(ARPACKPP_DIR)/include
  SUPERLU_DIR  = $(ARPACKPP_INC)
  UMFPACK_DIR  = $(ARPACKPP_INC)
--- 16,23 ----
  # ARPACKPP_INC is the directory that contains all arpack++ header files.
  # SUPERLU_DIR and UMFPACK_DIR must be set to ARPACKPP_INC.
  
! #ARPACKPP_DIR = $(HOME)/arpack++
! ARPACKPP_DIR = ../../..
  ARPACKPP_INC = $(ARPACKPP_DIR)/include
  SUPERLU_DIR  = $(ARPACKPP_INC)
  UMFPACK_DIR  = $(ARPACKPP_INC)
***************
*** 33,46 ****
  # Other libraries should be defined if the user intends to compile
  # arpack++ on another environment.
  
! ARPACK_LIB   = $(HOME)/lib/arpack_$(PLAT).a
! LAPACK_LIB   = /opt/LAPACK/lapack_$(PLAT).a
! UMFPACK_LIB  = $(HOME)/lib/umfpack_$(PLAT).a
! SUPERLU_LIB  = $(HOME)/lib/superlu_$(PLAT).a
! BLAS_LIB     = /opt/LAPACK/blas_$(PLAT).a 
! FORTRAN_LIBS = /opt/SUNWspro/SC4.0/lib/libF77.a \
!                /opt/SUNWspro/SC4.0/lib/libM77.a \
!                /opt/SUNWspro/SC4.0/lib/libsunmath.a
  
  # Defining g++ flags and directories.
  
--- 34,45 ----
  # Other libraries should be defined if the user intends to compile
  # arpack++ on another environment.
  
! ARPACK_LIB   = -larpack
! LAPACK_LIB   = -llapack
! UMFPACK_LIB  = #-lumfpack
! SUPERLU_LIB  = -lsuperlu
! BLAS_LIB     = -lblas
! FORTRAN_LIBS = -lgfortran
  
  # Defining g++ flags and directories.
  
***************
*** 49,63 ****
  CPP_DEBUG    = -g
  CPP_OPTIM    = -O
  CPP_LIBS     = 
! CPP_INC      = /usr/local/include/g++-3
  
  CPP_FLAGS    = $(CPP_DEBUG) -D$(PLAT) -I$(ARPACKPP_INC) -I$(CPP_INC) \
                 $(CPP_WARNINGS)
  
  # Putting all libraries together.
  
! ALL_LIBS     = $(CPP_LIBS) $(ARPACK_LIB) $(LAPACK_LIB) \
!                $(BLAS_LIB) $(FORTRAN_LIBS) 
  
  # defining paths.
  
--- 48,62 ----
  CPP_DEBUG    = -g
  CPP_OPTIM    = -O
  CPP_LIBS     = 
! CPP_INC      = 
  
  CPP_FLAGS    = $(CPP_DEBUG) -D$(PLAT) -I$(ARPACKPP_INC) -I$(CPP_INC) \
                 $(CPP_WARNINGS)
  
  # Putting all libraries together.
  
! ALL_LIBS     = $(CPP_LIBS) $(ARPACK_LIB) \
!                $(BLAS_LIB) $(LAPACK_LIB) $(FORTRAN_LIBS) 
  
  # defining paths.
  
